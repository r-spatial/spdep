[{"path":"https://r-spatial.github.io/spdep/articles/CO69.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"“The Problem of Spatial Autocorrelation:” forty years on","text":"Cliff Ord (1969), published forty years ago, marked turning point treatment spatial autocorrelation quantitative geography. provided framework needed applied researcher attempt implementation different system, possibly using different programming language. spirit, examine spatial weights represented implementations may reproduced, tabulated results paper may reproduced, may extended cover simulation. One major assertions Cliff Ord (1969) statistic advances measurement spatial autocorrelation respect Moran (1950) Geary (1954) general specification spatial weights used. general form implications preparation weights , calculation measures. look spatial weights first, moving consider measures presented paper subsequent developments. , put together data set matching used Cliff Ord (1969). provide tabulated data counties Irish Republic, omit Dublin analyses. shapefile included package, kindly made available Michael Tiefelsdorf, used starting point: read SpatialPolygonsDataFrame — classes used handling spatial data fully described Roger S. Bivand, Pebesma, Gómez-Rubio (2008). need add data tabulated paper Table 2,1 p. 40, form text file added rainfall values Table 9, p. 49: Since assigned county names feature identifiers reading shapefiles, extra data, combine objects: Finally, need drop Dublin county omitted analyses conducted Cliff Ord (1969): double-check data, let us calculate sample Beta coefficients, using formulae given paper sample moments: differ somewhat ways skewness kurtosis computed modern statistical software, see example Joanes Gill (1998). However, purposes, let us reproduce Table 3, p. 42: Using tabulated value 23.623.6 percentage agricultural holdings 50 1950 Waterford, skewness kurtosis reproduced, comparison irishdata dataset , turns value rather 26.626.6, yields tabulated skewness kurtosis values. going , variables considered presented Table varsvars. Description variables Geary data set.","code":"library(spdep) eire <- as(sf::st_read(system.file(\"shapes/eire.gpkg\", package=\"spData\")[1]), \"Spatial\") row.names(eire) <- as.character(eire$names) #proj4string(eire) <- CRS(\"+proj=utm +zone=30 +ellps=airy +units=km\") class(eire) ## [1] \"SpatialPolygonsDataFrame\" ## attr(,\"package\") ## [1] \"sp\" names(eire) ##  [1] \"A\"       \"towns\"   \"pale\"    \"size\"    \"ROADACC\" \"OWNCONS\" \"POPCHG\"  ##  [8] \"RETSALE\" \"INCOME\"  \"names\" fn <- system.file(\"etc/misc/geary_eire.txt\", package=\"spdep\")[1] ge <- read.table(fn, header=TRUE) names(ge) ##  [1] \"serlet\"        \"county\"        \"pagval2_10\"    \"pagval10_50\"   ##  [5] \"pagval50p\"     \"cowspacre\"     \"ocattlepacre\"  \"pigspacre\"     ##  [9] \"sheeppacre\"    \"townvillp\"     \"carspcap\"      \"radiopcap\"     ## [13] \"retailpcap\"    \"psinglem30_34\" \"rainfall\" row.names(ge) <- as.character(ge$county) all.equal(row.names(ge), row.names(eire)) ## [1] TRUE eire_ge <- cbind(eire, ge) eire_ge1 <- eire_ge[!(row.names(eire_ge) %in% \"Dublin\"),] length(row.names(eire_ge1)) ## [1] 25 skewness <- function(z) {z <- scale(z, scale=FALSE); ((sum(z^3)/length(z))^2)/((sum(z^2)/length(z))^3)} kurtosis <- function(z) {z <- scale(z, scale=FALSE); (sum(z^4)/length(z))/((sum(z^2)/length(z))^2)} print(sapply(as(eire_ge1, \"data.frame\")[13:24], skewness), digits=3) ##    pagval2_10   pagval10_50     pagval50p     cowspacre  ocattlepacre  ##      1.675429      1.294978      0.000382      1.682094      0.086267  ##     pigspacre    sheeppacre     townvillp      carspcap     radiopcap  ##      1.138387      1.842362      0.472748      0.011111      0.342805  ##    retailpcap psinglem30_34  ##      0.002765      0.068169 print(sapply(as(eire_ge1, \"data.frame\")[13:24], kurtosis), digits=4) ##    pagval2_10   pagval10_50     pagval50p     cowspacre  ocattlepacre  ##         3.790         4.331         1.508         4.294         2.985  ##     pigspacre    sheeppacre     townvillp      carspcap     radiopcap  ##         3.754         4.527         2.619         1.865         2.730  ##    retailpcap psinglem30_34  ##         2.188         2.034 print(sapply(as(eire_ge1, \"data.frame\")[c(13,16,18,19)], function(x) skewness(log(x))), digits=3) ## pagval2_10  cowspacre  pigspacre sheeppacre  ##    0.68801    0.17875    0.00767    0.04184 print(sapply(as(eire_ge1, \"data.frame\")[c(13,16,18,19)], function(x) kurtosis(log(x))), digits=4) ## pagval2_10  cowspacre  pigspacre sheeppacre  ##      2.883      2.799      2.212      2.421"},{"path":"https://r-spatial.github.io/spdep/articles/CO69.html","id":"spatial-weights","dir":"Articles","previous_headings":"","what":"Spatial weights","title":"“The Problem of Spatial Autocorrelation:” forty years on","text":"basis comparison, first read unstandardised weighting matrix given Table A1, p. 54, paper, reading file corrected misprint giving O rather D neighbour V: file, counties represented serial letters, ordering conversion integer index representation required reach representation similar SpatialStats module spatial neighbours: done , can change representation listw object, assigning appropriate style (generalised binary) unstandardised values: Note values S0, S1, S2 correspond closely given page 42 paper, 0.846886720.84688672, 0.018699860.01869986 0.122673190.12267319. discrepancies appear due rounding printed table weights. contiguous neighbours represented object match found using poly2nb. However, see reproduced contiguities smaller link count: missing link Clare Kerry, perhaps Tarbert–Killimer ferry, counties contiguous, Figure plot_nbplot\\_nb shows: County boundaries contiguities attempt also made reproduce generalised weights 25 Irish counties reported Cliff Ord (1969), Dublin omitted. Reproducing inverse distance component dij−1d_{ij}^{-1} generalised weights dij−1βi(j)d_{ij}^{-1} \\beta_{(j)} eased statement Cliff Ord (1973, 55) points chosen represent counties “geographic centres,” different centroids yielded applying chosen computational geometry function. distance metric given, may kilometers miles — tried, results sensitive difference applies equally across weights; miles used . Computing proportion shared distance measure βi(j)\\beta_{(j)} harder, requires availability full topology input polygons. Roger S. Bivand, Pebesma, Gómez-Rubio (2008, 244) show employ vect2neigh function (written Markus Neteler) package using GRASS GIS vector handling create full topology spaghetti vector data extract border segment lengths; similar approach also mentioned using ArcGIS coverages purpose. GRASS used create topology, next proportion shared distance measure calculated. compare, need remove Tarbert–Killimer ferry link manually, view summary original weights, well correlation coefficient reconstructed weights. Naturally, unless boundary coordinates used identical original analysis, presumably measured hand, small differences occur. Even though differences general weights, identical contiguities, small, consequences measure spatial autocorrelation substantial, use fifth variable, cattle per 1000 acres crops pasture (1952), see reconstructed weights seem “reveal” autocorrelation original weights.","code":"fn <- system.file(\"etc/misc/unstand_sn.txt\", package=\"spdep\")[1] unstand <- read.table(fn, header=TRUE) summary(unstand) ##      from                to                weight         ##  Length:110         Length:110         Min.   :0.000600   ##  Class :character   Class :character   1st Qu.:0.003225   ##  Mode  :character   Mode  :character   Median :0.007550   ##                                        Mean   :0.007705   ##                                        3rd Qu.:0.010225   ##                                        Max.   :0.032400 class(unstand) <- c(\"spatial.neighbour\", class(unstand)) of <- ordered(unstand$from) attr(unstand, \"region.id\") <- levels(of) unstand$from <- as.integer(of) unstand$to <- as.integer(ordered(unstand$to)) attr(unstand, \"n\") <- length(unique(unstand$from)) lw_unstand <- sn2listw(unstand) lw_unstand$style <- \"B\" lw_unstand ## Characteristics of weights list object: ## Neighbour list object: ## Number of regions: 25  ## Number of nonzero links: 110  ## Percentage nonzero weights: 17.6  ## Average number of links: 4.4  ##  ## Weights style: B  ## Weights constants summary: ##    n  nn     S0         S1        S2 ## B 25 625 0.8476 0.01871808 0.1229232 nb <- poly2nb(eire_ge1) nb ## Neighbour list object: ## Number of regions: 25  ## Number of nonzero links: 108  ## Percentage nonzero weights: 17.28  ## Average number of links: 4.32 xx <- diffnb(nb, lw_unstand$neighbours, verbose=TRUE) ## Neighbour difference for region id: Clare in relation to id: Kerry  ## Neighbour difference for region id: Kerry in relation to id: Clare plot(eire_ge1, border=\"grey60\") plot(nb, coordinates(eire_ge1), add=TRUE, pch=\".\", lwd=2) plot(xx, coordinates(eire_ge1), add=TRUE, pch=\".\", lwd=2, col=3) library(terra) v_eire_ge1 <-vect(eire_ge1) SG <- rasterize(v_eire_ge1, rast(nrows=70, ncols=50, extent=ext(v_eire_ge1)), field=\"county\") library(rgrass) grass_home <- \"/home/rsb/topics/grass/g820/grass82\" initGRASS(grass_home, home=tempdir(), SG=SG, override=TRUE) write_VECT(v_eire_ge1, \"eire\", flags=c(\"o\", \"overwrite\")) res <- vect2neigh(\"eire\", ID=\"serlet\") res$length <- res$length*1000 attr(res, \"external\") <- attr(res, \"external\")*1000 attr(res, \"total\") <- attr(res, \"total\")*1000 grass_borders <- sn2listw(res) raw_borders <- grass_borders$weights int_tot <- attr(res, \"total\") - attr(res, \"external\") prop_borders <- lapply(1:length(int_tot), function(i) raw_borders[[i]]/int_tot[i]) dlist <- nbdists(grass_borders$neighbours, coordinates(eire_ge1)) inv_dlist <- lapply(dlist, function(x) 1/(x/1.609344)) combo_km <- lapply(1:length(inv_dlist), function(i) inv_dlist[[i]]*prop_borders[[i]]) combo_km_lw <- nb2listw(grass_borders$neighbours, glist=combo_km, style=\"B\") summary(combo_km_lw) ## Characteristics of weights list object: ## Neighbour list object: ## Number of regions: 25  ## Number of nonzero links: 108  ## Percentage nonzero weights: 17.28  ## Average number of links: 4.32  ## Link number distribution: ##  ## 1 2 3 4 5 6 7 8  ## 1 2 5 5 8 1 2 1  ## 1 least connected region: ## E with 1 link ## 1 most connected region: ## V with 8 links ##  ## Weights style: B  ## Weights constants summary: ##    n  nn        S0       S1.5        S2 ## B 25 625 0.9083144 0.02191845 0.1427746 red_lw_unstand <- lw_unstand Clare <- which(attr(lw_unstand, \"region.id\") == \"C\") Kerry <- which(attr(lw_unstand, \"region.id\") == \"H\") Kerry_in_Clare <- which(lw_unstand$neighbours[[Clare]] == Kerry) Clare_in_Kerry <- which(lw_unstand$neighbours[[Kerry]] == Clare) red_lw_unstand$neighbours[[Clare]] <- red_lw_unstand$neighbours[[Clare]][-Kerry_in_Clare] red_lw_unstand$neighbours[[Kerry]] <- red_lw_unstand$neighbours[[Kerry]][-Clare_in_Kerry] red_lw_unstand$weights[[Clare]] <- red_lw_unstand$weights[[Clare]][-Kerry_in_Clare] red_lw_unstand$weights[[Kerry]] <- red_lw_unstand$weights[[Kerry]][-Clare_in_Kerry] summary(red_lw_unstand) ## Characteristics of weights list object: ## Neighbour list object: ## Number of regions: 25  ## Number of nonzero links: 108  ## Percentage nonzero weights: 17.28  ## Average number of links: 4.32  ## Link number distribution: ##  ## 1 2 3 4 5 6 7 8  ## 1 2 5 5 8 1 2 1  ## 1 least connected region: ## E with 1 link ## 1 most connected region: ## V with 8 links ##  ## Weights style: B  ## Weights constants summary: ##    n  nn     S0         S1        S2 ## B 25 625 0.8437 0.01870287 0.1222501 cor(unlist(red_lw_unstand$weights), unlist(combo_km_lw$weights)) ## [1] 0.969543 flatten <- function(x, digits=3, statistic=\"I\") {   res <- c(format(x$estimate, digits=digits),     format(x$statistic, digits=digits),     format.pval(x$p.value, digits=digits))   res <- matrix(res, ncol=length(res))   colnames(res) <- paste(c(\"\", \"E\", \"V\", \"SD_\", \"P_\"), \"I\", sep=\"\")   rownames(res) <- deparse(substitute(x))   res } `reconstructed weights` <- moran.test(eire_ge1$ocattlepacre, combo_km_lw) `original weights` <- moran.test(eire_ge1$ocattlepacre, red_lw_unstand) print(rbind(flatten(`reconstructed weights`), flatten(`original weights`)), quote=FALSE) ##                       I       EI      VI      SD_I P_I     ## reconstructed weights  0.3203 -0.0417  0.0225 2.41 0.00792 ## original weights       0.2779 -0.0417  0.0223 2.14 0.0161"},{"path":"https://r-spatial.github.io/spdep/articles/CO69.html","id":"measures-of-spatial-autocorrelation","dir":"Articles","previous_headings":"","what":"Measures of spatial autocorrelation","title":"“The Problem of Spatial Autocorrelation:” forty years on","text":"targets reproduction Tables 4 5 Cliff Ord (1969, 43–44), first containing standard deviates normality randomisation original Moran measure binary weights, original Geary measure binary weights, proposed measure unstandardised general weights, proposed measure row-standardised general weights. addition, four variables log-transformed basis skewness kurtosis results presented . carry transformation variables, generate additional binary row-standardised general spatial weights objects — note weights constants row-standardised general weights agree given p. 42 paper, allowing small differences due rounding weights values displayed paper (p. 54): standard representation measures : =n∑=1n∑j=1nwij∑=1n∑j=1nwij(xi−x‾)(xj−x‾)∑=1n(xi−x‾)2I = \\frac{n}{\\sum_{=1}^{n}\\sum_{j=1}^{n}w_{ij}} \\frac{\\sum_{=1}^{n}\\sum_{j=1}^{n}w_{ij}(x_i-\\bar{x})(x_j-\\bar{x})}{\\sum_{=1}^{n}(x_i - \\bar{x})^2} Moran’s II — paper termed proposed statistic, Geary’s CC: C=(n−1)2∑=1n∑j=1nwij∑=1n∑j=1nwij(xi−xj)2∑=1n(xi−x‾)2C = \\frac{(n-1)}{2\\sum_{=1}^{n}\\sum_{j=1}^{n}w_{ij}} \\frac{\\sum_{=1}^{n}\\sum_{j=1}^{n}w_{ij}(x_i-x_j)^2}{\\sum_{=1}^{n}(x_i - \\bar{x})^2} xi,=1,…,nx_i, =1, \\ldots, n nn observations numeric variable interest, wijw_{ij} spatial weights. order reproduce standard deviates given paper, sufficient apply moran.test variables three different spatial weights objects, two different values randomisation= argument. addition, geary.test applied single spatial weights objects, two different values randomisation= argument. order conduct 8 different tests 16 variables, use lapply list variables specified order, sapply list output objects name generate table row column order original (save copy six columns comparison bootstrap results ): values standard deviates agree Table 4 original paper, exception proposed statistic standardised weights normality untransformed variables. can see happened substituting weights constants standardised weights unstandardised weights: Next, let us look Table 5 original paper. tabulate values measures , , since expectation constant measure, square root variance measure randomisation — extracting values calculated : values follows, match original exception initial version Moran’s II first two columns. write function implementing equations 3 4: =∑=1n∑j=+1nwij(xi−x‾)(xj−x‾)∑=1n(xi−x‾)2I = \\frac{\\sum_{=1}^{n}\\sum_{j=+1}^{n}w_{ij}(x_i-\\bar{x})(x_j-\\bar{x})}{\\sum_{=1}^{n}(x_i - \\bar{x})^2} crucially inner summation +1…ni+1 \\ldots n, 1…n1 \\ldots n, can reproduce values measure shown original Table 5: variance term given equation 7 original paper case normality, randomisation; reference p. 28 equation 38 p. 26 permit reproduction values second column Table 5. variance equation given equation 1.35 Cliff Ord (1973, 9) either, time possible say tabulated values computed. Note since standard deviances reproduced correctly, can reproduced second column values using measure expectance, just matter establishing formula used, far proved possible.","code":"eire_ge1$ln_pagval2_10 <- log(eire_ge1$pagval2_10) eire_ge1$ln_cowspacre <- log(eire_ge1$cowspacre) eire_ge1$ln_pigspacre <- log(eire_ge1$pigspacre) eire_ge1$ln_sheeppacre <- log(eire_ge1$sheeppacre) vars <- c(\"pagval2_10\", \"ln_pagval2_10\", \"pagval10_50\", \"pagval50p\",  \"cowspacre\", \"ln_cowspacre\", \"ocattlepacre\", \"pigspacre\",  \"ln_pigspacre\", \"sheeppacre\", \"ln_sheeppacre\", \"townvillp\",  \"carspcap\", \"radiopcap\", \"retailpcap\", \"psinglem30_34\") nb_B <- nb2listw(lw_unstand$neighbours, style=\"B\") nb_B ## Characteristics of weights list object: ## Neighbour list object: ## Number of regions: 25  ## Number of nonzero links: 110  ## Percentage nonzero weights: 17.6  ## Average number of links: 4.4  ##  ## Weights style: B  ## Weights constants summary: ##    n  nn  S0  S1   S2 ## B 25 625 110 220 2176 lw_std <- nb2listw(lw_unstand$neighbours, glist=lw_unstand$weights, style=\"W\") lw_std ## Characteristics of weights list object: ## Neighbour list object: ## Number of regions: 25  ## Number of nonzero links: 110  ## Percentage nonzero weights: 17.6  ## Average number of links: 4.4  ##  ## Weights style: W  ## Weights constants summary: ##    n  nn S0       S1       S2 ## W 25 625 25 15.84089 103.6197 system.time({ MoranN <- lapply(vars, function(x) moran.test(eire_ge1[[x]], listw=nb_B, randomisation=FALSE)) MoranR <- lapply(vars, function(x) moran.test(eire_ge1[[x]], listw=nb_B, randomisation=TRUE)) GearyN <- lapply(vars, function(x) geary.test(eire_ge1[[x]], listw=nb_B, randomisation=FALSE)) GearyR <- lapply(vars, function(x) geary.test(eire_ge1[[x]], listw=nb_B, randomisation=TRUE)) Prop_unstdN  <- lapply(vars, function(x) moran.test(eire_ge1[[x]], listw=lw_unstand, randomisation=FALSE)) Prop_unstdR  <- lapply(vars, function(x) moran.test(eire_ge1[[x]], listw=lw_unstand, randomisation=TRUE)) Prop_stdN  <- lapply(vars, function(x) moran.test(eire_ge1[[x]], listw=lw_std, randomisation=FALSE)) Prop_stdR  <- lapply(vars, function(x) moran.test(eire_ge1[[x]], listw=lw_std, randomisation=TRUE)) }) ##    user  system elapsed  ##   0.116   0.000   0.117 res <- sapply(c(\"MoranN\", \"MoranR\", \"GearyN\", \"GearyR\", \"Prop_unstdN\", \"Prop_unstdR\", \"Prop_stdN\", \"Prop_stdR\"), function(x) sapply(get(x), \"[[\", \"statistic\")) rownames(res) <- vars ores <- res[,c(1,2,5:8)] print(formatC(res, format=\"f\", digits=4), quote=FALSE) ##               MoranN MoranR GearyN  GearyR  Prop_unstdN Prop_unstdR Prop_stdN Prop_stdR ## pagval2_10    3.7851 3.8779 4.3142  3.9016  3.3307      3.4159      3.9276    4.0292    ## ln_pagval2_10 4.0965 4.1074 4.0841  4.0343  3.5795      3.5894      4.1278    4.1393    ## pagval10_50   1.0899 1.1316 2.7511  2.3760  1.3348      1.3882      1.5127    1.5738    ## pagval50p     5.2011 5.0555 4.0178  4.7194  4.6604      4.5247      4.8823    4.7387    ## cowspacre     5.1969 5.3907 4.3531  3.7709  4.1379      4.2991      4.7274    4.9135    ## ln_cowspacre  5.2420 5.2455 3.9211  3.9085  4.2007      4.2037      4.6532    4.6566    ## ocattlepacre  0.5565 0.5593 -0.1707 -0.1668 2.1366      2.1478      1.9219    1.9320    ## pigspacre     2.4807 2.5393 2.2928  2.0802  2.8312      2.9010      3.1908    3.2703    ## ln_pigspacre  2.3015 2.2724 2.0520  2.1893  2.5171      2.4839      2.8460    2.8081    ## sheeppacre    1.0188 1.0630 0.8689  0.7387  1.7398      1.8187      1.4792    1.5470    ## ln_sheeppacre 1.2930 1.2827 1.5156  1.5767  2.3708      2.3511      2.0374    2.0203    ## townvillp     2.2759 2.2681 2.5475  2.5902  1.2148      1.2104      1.6275    1.6216    ## carspcap      4.4927 4.4015 3.2247  3.5992  3.8897      3.8075      4.1826    4.0934    ## radiopcap     0.3156 0.3153 1.2294  1.2348  0.5915      0.5909      0.7857    0.7849    ## retailpcap    3.4985 3.4524 3.1303  3.3497  2.9291      2.8888      3.0346    2.9926    ## psinglem30_34 2.7349 2.6895 2.3382  2.5519  2.7541      2.7065      2.7078    2.6605 wc_unstd <- spweights.constants(lw_unstand) wrong_N_sqVI <- sqrt((wc_unstd$nn*wc_unstd$S1 - wc_unstd$n*wc_unstd$S2 + 3*wc_unstd$S0*wc_unstd$S0)/((wc_unstd$nn-1)*wc_unstd$S0*wc_unstd$S0)-((-1/(wc_unstd$n-1))^2)) raw_data <- grep(\"^ln_\", vars, invert=TRUE) I <- sapply(Prop_stdN, function(x) x$estimate[1])[raw_data] EI <- sapply(Prop_stdN, function(x) x$estimate[2])[raw_data] res <- (I - EI)/wrong_N_sqVI names(res) <- vars[raw_data] print(formatC(res, format=\"f\", digits=4), quote=FALSE) ##    pagval2_10   pagval10_50     pagval50p     cowspacre  ocattlepacre     pigspacre  ##        3.8836        1.4957        4.8276        4.6744        1.9003        3.1550  ##    sheeppacre     townvillp      carspcap     radiopcap    retailpcap psinglem30_34  ##        1.4627        1.6093        4.1357        0.7769        3.0006        2.6774 res <- lapply(c(\"MoranR\", \"GearyR\", \"Prop_unstdR\", \"Prop_stdR\"), function(x) sapply(get(x), function(y) c(y$estimate[1], sqrt(y$estimate[3])))) res <- t(do.call(\"rbind\", res)) colnames(res) <- c(\"I\", \"sigma_I\", \"C\", \"sigma_C\", \"unstd_r\", \"sigma_r\", \"std_r\", \"sigma_r\") rownames(res) <- vars print(formatC(res, format=\"f\", digits=4), quote=FALSE) ##               I       sigma_I C      sigma_C unstd_r sigma_r std_r  sigma_r ## pagval2_10    0.4074  0.1158  0.3477 0.1672  0.4559  0.1456  0.5384 0.1440  ## ln_pagval2_10 0.4444  0.1183  0.3825 0.1531  0.4930  0.1490  0.5680 0.1473  ## pagval10_50   0.0877  0.1143  0.5840 0.1751  0.1577  0.1436  0.1818 0.1420  ## pagval50p     0.5754  0.1221  0.3925 0.1287  0.6545  0.1539  0.6795 0.1522  ## cowspacre     0.5749  0.1144  0.3418 0.1745  0.5764  0.1438  0.6566 0.1421  ## ln_cowspacre  0.5803  0.1186  0.4071 0.1517  0.5858  0.1493  0.6456 0.1476  ## ocattlepacre  0.0244  0.1181  1.0258 0.1547  0.2775  0.1486  0.2422 0.1469  ## pigspacre     0.2527  0.1159  0.6533 0.1667  0.3812  0.1458  0.4296 0.1441  ## ln_pigspacre  0.2314  0.1202  0.6897 0.1417  0.3343  0.1514  0.3787 0.1497  ## sheeppacre    0.0792  0.1137  0.8686 0.1778  0.2182  0.1429  0.1768 0.1412  ## ln_sheeppacre 0.1117  0.1196  0.7708 0.1453  0.3125  0.1506  0.2593 0.1489  ## townvillp     0.2284  0.1191  0.6148 0.1487  0.1398  0.1499  0.1987 0.1482  ## carspcap      0.4914  0.1211  0.5124 0.1355  0.5394  0.1526  0.5761 0.1509  ## radiopcap     -0.0042 0.1188  0.8141 0.1505  0.0467  0.1495  0.0744 0.1478  ## retailpcap    0.3734  0.1202  0.5267 0.1413  0.3959  0.1515  0.4066 0.1498  ## psinglem30_34 0.2828  0.1207  0.6465 0.1385  0.3697  0.1520  0.3583 0.1503 oMoranf <- function(x, nb) {   z <- scale(x, scale=FALSE)   n <- length(z)   glist <- lapply(1:n, function(i) {ii <- nb[[i]]; ifelse(ii > i, 1, 0)})   lw <- nb2listw(nb, glist=glist, style=\"B\")   wz <- lag(lw, z)   I <- (sum(z*wz)/sum(z*z))   I } res <- sapply(vars, function(x) oMoranf(eire_ge1[[x]], nb=lw_unstand$neighbours)) print(formatC(res, format=\"f\", digits=4), quote=FALSE) ##    pagval2_10 ln_pagval2_10   pagval10_50     pagval50p     cowspacre  ln_cowspacre  ##        0.8964        0.9776        0.1928        1.2660        1.2649        1.2766  ##  ocattlepacre     pigspacre  ln_pigspacre    sheeppacre ln_sheeppacre     townvillp  ##        0.0536        0.5559        0.5091        0.1743        0.2458        0.5024  ##      carspcap     radiopcap    retailpcap psinglem30_34  ##        1.0811       -0.0093        0.8215        0.6222"},{"path":"https://r-spatial.github.io/spdep/articles/CO69.html","id":"simulating-measures-of-spatial-autocorrelation","dir":"Articles","previous_headings":"","what":"Simulating measures of spatial autocorrelation","title":"“The Problem of Spatial Autocorrelation:” forty years on","text":"Cliff Ord (1969) conduct simulation experiments, although sequels , notably Cliff Ord (1973), among many others. Simulation studies necessarily demanding computationally, especially spatially autocorrelated variables created, Cliff Ord (1973, 146–53). book, also report use permutation tests, also known Monte Carlo Hope hypothesis testing procedures (Cliff Ord 1973, 50–52). procedures provided way examine distribution statistic interest exchanging random observed values observations, comparing simulated distribution null hypothesis spatial patterning observed value statistic question. First let us define function MoranI.boot just return value Moran’s II variable var permutation index , function Nsim generate random samples variable interest assuming Normality. make easier process variables turn, encapsulate calls boot wrapper functions f_bperm f_bpara. Running 4999 simulations 16 three different weights specifications parametric permutation bootstrap takes quite lot time. collate results compare analytical standard deviates Normality randomisation, see fact differences large, expressed median absolute difference tables. can also see inferences based one-sided α=0.05\\alpha=0.05 cut-analytical bootstrap approaches. indicates can, general, rely analytical standard deviates, bootstrap methods help assumptions underlying measures met. assumptions affect shape distribution measure tails; one possibility use Saddlepoint approximation find equivalent analytical bootstrap-based standard deviate inference (Tiefelsdorf 2002). Saddlepoint approximation requires eigenvalues weights matrix iterative root-finding global Moran’s II, local Moran’s IiI_i, analytical forms known. Even computational burden, Saddlepoint approximation global Moran’s II runs quite quickly. First need fit null linear models (including intercept) variables, apply lm.morantest.sad fitted model objects: Although analytical standard deviates (Normality) larger reached using Saddlepoint approximation measured median absolute deviation, differences lead different inferences chosen cut-. reflects fact shape distribution sensitive small nn, moderate nn global Moran’s II, effects seen tails. consequences local Moran’s IiI_i much stronger, clique neighbours observation typically small. perhaps interest differences much smaller case general weights unstandardised binary weights. addition choose use exact distribution Moran’s II, described Tiefelsdorf (2000); implementation covered R. S. Bivand, Müller, Reder (2009). global case also needs eigenvalues weights matrix, solution numerical integration function, cases, timings quite acceptable. output comparable Saddlepoint approximation, inferences drawn chosen cut-analytical standard deviates calculated Normality. Li, Calder, Cressie (2007) take challenge Cliff Ord (1969, 31), try give statistic bounded fixed range. APLE measure intended approximate spatial dependence parameter simultaneous autoregressive model better Moran’s II, re-scales measure function eigenvalues spatial weights matrix. APLE requires use row standardised weights. order save time, use two internal functions spatialreg:::preAple spatialreg:::inAple, since definition spatial weights, eigenvalue calculations need made. notation using ::: operator says function named operator found namespace package named operator. APLE values repeat pattern already seen — variables, measured autocorrelation similar irrespective spatial weights definition, others, change definition binary general make difference.","code":"MoranI.boot <- function(var, i, ...) {   var <- var[i]   return(moran(x=var, ...)$I) } Nsim <- function(d, mle) {   n <- length(d)   rnorm(n, mle$mean, mle$sd) } f_bperm <- function(x, nsim, listw) {   boot(x, statistic=MoranI.boot, R=nsim, sim=\"permutation\", listw=listw,     n=length(x), S0=Szero(listw)) } f_bpara <- function(x, nsim, listw) {   boot(x, statistic=MoranI.boot, R=nsim, sim=\"parametric\", ran.gen=Nsim,     mle=list(mean=mean(x), sd=sd(x)), listw=listw, n=length(x),     S0=Szero(listw)) } nsim <- 4999 set.seed(1234) system.time({ MoranNb <- lapply(vars, function(x) f_bpara(x=eire_ge1[[x]], nsim=nsim, listw=nb_B)) MoranRb <- lapply(vars, function(x) f_bperm(x=eire_ge1[[x]], nsim=nsim, listw=nb_B)) Prop_unstdNb  <- lapply(vars, function(x) f_bpara(x=eire_ge1[[x]], nsim=nsim, listw=lw_unstand)) Prop_unstdRb  <- lapply(vars, function(x) f_bperm(x=eire_ge1[[x]], nsim=nsim, listw=lw_unstand)) Prop_stdNb  <- lapply(vars, function(x) f_bpara(x=eire_ge1[[x]], nsim=nsim, listw=lw_std)) Prop_stdRb  <- lapply(vars, function(x) f_bperm(x=eire_ge1[[x]], nsim=nsim, listw=lw_std)) }) res <- lapply(c(\"MoranNb\", \"MoranRb\", \"Prop_unstdNb\", \"Prop_unstdRb\", \"Prop_stdNb\", \"Prop_stdRb\"), function(x) sapply(get(x), function(y) (y$t0 - mean(y$t))/sd(y$t))) res <- t(do.call(\"rbind\", res)) colnames(res) <- c(\"MoranNb\", \"MoranRb\", \"Prop_unstdNb\", \"Prop_unstdRb\", \"Prop_stdNb\", \"Prop_stdRb\") rownames(res) <- vars print(formatC(res, format=\"f\", digits=4), quote=FALSE) ##    pagval2_10 ln_pagval2_10   pagval10_50     pagval50p     cowspacre  ln_cowspacre  ##        0.8964        0.9776        0.1928        1.2660        1.2649        1.2766  ##  ocattlepacre     pigspacre  ln_pigspacre    sheeppacre ln_sheeppacre     townvillp  ##        0.0536        0.5559        0.5091        0.1743        0.2458        0.5024  ##      carspcap     radiopcap    retailpcap psinglem30_34  ##        1.0811       -0.0093        0.8215        0.6222 oores <- ores - res apply(oores, 2, mad) ##      MoranN      MoranR Prop_unstdN Prop_unstdR   Prop_stdN   Prop_stdR  ##   1.6470091   1.6241614   0.7681895   0.7170636   1.2615083   1.2723149 alpha_0.05 <- qnorm(0.05, lower.tail=FALSE) all((res >= alpha_0.05) == (ores >= alpha_0.05)) ## [1] FALSE lm_objs <- lapply(vars, function(x) lm(formula(paste(x, \"~1\")), data=eire_ge1)) system.time({ MoranSad <- lapply(lm_objs, function(x) lm.morantest.sad(x, listw=nb_B)) Prop_unstdSad  <- lapply(lm_objs, function(x) lm.morantest.sad(x, listw=lw_unstand)) Prop_stdSad  <- lapply(lm_objs, function(x) lm.morantest.sad(x, listw=lw_std)) }) ##    user  system elapsed  ##   0.064   0.000   0.064 res <- sapply(c(\"MoranSad\", \"Prop_unstdSad\", \"Prop_stdSad\"), function(x) sapply(get(x), \"[[\", \"statistic\")) rownames(res) <- vars print(formatC(res, format=\"f\", digits=4), quote=FALSE) ##               MoranSad Prop_unstdSad Prop_stdSad ## pagval2_10    3.2903   3.1711        3.8283      ## ln_pagval2_10 3.5346   3.3982        4.0441      ## pagval10_50   1.0883   1.3219        1.4791      ## pagval50p     4.4402   4.4258        4.9377      ## cowspacre     4.4366   3.9164        4.7406      ## ln_cowspacre  4.4758   3.9760        4.6493      ## ocattlepacre  0.6030   2.0748        1.8642      ## pigspacre     2.2611   2.7154        3.0775      ## ln_pigspacre  2.1158   2.4271        2.7417      ## sheeppacre    1.0250   1.7040        1.4476      ## ln_sheeppacre 1.2669   2.2921        1.9731      ## townvillp     2.0949   1.2079        1.5872      ## carspcap      3.8500   3.6840        4.1044      ## radiopcap     0.3750   0.6094        0.7906      ## retailpcap    3.0663   2.8049        2.9245      ## psinglem30_34 2.4649   2.6449        2.6089 oores <- res - ores[,c(1,3,5)] apply(oores, 2, mad) ##      MoranSad Prop_unstdSad   Prop_stdSad  ##    0.37142684    0.10779060    0.05650183 all((res >= alpha_0.05) == (ores[,c(1,3,5)] >= alpha_0.05)) ## [1] TRUE system.time({  MoranEx <- lapply(lm_objs, function(x) lm.morantest.exact(x, listw=nb_B)) Prop_unstdEx  <- lapply(lm_objs, function(x) lm.morantest.exact(x, listw=lw_unstand)) Prop_stdEx  <- lapply(lm_objs, function(x) lm.morantest.exact(x, listw=lw_std)) }) ##    user  system elapsed  ##   0.079   0.000   0.080 res <- sapply(c(\"MoranEx\", \"Prop_unstdEx\", \"Prop_stdEx\"), function(x) sapply(get(x), \"[[\", \"statistic\")) rownames(res) <- vars print(formatC(res, format=\"f\", digits=4), quote=FALSE) ##               MoranEx Prop_unstdEx Prop_stdEx ## pagval2_10    3.2895  3.1660       3.8261     ## ln_pagval2_10 3.5384  3.3979       4.0430     ## pagval10_50   1.0798  1.3131       1.4745     ## pagval50p     4.4568  4.4430       4.9446     ## cowspacre     4.4532  3.9268       4.7453     ## ln_cowspacre  4.4928  3.9875       4.6531     ## ocattlepacre  0.5967  2.0611       1.8596     ## pigspacre     2.2486  2.7033       3.0740     ## ln_pigspacre  2.1031  2.4131       2.7380     ## sheeppacre    1.0168  1.6924       1.4430     ## ln_sheeppacre 1.2575  2.2779       1.9685     ## townvillp     2.0822  1.1999       1.5826     ## carspcap      3.8593  3.6899       4.1037     ## radiopcap     0.3696  0.6054       0.7873     ## retailpcap    3.0616  2.7938       2.9210     ## psinglem30_34 2.4533  2.6321       2.6050 oores <- res - ores[,c(1,3,5)] apply(oores, 2, mad) ##      MoranEx Prop_unstdEx   Prop_stdEx  ##   0.37187539   0.09751723   0.05419300 all((res >= alpha_0.05) == (ores[,c(1,3,5)] >= alpha_0.05)) ## [1] TRUE vars_scaled <- lapply(vars, function(x) scale(eire_ge1[[x]], scale=FALSE)) nb_W <- nb2listw(lw_unstand$neighbours, style=\"W\") pre <- spatialreg:::preAple(0, listw=nb_W) MoranAPLE <- sapply(vars_scaled, function(x) spatialreg:::inAple(x, pre)) pre <- spatialreg:::preAple(0, listw=lw_std, override_similarity_check=TRUE) Prop_stdAPLE <- sapply(vars_scaled, function(x) spatialreg:::inAple(x, pre)) res <- cbind(MoranAPLE, Prop_stdAPLE) colnames(res) <- c(\"APLE W\", \"APLE Gstd\") rownames(res) <- vars print(formatC(res, format=\"f\", digits=4), quote=FALSE) ##               APLE W APLE Gstd ## pagval2_10    0.7702 0.6628    ## ln_pagval2_10 0.7615 0.6655    ## pagval10_50   0.3954 0.3446    ## pagval50p     0.7519 0.7313    ## cowspacre     0.8329 0.7408    ## ln_cowspacre  0.8148 0.7487    ## ocattlepacre  0.1468 0.4092    ## pigspacre     0.6227 0.6205    ## ln_pigspacre  0.5582 0.5887    ## sheeppacre    0.1594 0.2841    ## ln_sheeppacre 0.2046 0.4550    ## townvillp     0.3442 0.2644    ## carspcap      0.7140 0.6166    ## radiopcap     0.0083 0.1376    ## retailpcap    0.6376 0.5307    ## psinglem30_34 0.4094 0.4889"},{"path":"https://r-spatial.github.io/spdep/articles/CO69.html","id":"odds-and-ends-ldots","dir":"Articles","previous_headings":"","what":"Odds and ends …\\ldots","title":"“The Problem of Spatial Autocorrelation:” forty years on","text":"differences found case variables inference using original binary weights, general weights proposed Cliff Ord (1969) necessarily related weights thenselves. Figures plot_wtsplot\\_wts plot_mapplot\\_map show values weights sparse matrix form, sums weights county sums identical design. case binary weights, matrix entries equal, sums -weight counties many neighbours. General weights -weight counties close , neighbours, share larger boundary proportions (asymmetric relationship). impact using boundary proportions, boundary county exterior subtracted, thus boosting weights edge counties neighbours, even . Standardised general weights -weight -weight counties neighbours, chiefly edges study area. small data set, n=25n=25, possible edge configuration effects relatively strong, may impact inference different ways. issue egde effects really satisfactorily resolved, kept mind analyses data sets size shape.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/articles/nb.html","id":"creating-neighbours","dir":"Articles","previous_headings":"","what":"Creating Neighbours","title":"Creating Neighbours","text":"vignette formed pp. 239–251 first edition Bivand, R. S., Pebesma, E. Gómez-Rubio V. (2008) Applied Spatial Data Analysis R, Springer-Verlag, New York. retired second edition (2013) accommodate material topics, made available form understanding publishers.","code":""},{"path":"https://r-spatial.github.io/spdep/articles/nb.html","id":"introduction","dir":"Articles","previous_headings":"Creating Neighbours","what":"Introduction","title":"Creating Neighbours","text":"Creating spatial weights necessary step using areal data, perhaps just check remaining spatial patterning residuals. first step define relationships observations given non-zero weight, choose neighbour criterion used; second assign weights identified neighbour links. 281 census tract data set eight central New York State counties featured prominently (Waller Gotway 2004) used many examples, supplemented tract boundaries derived TIGER 1992 distributed SEDAC/CIESIN. boundaries projected geographical coordinates UTM zone~18. file identical boundaries used original source, close may re-distributed, unlike version used book. Starting census tract queen contiguities, touching polygons neighbours, used (Waller Gotway 2004) provided DBF file website, GAL format file created read R. sake simplicity showing create neighbour objects, work subset map consisting census tracts within Syracuse, although principles apply full data set. retrieve part neighbour list Syracuse using subset method.","code":"library(spdep) ## Loading required package: spData ## Loading required package: sf ## Linking to GEOS 3.13.0, GDAL 3.9.2, PROJ 9.5.0; sf_use_s2() is TRUE if (packageVersion(\"spData\") >= \"2.3.2\") {     NY8a <- sf::st_read(system.file(\"shapes/NY8_utm18.gpkg\", package=\"spData\")) } else {     NY8a <- sf::st_read(system.file(\"shapes/NY8_bna_utm18.gpkg\", package=\"spData\"))     sf::st_crs(NY8a) <- \"EPSG:32618\"     NY8a$Cases <- NY8a$TRACTCAS } ## Reading layer `NY8_utm18' from data source  ##   `/home/rsb/lib/r_libs/spData/shapes/NY8_utm18.gpkg' using driver `GPKG' ## Simple feature collection with 281 features and 17 fields ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 358241.9 ymin: 4649755 xmax: 480393.1 ymax: 4808545 ## Projected CRS: WGS 84 / UTM zone 18N NY8 <- as(NY8a, \"Spatial\") NY_nb <- read.gal(system.file(\"weights/NY_nb.gal\", package=\"spData\"), region.id=as.character(as.integer(row.names(NY8))-1L)) Syracuse <- NY8[!is.na(NY8$AREANAME) & NY8$AREANAME == \"Syracuse city\",] Sy0_nb <- subset(NY_nb, !is.na(NY8$AREANAME) & NY8$AREANAME == \"Syracuse city\") summary(Sy0_nb) ## Neighbour list object: ## Number of regions: 63  ## Number of nonzero links: 346  ## Percentage nonzero weights: 8.717561  ## Average number of links: 5.492063  ## Link number distribution: ##  ##  1  2  3  4  5  6  7  8  9  ##  1  1  5  9 14 17  9  6  1  ## 1 least connected region: ## 164 with 1 link ## 1 most connected region: ## 136 with 9 links"},{"path":"https://r-spatial.github.io/spdep/articles/nb.html","id":"creating-contiguity-neighbours","dir":"Articles","previous_headings":"Creating Neighbours","what":"Creating Contiguity Neighbours","title":"Creating Neighbours","text":"can create copy neighbours object polygon contiguities using poly2nb() function spdep. takes object extending SpatialPolygons class first argument, using heuristics identifies polygons sharing boundary points neighbours. also snap= argument, allow shared boundary points short distance one another. can see, creating contiguity neighbours Syracuse object reproduces neighbours (Waller Gotway 2004). Careful examination next figure shows, however, graph neighbours planar, since neighbour links cross . default, contiguity condition met least one point boundary one polygon within snap distance least one point neighbour. relationship given argument queen=TRUE analogy movements chessboard. three polygons meet single point, meet contiguity condition, giving rise crossed links. queen=FALSE, least two boundary points must within snap distance , conventional name `rook’ relationship. figure shows crossed line differences arise polygons touch single point, compared stricter rook criterion. : Queen-style census tract contiguities, Syracuse; b: Rook-style contiguity differences shown thicker orange lines access GIS GRASS ArcGIS, can export SpatialPolygonsDataFrame object use topology engine GIS find contiguities graph polygon edges - shared edge yield output rook relationship. procedure , however, depend topology set polygons clean, holds subset, full eight-county data set. infrequently, small artefacts, slivers boundary lines intersect diverge distances seen plots, require intervention keep geometries data correctly associated. geometrical artefacts present, topology clean, unambiguous shared polygon boundaries found cases; artefacts typically arise data collected one purpose combined data used another purpose. Topologies usually cleaned GIS snapping' vertices closer threshold distance together, removing artefacts -- example, snapping across river channel correct boundary median line input polygons stop channel banks side. Thepoly2nb()function asnap` argument, may also used input data possess geometrical artefacts. Similar approaches may also used read ArcGIS coverage data tallying left neighbour right neighbour arc indices polygons data set, using either RArcInfo rgdal. Syracuse case, exclaves islands' belonging data set, sharing boundary points within snap distance. number polygons moderate, missing neighbour links may added interactively using theedit()method fornb` objects, displaying polygon background. method may used removing links , although contiguity exists, may considered void, across mountain range.","code":"class(Syracuse) ## [1] \"SpatialPolygonsDataFrame\" ## attr(,\"package\") ## [1] \"sp\" Sy1_nb <- poly2nb(Syracuse) isTRUE(all.equal(Sy0_nb, Sy1_nb, check.attributes=FALSE)) ## [1] TRUE Sy2_nb <- poly2nb(Syracuse, queen=FALSE) isTRUE(all.equal(Sy0_nb, Sy2_nb, check.attributes=FALSE)) ## [1] FALSE oopar <- par(mfrow=c(1,2), mar=c(3,3,1,1)+0.1) plot(Syracuse, border=\"grey60\") plot(Sy0_nb, coordinates(Syracuse), add=TRUE, pch=19, cex=0.6) text(bbox(Syracuse)[1,1], bbox(Syracuse)[2,2], labels=\"a)\", cex=0.8) plot(Syracuse, border=\"grey60\") plot(Sy0_nb, coordinates(Syracuse), add=TRUE, pch=19, cex=0.6) plot(diffnb(Sy0_nb, Sy2_nb, verbose=FALSE), coordinates(Syracuse),   add=TRUE, pch=\".\", cex=0.6, lwd=2, col=\"orange\") text(bbox(Syracuse)[1,1], bbox(Syracuse)[2,2], labels=\"b)\", cex=0.8) par(oopar) library(rgrass) v <- terra::vect(sf::st_as_sf(Syracuse)) SG <- terra::rast(terra::ext(v), crs=terra::crs(v)) pr <- initGRASS(\"/home/rsb/topics/grass/g840/grass84\", tempdir(), SG=SG, override=TRUE) write_VECT(v, \"SY0\", flags=c(\"o\", \"overwrite\")) contig <- vect2neigh(\"SY0\") Sy3_nb <- sn2listw(contig, style=\"B\")$neighbours isTRUE(all.equal(Sy3_nb, Sy2_nb, check.attributes=FALSE)) ## [1] TRUE"},{"path":"https://r-spatial.github.io/spdep/articles/nb.html","id":"creating-graph-based-neighbours","dir":"Articles","previous_headings":"Creating Neighbours","what":"Creating Graph-Based Neighbours","title":"Creating Neighbours","text":"Continuing irregularly located areal entities, possible choose point represent polygon-support entities. often polygon centroid, average coordinates dimension, takes proper care weight component triangles polygon area. also possible use points, data available, construct, example population-weighted centroids. representative points available, criteria neighbourhood can extended just contiguity include graph measures, distance thresholds, kk-nearest neighbours. direct graph representation neighbours make Delaunay triangulation points, shown first panel figure. neighbour relationships defined triangulation, extends outwards convex hull points planar. Note graph-based representations construct interpoint relationships based Euclidean distance, option use Great Circle distances geographical coordinates. joins distant points around convex hull, may worthwhile thin triangulation Sphere Influence (SOI) graph, removing links relatively long. Points SOI neighbours circles centred points, radius equal points’ nearest neighbour distances, intersect two places (Avis Horton 1985). Functions graph-based neighbours kindly contributed Nicholas Lewin-Koh. : Delauney triangulation neighbours; b: Sphere influence neighbours (available); c: Gabriel graph neighbours; d: Relative graph neighbours Delaunay triangulation neighbours SOI neighbours symmetric design – ii neighbour jj, jj neighbour ii. Gabriel graph also subgraph Delaunay triangulation, retaining different set neighbours (Matula Sokal 1980). , however, guarantee symmetry; applies Relative graph neighbours (Toussaint 1980). graph2nb() function takes sym argument insert links restore symmetry, graphs longer exactly fulfil neighbour criteria. graph-based neighbour schemes always ensure points least one neighbour. Subgraphs full triangulation may also one graph trimming. functions .symmetric.nb() can used check symmetry, argument force=TRUE symmetry attribute overridden, n.comp.nb() reports number graph components ~components points belong (enforcing symmetry, algorithm assumes graph directed). one graph component, matrix representation spatial weights can become block-diagonal observations appropriately sorted.","code":"coords <- coordinates(Syracuse) IDs <- row.names(as(Syracuse, \"data.frame\")) #FIXME library(tripack) Sy4_nb <- tri2nb(coords, row.names=IDs) if (require(dbscan, quietly=TRUE)) {   Sy5_nb <- graph2nb(soi.graph(Sy4_nb, coords), row.names=IDs) } else Sy5_nb <- NULL ##  ## Attaching package: 'dbscan' ## The following object is masked from 'package:stats': ##  ##     as.dendrogram Sy6_nb <- graph2nb(gabrielneigh(coords), row.names=IDs) Sy7_nb <- graph2nb(relativeneigh(coords), row.names=IDs) oopar <- par(mfrow=c(2,2), mar=c(1,1,1,1)+0.1) plot(Syracuse, border=\"grey60\") plot(Sy4_nb, coords, add=TRUE, pch=\".\") text(bbox(Syracuse)[1,1], bbox(Syracuse)[2,2], labels=\"a)\", cex=0.8) plot(Syracuse, border=\"grey60\") if (!is.null(Sy5_nb)) {   plot(Sy5_nb, coords, add=TRUE, pch=\".\")   text(bbox(Syracuse)[1,1], bbox(Syracuse)[2,2], labels=\"b)\", cex=0.8) } plot(Syracuse, border=\"grey60\") plot(Sy6_nb, coords, add=TRUE, pch=\".\") text(bbox(Syracuse)[1,1], bbox(Syracuse)[2,2], labels=\"c)\", cex=0.8) plot(Syracuse, border=\"grey60\") plot(Sy7_nb, coords, add=TRUE, pch=\".\") text(bbox(Syracuse)[1,1], bbox(Syracuse)[2,2], labels=\"d)\", cex=0.8) par(oopar) nb_l <- list(Triangulation=Sy4_nb, Gabriel=Sy6_nb,   Relative=Sy7_nb) if (!is.null(Sy5_nb)) nb_l <- c(nb_l, list(SOI=Sy5_nb)) sapply(nb_l, function(x) is.symmetric.nb(x, verbose=FALSE, force=TRUE)) ## Triangulation       Gabriel      Relative           SOI  ##          TRUE         FALSE         FALSE          TRUE sapply(nb_l, function(x) n.comp.nb(x)$nc) ## Triangulation       Gabriel      Relative           SOI  ##             1             1             1             1"},{"path":"https://r-spatial.github.io/spdep/articles/nb.html","id":"distance-based-neighbours","dir":"Articles","previous_headings":"Creating Neighbours","what":"Distance-Based Neighbours","title":"Creating Neighbours","text":"alternative method choose kk nearest points neighbours – adapts across study area, taking account differences densities areal entities. Naturally, overwhelming majority cases, leads asymmetric neighbours, ensure areas kk neighbours. knearneigh() function returns intermediate form converted nb object knn2nb(); knearneigh() can also take longlat= argument handle geographical coordinates. : k=1k=1 neighbours; b: k=2k=2 neighbours; c: k=4k=4 neighbours figure shows neighbour relationships k=1,2,4k= 1, 2, 4, many components k=1k=1. need , kk-nearest neighbour objects can made symmetrical using make.sym.nb() function. k=1k=1 object also useful finding minimum distance areas distance-based neighbour. Using nbdists() function, can calculate list vectors distances corresponding neighbour object, first nearest neighbours. greatest value minimum distance needed make sure areas linked least one neighbour. dnearneigh() function used find neighbours interpoint distance, arguments d1 d2 setting lower upper distance bounds; can also take longlat argument handle geographical coordinates. : Neighbours within 1,158m; b: neighbours within 1,545m; c: neighbours within 2,317m figure shows numbers distance-based neighbours increase moderate increases distance. Moving 0.750.75 times minimum -included distance, -included distance, 1.51.5 times minimum -included distance, numbers links grow rapidly. major problem first nearest neighbour distances study area much larger others, since avoid -neighbour areal entities, distance criterion need set many areas many neighbours. Distance-based neighbours: frequencies numbers neighbours census tract figure shows counts sizes sets neighbours three different distance limits. Syracuse, census tracts similar areas, try use distance-based neighbour criterion eight-county study area, smallest distance securing least one neighbour every areal entity 38km. areal entities approximately regularly spaced, using distance-based neighbours necessarily problem. Provided care taken handle side effects “weighting” areas analysis, using lists neighbours -neighbour areas necessarily problem either, certainly raise questions. Different disciplines handle definition neighbours ways convention; particular, seems ecologists frequently use distance bands. many distance bands used, approach variogram, although underlying understanding spatial autocorrelation seems contagion rather continuous.","code":"Sy8_nb <- knn2nb(knearneigh(coords, k=1), row.names=IDs) ## Warning in knn2nb(knearneigh(coords, k = 1), row.names = IDs): neighbour object ## has 15 sub-graphs Sy9_nb <- knn2nb(knearneigh(coords, k=2), row.names=IDs) Sy10_nb <- knn2nb(knearneigh(coords, k=4), row.names=IDs) nb_l <- list(k1=Sy8_nb, k2=Sy9_nb, k4=Sy10_nb) sapply(nb_l, function(x) is.symmetric.nb(x, verbose=FALSE, force=TRUE)) ##    k1    k2    k4  ## FALSE FALSE FALSE sapply(nb_l, function(x) n.comp.nb(x)$nc) ## k1 k2 k4  ## 15  1  1 oopar <- par(mfrow=c(1,3), mar=c(1,1,1,1)+0.1) plot(Syracuse, border=\"grey60\") plot(Sy8_nb, coords, add=TRUE, pch=\".\") text(bbox(Syracuse)[1,1], bbox(Syracuse)[2,2], labels=\"a)\", cex=0.8) plot(Syracuse, border=\"grey60\") plot(Sy9_nb, coords, add=TRUE, pch=\".\") text(bbox(Syracuse)[1,1], bbox(Syracuse)[2,2], labels=\"b)\", cex=0.8) plot(Syracuse, border=\"grey60\") plot(Sy10_nb, coords, add=TRUE, pch=\".\") text(bbox(Syracuse)[1,1], bbox(Syracuse)[2,2], labels=\"c)\", cex=0.8) par(oopar) dsts <- unlist(nbdists(Sy8_nb, coords)) summary(dsts) ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  ##   395.7   587.3   700.1   760.4   906.1  1544.6 max_1nn <- max(dsts) max_1nn ## [1] 1544.615 Sy11_nb <- dnearneigh(coords, d1=0, d2=0.75*max_1nn, row.names=IDs) ## Warning in dnearneigh(coords, d1 = 0, d2 = 0.75 * max_1nn, row.names = IDs): ## neighbour object has 4 sub-graphs Sy12_nb <- dnearneigh(coords, d1=0, d2=1*max_1nn, row.names=IDs) Sy13_nb <- dnearneigh(coords, d1=0, d2=1.5*max_1nn, row.names=IDs) nb_l <- list(d1=Sy11_nb, d2=Sy12_nb, d3=Sy13_nb) sapply(nb_l, function(x) is.symmetric.nb(x, verbose=FALSE, force=TRUE)) ##   d1   d2   d3  ## TRUE TRUE TRUE sapply(nb_l, function(x) n.comp.nb(x)$nc) ## d1 d2 d3  ##  4  1  1 oopar <- par(mfrow=c(1,3), mar=c(1,1,1,1)+0.1) plot(Syracuse, border=\"grey60\") plot(Sy11_nb, coords, add=TRUE, pch=\".\") text(bbox(Syracuse)[1,1], bbox(Syracuse)[2,2], labels=\"a)\", cex=0.8) plot(Syracuse, border=\"grey60\") plot(Sy12_nb, coords, add=TRUE, pch=\".\") text(bbox(Syracuse)[1,1], bbox(Syracuse)[2,2], labels=\"b)\", cex=0.8) plot(Syracuse, border=\"grey60\") plot(Sy13_nb, coords, add=TRUE, pch=\".\") text(bbox(Syracuse)[1,1], bbox(Syracuse)[2,2], labels=\"c)\", cex=0.8) par(oopar) dS <- c(0.75, 1, 1.5)*max_1nn res <- sapply(nb_l, function(x) table(card(x))) mx <- max(card(Sy13_nb)) res1 <- matrix(0, ncol=(mx+1), nrow=3) rownames(res1) <- names(res) colnames(res1) <- as.character(0:mx) res1[1, names(res$d1)] <- res$d1 res1[2, names(res$d2)] <- res$d2 res1[3, names(res$d3)] <- res$d3 library(RColorBrewer) pal <- grey.colors(3, 0.95, 0.55, 2.2) # RSB quietening greys barplot(res1, col=pal, beside=TRUE, legend.text=FALSE, xlab=\"numbers of neighbours\", ylab=\"tracts\") legend(\"topright\", legend=format(dS, digits=1), fill=pal, bty=\"n\", cex=0.8, title=\"max. distance\") dsts0 <- unlist(nbdists(NY_nb, coordinates(NY8))) summary(dsts0) ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  ##    82.7  1505.0  3378.7  5865.8  8954.3 38438.1"},{"path":"https://r-spatial.github.io/spdep/articles/nb.html","id":"higher-order-neighbours","dir":"Articles","previous_headings":"Creating Neighbours","what":"Higher-Order Neighbours","title":"Creating Neighbours","text":"Distance bands can generated using sequence d1 d2 argument values dnearneigh() function needed construct spatial autocorrelogram understood ecology. conventions, correlograms constructed taking input list neighbours first-order sets, stepping across graph second-, third-, higher-order neighbours based number links traversed, permitting cycles, risk making ii neighbour ii (O’Sullivan Unwin 2003). nblag() function takes existing neighbour list returns list lists, first maxlag= order neighbours. shows wave connectedness graph spreads third order, receding eighth order, dying away ninth order - tracts nine steps graph. distance bands graph step order approaches spreading neighbourhoods can used examine shape relationship intensities space, like variogram, can used attempting look effects scale.","code":"Sy0_nb_lags <- nblag(Sy0_nb, maxlag=9) ## Warning in nblag(Sy0_nb, maxlag = 9): lag 6 neighbour object has 7 sub-graphs ## Warning in nblag(Sy0_nb, maxlag = 9): lag 7 neighbour object has 22 sub-graphs ## Warning in nblag(Sy0_nb, maxlag = 9): lag 8 neighbour object has 52 sub-graphs ## Warning in nblag(Sy0_nb, maxlag = 9): lag 9 neighbour object has 63 sub-graphs names(Sy0_nb_lags) <- c(\"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\", \"eighth\", \"ninth\") res <- sapply(Sy0_nb_lags, function(x) table(card(x))) mx <- max(unlist(sapply(Sy0_nb_lags, function(x) card(x)))) nn <- length(Sy0_nb_lags) res1 <- matrix(0, ncol=(mx+1), nrow=nn) rownames(res1) <- names(res) colnames(res1) <- as.character(0:mx) for (i in 1:nn) res1[i, names(res[[i]])] <- res[[i]] res1 ##          0 1 2 3 4  5  6 7 8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ## first    0 1 1 5 9 14 17 9 6  1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ## second   0 0 0 0 2  2  0 6 6 11 11  4  3  7  4  6  1  0  0  0  0  0  0  0  0 ## third    0 0 0 0 0  0  0 1 3  5  5  7 14  6  8  3  3  0  1  1  1  3  1  0  1 ## fourth   0 0 0 0 0  0  0 0 1  3  5  7 16 16  5  3  3  2  0  1  1  0  0  0  0 ## fifth    0 0 0 1 1  3  1 1 3  7 13 12  8  9  3  1  0  0  0  0  0  0  0  0  0 ## sixth    6 3 0 2 8  2  5 5 4  8  9  5  5  1  0  0  0  0  0  0  0  0  0  0  0 ## seventh 21 7 4 5 9  7  3 5 1  0  0  0  1  0  0  0  0  0  0  0  0  0  0  0  0 ## eighth  49 6 5 2 1  0  0 0 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 ## ninth   63 0 0 0 0  0  0 0 0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0"},{"path":"https://r-spatial.github.io/spdep/articles/nb.html","id":"grid-neighbours","dir":"Articles","previous_headings":"Creating Neighbours","what":"Grid Neighbours","title":"Creating Neighbours","text":"data known arranged regular, rectangular grid, cell2nb() function can used construct neighbour lists, including torus. useful simulations, , since areal entities equal numbers neighbours, edges, structure graph neutral can achieved. Neighbours can either type rook queen. regular, rectangular grid complete, can use knowledge cell size stored grid topology create appropriate list neighbours, using tightly bounded distance criterion. Neighbour lists kind commonly found ecological assays, studies species richness national continental scale. also settings, moderately large nn, n=3n=3,103, use sparse, list based representation shows strength. Handling 281×281281 \\times 281 matrix eight-county census tracts feasible, easy 63×6363 \\times 63 matrix Syracuse census tracts, demanding 3,103×3103 \\times 3,103 matrix.","code":"cell2nb(7, 7, type=\"rook\", torus=TRUE) ## Neighbour list object: ## Number of regions: 49  ## Number of nonzero links: 196  ## Percentage nonzero weights: 8.163265  ## Average number of links: 4 cell2nb(7, 7, type=\"rook\", torus=FALSE) ## Neighbour list object: ## Number of regions: 49  ## Number of nonzero links: 168  ## Percentage nonzero weights: 6.997085  ## Average number of links: 3.428571 data(meuse.grid) coordinates(meuse.grid) <- c(\"x\", \"y\") gridded(meuse.grid) <- TRUE dst <- max(slot(slot(meuse.grid, \"grid\"), \"cellsize\")) mg_nb <- dnearneigh(coordinates(meuse.grid), 0, dst) mg_nb ## Neighbour list object: ## Number of regions: 3103  ## Number of nonzero links: 12022  ## Percentage nonzero weights: 0.1248571  ## Average number of links: 3.874315 table(card(mg_nb)) ##  ##    1    2    3    4  ##    1  133  121 2848"},{"path":[]},{"path":[]},{"path":"https://r-spatial.github.io/spdep/articles/nb_sf.html","id":"introduction","dir":"Articles","previous_headings":"Creating Neighbours using sf objects","what":"Introduction","title":"Creating Neighbours using sf objects","text":"vignette tracks legacy nb vignette, based part first (2008) edition ASDAR. adds hints code nb vignette use sf vector representation instead sp vector representation create neighbour objects. .","code":""},{"path":"https://r-spatial.github.io/spdep/articles/nb_sf.html","id":"summary","dir":"Articles","previous_headings":"Creating Neighbours using sf objects","what":"Summary","title":"Creating Neighbours using sf objects","text":"summary results : general, need reproduce results using \"Spatial\" objects spdep, coerce sf objects sp objects constructing neighbour objects (particularly polygon centroids used point representation). However, new work, use \"sf\" objects read using sf. spdep 1.1-7, number steps taken choose efficient approaches especially larger data sets, using functions sf approximate nearest neighbour (ANN) implementation dbscan rather RANN.","code":""},{"path":"https://r-spatial.github.io/spdep/articles/nb_sf.html","id":"data-set","dir":"Articles","previous_headings":"Creating Neighbours using sf objects","what":"Data set","title":"Creating Neighbours using sf objects","text":"’ll use whole NY 8 county set boundaries, challenge implementations just Syracuse subset. description input geometries ADSAR : New York leukemia: used documented extensively Waller Gotway (2004) data formerly made available Chap. 9 http://web1.sph.emory.edu/users/lwaller/ch9index.htm; data import process described help file NY_data spData; geometries downloaded CIESIN server https://sedac.ciesin.columbia.edu/data/set/acrp-boundary-1992/data-download, file /pub/census/usa/tiger/ny/bna_st/t8_36.zip, extensively edited; zip archive NY_data.zip shapefiles GAL format neighbours list book website. , zipfile now new location requiring login. object listw_NY directly imported nyadjwts.dbf Waller & Gotway (2004) chapter 9 website. version New York 8 counties geometries used ASDAR included shapefile spdep converted original BNA file using external utility program convert MapInfo format converted using GDAL 1.4.1 (OGR BNA driver available; entered OGR 1.5.0, release end 2007), contains invalid geometries. found mid-2007 included villages /excluded -umbilical cords boundary enclosing tract, underlying BNA file first converted MapInfo (holes exist ). use GPKG file created follows (rgdal also used output; GDAL prior GDAL 3.3 built GEOS, BNA vector driver use geometry tests: BNA driver supports reading polygons holes lakes. determines hole lake geometrical analysis (inclusion, non-intersection tests) ignores completely notion polygon winding (whether polygon edges described clockwise counter-clockwise). GDAL must built GEOS enabled make geometry test work.):","code":"library(sf) sf_bna <- st_read(\"t8_36.bna\", stringsAsFactors=FALSE) table(st_is_valid(sf_bna)) sf_bna$AREAKEY <- gsub(\"\\\\.\", \"\", sf_bna$Primary.ID) data(NY_data, package=\"spData\") key <- as.character(nydata$AREAKEY) sf_bna1 <- sf_bna[match(key, sf_bna$AREAKEY), c(\"AREAKEY\")] sf_bna2 <- merge(sf_bna1, nydata, by=\"AREAKEY\") sf_bna2_utm18 <- st_transform(sf_bna2, \"+proj=utm +zone=18 +datum=NAD27\") st_write(sf_bna2_utm18, \"NY8_bna_utm18.gpkg\")"},{"path":"https://r-spatial.github.io/spdep/articles/nb_sf.html","id":"nb-and-listw-objects-copied-from-the-nb_igraph-vignette","dir":"Articles","previous_headings":"Creating Neighbours using sf objects","what":"nb and listw objects (copied from the nb_igraph vignette)","title":"Creating Neighbours using sf objects","text":"Since spdep package created, spatial weights objects constructed lists three components attributes, old-style class listw objects. first component listw object nb object, list n integer vectors, least character vector region.id attribute n unique values (like row.names data.frame object); n number spatial entities. Component list contains integer identifiers neighbours sorted vector duplication values 1:n; neighbours, component vector length 1 value 0L. nb object may contain attribute indicating whether symmetric , whether neighbour j implies j neighbour . neighbour definitions symmetric construction, contiguities distance thresholds, others asymmetric, k-nearest neighbours. nb object redundantly stores -j j-links. second component listw object list n numeric vectors, length corresponding non-zero vectors nbobject. give values spatial weights -j neighbour pair. often case neighbours symmetric construction, weights , example weights row-standardised dividing row input weights count neighbours cardinality neighbour set . nb2listwfunction, also possible pass general weights, inverse distances, shares boundary lengths . third component listw object records style weights character code, \"B\" binary weights taking values zero one (one recorded), \"W\" row-standardised weights, . order subset listw objects, knowledge style may necessary.","code":""},{"path":"https://r-spatial.github.io/spdep/articles/nb_sf.html","id":"comparison-of-sp-and-sf-approaches","dir":"Articles","previous_headings":"Creating Neighbours using sf objects","what":"Comparison of sp and sf approaches","title":"Creating Neighbours using sf objects","text":"First housekeeping setup permit vignette built packages missing --date: Let us read GPKG file valid geometries ‘sf’ ‘sp’ objects:","code":"if (!suppressPackageStartupMessages(require(sf, quietly=TRUE))) {   message(\"install the sf package\")   dothis <- FALSE } if (dothis) sf_extSoftVersion() ##           GEOS           GDAL         proj.4 GDAL_with_GEOS     USE_PROJ_H  ##       \"3.13.0\"        \"3.9.2\"        \"9.5.0\"         \"true\"         \"true\"  ##           PROJ  ##        \"9.5.0\" NY8_sf <- st_read(system.file(\"shapes/NY8_bna_utm18.gpkg\", package=\"spData\"), quiet=TRUE) table(st_is_valid(NY8_sf)) ##  ## TRUE  ##  281"},{"path":"https://r-spatial.github.io/spdep/articles/nb_sf.html","id":"contiguity-neighbours-for-polygon-support","dir":"Articles","previous_headings":"Creating Neighbours using sf objects > Comparison of sp and sf approaches","what":"Contiguity neighbours for polygon support","title":"Creating Neighbours using sf objects","text":"first generate queen contiguity nb object using legacy spdep approach. first either uses pre-computed list vectors probable neighbours finds intersecting bounding boxes internally. points boundaries set polygons making observation checked distance less snap points set polygons making observation included set candidate neighbours. contiguity symmetric, j contiguities tested. queen contiguity found soon one point matches, rook contiguity soon two points match: Using spatial indices check intersection polygons much faster legacy method poly2nb. spdep 1.1-7, use made GEOS sf find candidate neighbours foundInBox=NULL, default value. contiguity symmetric definition, foundInBox= requires intersections higher indices, leading slight overhead remove duplicates, st_intersects() reports j ans j relationships. st_intersects() report whether neighbours queen rook, step needed distinguish two cases. spdep::poly2nb uses two heuristics, first find candidate neighbours intersecting polygons (st_intersects()), second use symmetry relationship halve number remaining tests. means performance linear n, overhead identifying candidates, back-filling symmetric neighbours. , spdep::poly2nb() stops searching queen contiguity soon first neighbour point found within snap distance (identical, tested first); second neighbour point indicates rook contiguities. details alternatives spherical geometries, see section @ref(spher-poly2nb) .","code":"suppressPackageStartupMessages(library(spdep)) reps <- 10 eps <- sqrt(.Machine$double.eps) system.time(for(i in 1:reps) NY8_sf_1_nb <- poly2nb(NY8_sf, queen=TRUE, snap=eps))/reps ##    user  system elapsed  ##  0.1847  0.0088  0.1943 NY8_sf_1_nb ## Neighbour list object: ## Number of regions: 281  ## Number of nonzero links: 1632  ## Percentage nonzero weights: 2.066843  ## Average number of links: 5.807829"},{"path":"https://r-spatial.github.io/spdep/articles/nb_sf.html","id":"contiguity-neighbours-from-invalid-polygons","dir":"Articles","previous_headings":"Creating Neighbours using sf objects > Comparison of sp and sf approaches","what":"Contiguity neighbours from invalid polygons","title":"Creating Neighbours using sf objects","text":"Next, explore possible source differences neighbour object reproduction, using original version tract boundaries used ASDAR, invalid geometries mentioned earlier (NY8_utm18.gpkg created original ESRI Shapefile used ASDAR): can see number differences neighbour sets derived fully valid geometries older partly invalid set: Using st_make_valid() make geometries valid: also see geometry type geometry column changes: checking \"sfg\" objects, two now objects different topological dimensions. can remedied using st_collection_extract() get polygon objects: However, making geometries valid, change geometries, new sets neighbours still differ made valid geometries ways imposing validity: neighbour sets old boundaries without imposing validity:","code":"if (packageVersion(\"spData\") >= \"2.3.2\") {     NY8_sf_old <- sf::st_read(system.file(\"shapes/NY8_utm18.gpkg\", package=\"spData\")) } else {     NY8_sf_old <- sf::st_read(system.file(\"shapes/NY8_utm18.shp\", package=\"spData\")) } ## Reading layer `NY8_utm18' from data source  ##   `/home/rsb/lib/r_libs/spData/shapes/NY8_utm18.gpkg' using driver `GPKG' ## Simple feature collection with 281 features and 17 fields ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 358241.9 ymin: 4649755 xmax: 480393.1 ymax: 4808545 ## Projected CRS: WGS 84 / UTM zone 18N table(st_is_valid(NY8_sf_old)) ##  ## FALSE  TRUE  ##     5   276 try(NY8_sf_old_1_nb <- poly2nb(NY8_sf_old), silent = TRUE) all.equal(NY8_sf_old_1_nb, NY8_sf_1_nb, check.attributes=FALSE) ## [1] \"Component 57: Numeric: lengths (4, 5) differ\"  ## [2] \"Component 58: Numeric: lengths (5, 6) differ\"  ## [3] \"Component 66: Numeric: lengths (7, 11) differ\" ## [4] \"Component 73: Numeric: lengths (4, 5) differ\"  ## [5] \"Component 260: Numeric: lengths (8, 9) differ\" NY8_sf_old_val <- st_make_valid(NY8_sf_old, dist=0) table(st_is_valid(NY8_sf_old_val)) ##  ## TRUE  ##  281 class(st_geometry(NY8_sf_old)) ## [1] \"sfc_POLYGON\" \"sfc\" class(st_geometry(NY8_sf_old_val)) ## [1] \"sfc_GEOMETRY\" \"sfc\" table(sapply(st_geometry(NY8_sf_old_val), function(x) class(x)[[2]])) ##  ## MULTIPOLYGON      POLYGON  ##            3          278 NY8_sf_old_val <- st_collection_extract(NY8_sf_old_val, \"POLYGON\") table(sapply(st_geometry(NY8_sf_old_val), function(x) class(x)[[2]])) ##  ## MULTIPOLYGON  ##          281 try(NY8_sf_old_1_nb_val <- poly2nb(NY8_sf_old_val), silent = TRUE) all.equal(NY8_sf_old_1_nb_val, NY8_sf_1_nb, check.attributes=FALSE) ## [1] \"Component 57: Numeric: lengths (4, 5) differ\"  ## [2] \"Component 58: Numeric: lengths (5, 6) differ\"  ## [3] \"Component 66: Numeric: lengths (7, 11) differ\" ## [4] \"Component 73: Numeric: lengths (4, 5) differ\"  ## [5] \"Component 260: Numeric: lengths (8, 9) differ\" all.equal(NY8_sf_old_1_nb_val, NY8_sf_old_1_nb, check.attributes=FALSE) ## [1] TRUE"},{"path":[]},{"path":"https://r-spatial.github.io/spdep/articles/nb_sf.html","id":"finding-points-for-polygon-objects","dir":"Articles","previous_headings":"Creating Neighbours using sf objects > Planar point-based neighbours","what":"Finding points for polygon objects","title":"Creating Neighbours using sf objects","text":"knearneigh() dnearneigh() require point support, decisions must taken place point areal object. can use st_centroid() get centroids, using of_largest_polygon=TRUE argument make sure centroid largest polygon id observation made one external ring: st_point_on_surface() guarantees point fall surface member polygon: indeed taking centre largest inscribed circle (function returns radius line segment, choose central point, point circle): need check whether coordinates planar :","code":"NY8_ct_sf <- st_centroid(st_geometry(NY8_sf), of_largest_polygon=TRUE) NY8_pos_sf <- st_point_on_surface(st_geometry(NY8_sf)) if (unname(sf_extSoftVersion()[\"GEOS\"] >= \"3.9.0\"))      NY8_cic_sf <- st_cast(st_inscribed_circle(st_geometry(NY8_sf), nQuadSegs=0), \"POINT\")[(1:(2*nrow(NY8_sf)) %% 2) != 0] st_is_longlat(NY8_ct_sf) ## [1] FALSE"},{"path":"https://r-spatial.github.io/spdep/articles/nb_sf.html","id":"graph-based-neighbours","dir":"Articles","previous_headings":"Creating Neighbours using sf objects > Planar point-based neighbours","what":"Graph-based neighbours","title":"Creating Neighbours using sf objects","text":", can check graph-based neighbours (planar coordinates ):","code":"suppressPackageStartupMessages(require(deldir)) NY84_nb <- tri2nb(NY8_ct_sf) if (require(dbscan, quietly=TRUE)) {   NY85_nb <- graph2nb(soi.graph(NY84_nb, NY8_ct_sf)) } else NY85_nb <- NULL ##  ## Attaching package: 'dbscan' ## The following object is masked from 'package:stats': ##  ##     as.dendrogram ## Warning in graph2nb(soi.graph(NY84_nb, NY8_ct_sf)): neighbour object has 2 ## sub-graphs NY86_nb <- graph2nb(gabrielneigh(NY8_ct_sf)) NY87_nb <- graph2nb(relativeneigh(NY8_ct_sf))"},{"path":"https://r-spatial.github.io/spdep/articles/nb_sf.html","id":"k-nearest-neighbours","dir":"Articles","previous_headings":"Creating Neighbours using sf objects > Planar point-based neighbours","what":"K-nearest neighbours","title":"Creating Neighbours using sf objects","text":"K-nearest neighbours use coordinate matrices, can handle Great Circle distances, demonstrated , data set used planar, case dbscan::kNN() 2D 3D building kd-tree used: Legacy code may used omitting kd-tree:","code":"system.time(for (i in 1:reps) suppressWarnings(NY88_nb_sf <- knn2nb(knearneigh(NY8_ct_sf, k=1))))/reps ##    user  system elapsed  ##  0.0224  0.0009  0.0234 system.time(for (i in 1:reps) suppressWarnings(NY89_nb_sf <- knn2nb(knearneigh(NY8_ct_sf, k=1, use_kd_tree=FALSE))))/reps ##    user  system elapsed  ##  0.0239  0.0007  0.0247"},{"path":"https://r-spatial.github.io/spdep/articles/nb_sf.html","id":"distance-neighbours","dir":"Articles","previous_headings":"Creating Neighbours using sf objects > Planar point-based neighbours","what":"Distance neighbours","title":"Creating Neighbours using sf objects","text":"Distance neighbours need threshold - nbdists shows maximum distance first nearest neighbour: dnearneigh can also handle Great Circle distances, demonstrated , data set used planar: default, function uses dbscan::frNN() build kd-tree 2D 3D used find distance neighbours. small n, argument use_kd_tree=FALSE may speed computation little reverting legacy code building kd-tree first, general differences small user notice:","code":"dsts <- unlist(nbdists(NY88_nb_sf, NY8_ct_sf)) summary(dsts) ##     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.  ##    82.85   912.85  1801.11  3441.04  4461.26 17033.11 max_1nn <- max(dsts) system.time(for (i in 1:reps) suppressWarnings(NY810_nb <- dnearneigh(NY8_ct_sf, d1=0, d2=0.75*max_1nn)))/reps ##    user  system elapsed  ##  0.0583  0.0018  0.0603 system.time(for (i in 1:reps) suppressWarnings(NY811_nb <- dnearneigh(NY8_ct_sf, d1=0, d2=0.75*max_1nn, use_kd_tree=FALSE)))/reps ##    user  system elapsed  ##  0.0445  0.0012  0.0458"},{"path":"https://r-spatial.github.io/spdep/articles/nb_sf.html","id":"spherical-point-based-neighbours","dir":"Articles","previous_headings":"Creating Neighbours using sf objects","what":"Spherical point-based neighbours","title":"Creating Neighbours using sf objects","text":"Spherical point-based neighbours may found using Great Circle distances. used many years, switch sf 1.0-0 use s2 default opened new opportunities spatial indexing sphere may help.","code":"pts_ll <- st_transform(NY8_ct_sf, \"OGC:CRS84\") st_is_longlat(pts_ll) ## [1] TRUE"},{"path":"https://r-spatial.github.io/spdep/articles/nb_sf.html","id":"k-nearest-neighbours-1","dir":"Articles","previous_headings":"Creating Neighbours using sf objects > Spherical point-based neighbours","what":"K-nearest neighbours","title":"Creating Neighbours using sf objects","text":"input geometries geographical coordinates, sf_use_s2() TRUE, knearneigh() use spatially indexed points s2::s2_closest_edges() (see https://github.com/r-spatial/s2/issues/125#issuecomment-860107442) performs well also larger data sets: smaller data set, legacy approach without spatial indexing adequate, slows number observations increases: WGS84 ellipsoid Great Circle distances differ little s2 spherical distances, yielding output diverges two tract centroids:","code":"(old_use_s2 <- sf_use_s2()) ## [1] TRUE sf_use_s2(TRUE) system.time(for (i in 1:reps) pts_ll1_nb <- knn2nb(knearneigh(pts_ll, k=6)))/reps ##    user  system elapsed  ##  0.0319  0.0000  0.0320 sf_use_s2(FALSE) ## Spherical geometry (s2) switched off system.time(for (i in 1:reps) pts_ll2_nb <- knn2nb(knearneigh(pts_ll, k=6)))/reps ##    user  system elapsed  ##  0.0296  0.0001  0.0298 all.equal(pts_ll1_nb, pts_ll2_nb, check.attributes=FALSE) ## [1] \"Component 52: Mean relative difference: 1.466667\"   ## [2] \"Component 124: Mean relative difference: 0.0251046\" pts_ll1_nb[[52]] ## [1] 15 38 48 49 50 53 pts_ll2_nb[[52]] ## [1] 37 38 48 49 50 53 pts_ll1_nb[[124]] ## [1] 117 122 123 125 133 134 pts_ll2_nb[[124]] ## [1] 116 117 123 125 133 134 sf_use_s2(old_use_s2) ## Spherical geometry (s2) switched on"},{"path":"https://r-spatial.github.io/spdep/articles/nb_sf.html","id":"distance-neighbours-1","dir":"Articles","previous_headings":"Creating Neighbours using sf objects > Spherical point-based neighbours","what":"Distance neighbours","title":"Creating Neighbours using sf objects","text":"Distance neighbours problematic. nbdists() works well s2 spherical coordinates, none tried adaptations dnearneigh() work adequately yet. argument use_s2= set TRUE s2 > 1.0-7, using s2::s2_closest_edges() legacy brute-force approach, calculating distances j copying j symmetry. distance metric alway \"km\". permit s2 methods run, without arguments set, s2 > 1.0-7, s2::s2_dwithin_matrix() run: Alternatively, spherical distances can used dwithin=FALSE s2::s2_closest_edges(); although running similar time, s2::s2_closest_edges() depends additional k= argument, , mis-set, may miss valid neighbours: Using s2::s2_closest_edges() respects d1 > 0 without requiring second pass R, faster s2::s2_dwithin_matrix(): Using s2::s2_dwithin_matrix() requires second pass, one lower bound, another upper bound, set difference operation find neighbours distance band: Setting use_s2=FALSE falls back legacy version, uses symmetry reduce time: Minor differences may occur legacy ellipsoid s2 spherical approaches:","code":"max_1nn_ll <- max(unlist(nbdists(knn2nb(knearneigh(pts_ll, k=1)), pts_ll))) ## Warning in knn2nb(knearneigh(pts_ll, k = 1)): neighbour object has 62 ## sub-graphs args(dnearneigh) ## function (x, d1, d2, row.names = NULL, longlat = NULL, bounds = c(\"GE\",  ##     \"LE\"), use_kd_tree = TRUE, symtest = FALSE, use_s2 = packageVersion(\"s2\") >  ##     \"1.0.7\", k = 200, dwithin = TRUE)  ## NULL if (packageVersion(\"s2\") > \"1.0.7\") {   system.time(for (i in 1:(reps/5)) suppressWarnings(pts_ll3_nb <- dnearneigh(pts_ll, d1=0,       d2=0.75*max_1nn_ll)))/(reps/5) } ##    user  system elapsed  ##  0.0655  0.0000  0.0660 system.time(for (i in 1:(reps/5)) suppressWarnings(pts_ll5_nb <- dnearneigh(pts_ll, d1=0, d2=0.75*max_1nn_ll, dwithin=FALSE)))/(reps/5) ##    user  system elapsed  ##  0.0525  0.0000  0.0525 if (packageVersion(\"s2\") > \"1.0.7\") all.equal(pts_ll3_nb, pts_ll5_nb, check.attributes=FALSE) ## [1] TRUE if (packageVersion(\"s2\") > \"1.0.7\") {   system.time(for (i in 1:(reps/5)) suppressWarnings(pts_ll3a_nb <- dnearneigh(pts_ll, d1=5,       d2=0.75*max_1nn_ll, dwithin=FALSE)))/(reps/5) } ##    user  system elapsed  ##  0.0445  0.0000  0.0450 if (packageVersion(\"s2\") > \"1.0.7\") {     system.time(for (i in 1:(reps/5)) suppressWarnings(pts_ll5a_nb <- dnearneigh(pts_ll, d1=5,         d2=0.75*max_1nn_ll)))/(reps/5) } ##    user  system elapsed  ##    0.09    0.00    0.09 if (packageVersion(\"s2\") > \"1.0.7\") all.equal(pts_ll3a_nb, pts_ll5a_nb, check.attributes=FALSE) ## [1] TRUE system.time(for (i in 1:reps) suppressWarnings(pts_ll6_nb <- dnearneigh(pts_ll, d1=0, d2=0.75*max_1nn_ll, use_s2=FALSE)))/reps ##    user  system elapsed  ##  0.0400  0.0000  0.0401 all.equal(pts_ll5_nb, pts_ll6_nb, check.attributes=FALSE) ##  [1] \"Component 20: Numeric: lengths (6, 5) differ\"      ##  [2] \"Component 28: Numeric: lengths (7, 6) differ\"      ##  [3] \"Component 112: Numeric: lengths (109, 108) differ\" ##  [4] \"Component 116: Numeric: lengths (109, 108) differ\" ##  [5] \"Component 122: Numeric: lengths (105, 106) differ\" ##  [6] \"Component 123: Numeric: lengths (108, 107) differ\" ##  [7] \"Component 130: Numeric: lengths (108, 109) differ\" ##  [8] \"Component 134: Numeric: lengths (106, 105) differ\" ##  [9] \"Component 158: Numeric: lengths (101, 102) differ\" ## [10] \"Component 165: Numeric: lengths (101, 102) differ\" ## [11] \"Component 168: Numeric: lengths (101, 102) differ\" ## [12] \"Component 179: Numeric: lengths (89, 90) differ\"   ## [13] \"Component 180: Numeric: lengths (96, 97) differ\"   ## [14] \"Component 188: Numeric: lengths (46, 47) differ\"   ## [15] \"Component 189: Numeric: lengths (55, 56) differ\"   ## [16] \"Component 196: Numeric: lengths (47, 46) differ\"   ## [17] \"Component 210: Numeric: lengths (106, 104) differ\" ## [18] \"Component 226: Numeric: lengths (88, 87) differ\"   ## [19] \"Component 229: Numeric: lengths (55, 53) differ\"   ## [20] \"Component 235: Numeric: lengths (40, 39) differ\"   ## [21] \"Component 237: Numeric: lengths (14, 15) differ\"   ## [22] \"Component 245: Numeric: lengths (16, 15) differ\" system.time(for (i in 1:reps) suppressWarnings(pts_ll6a_nb <- dnearneigh(pts_ll, d1=5, d2=0.75*max_1nn_ll, use_s2=FALSE)))/reps ##    user  system elapsed  ##  0.0310  0.0001  0.0313 if (packageVersion(\"s2\") > \"1.0.7\") all.equal(pts_ll5a_nb, pts_ll6a_nb, check.attributes=FALSE) ##  [1] \"Component 20: Numeric: lengths (6, 5) differ\"        ##  [2] \"Component 28: Numeric: lengths (7, 6) differ\"        ##  [3] \"Component 112: Numeric: lengths (62, 61) differ\"     ##  [4] \"Component 113: Numeric: lengths (62, 63) differ\"     ##  [5] \"Component 116: Numeric: lengths (56, 55) differ\"     ##  [6] \"Component 119: Numeric: lengths (68, 69) differ\"     ##  [7] \"Component 122: Numeric: lengths (43, 44) differ\"     ##  [8] \"Component 123: Numeric: lengths (50, 49) differ\"     ##  [9] \"Component 128: Numeric: lengths (65, 64) differ\"     ## [10] \"Component 130: Numeric: lengths (61, 63) differ\"     ## [11] \"Component 132: Numeric: lengths (45, 46) differ\"     ## [12] \"Component 134: Numeric: lengths (46, 45) differ\"     ## [13] \"Component 136: Numeric: lengths (61, 62) differ\"     ## [14] \"Component 147: Numeric: lengths (50, 51) differ\"     ## [15] \"Component 154: Numeric: lengths (56, 57) differ\"     ## [16] \"Component 158: Numeric: lengths (49, 50) differ\"     ## [17] \"Component 165: Mean relative difference: 0.02823018\" ## [18] \"Component 168: Numeric: lengths (54, 56) differ\"     ## [19] \"Component 179: Numeric: lengths (77, 78) differ\"     ## [20] \"Component 180: Numeric: lengths (85, 86) differ\"     ## [21] \"Component 188: Numeric: lengths (39, 40) differ\"     ## [22] \"Component 189: Numeric: lengths (48, 49) differ\"     ## [23] \"Component 196: Numeric: lengths (45, 44) differ\"     ## [24] \"Component 210: Numeric: lengths (68, 66) differ\"     ## [25] \"Component 226: Numeric: lengths (82, 81) differ\"     ## [26] \"Component 229: Numeric: lengths (48, 46) differ\"     ## [27] \"Component 235: Numeric: lengths (38, 37) differ\"     ## [28] \"Component 237: Numeric: lengths (14, 15) differ\"     ## [29] \"Component 245: Numeric: lengths (15, 14) differ\""},{"path":"https://r-spatial.github.io/spdep/articles/nb_sf.html","id":"spher-poly2nb","dir":"Articles","previous_headings":"Creating Neighbours using sf objects > Spherical point-based neighbours","what":"Contiguity neighbours for spherical polygon support","title":"Creating Neighbours using sf objects","text":"also turns sf functions used find contiguity neighbours, s2 spatial indexing functionality accessed finding candidate neighbours intersecting geometries. timings little slower st_intersects() hands geometry predicates s2_intersects_matrix(), results , spatial indexing used, scales well larger data sets:","code":"NY8_sf_ll <- st_transform(NY8_sf, \"OGC:CRS84\") st_is_longlat(NY8_sf_ll) ## [1] TRUE sf_use_s2(TRUE) system.time(for (i in 1:reps) NY8_sf_1_nb_ll <- poly2nb(NY8_sf_ll, queen=TRUE, snap=eps))/reps ##    user  system elapsed  ##  0.1604  0.0024  0.1634 all.equal(NY8_sf_1_nb, NY8_sf_1_nb_ll, check.attributes=FALSE) ## [1] TRUE"},{"path":"https://r-spatial.github.io/spdep/articles/sids.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to the North Carolina SIDS data set (re-revised)","text":"data set presented first Symons, Grimson, Yuan (1983), analysed reference spatial nature data Cressie Read (1985), expanded Cressie Chan (1989), used detail Cressie (1991). 100 counties North Carolina, includes counts numbers live births (also non-white live births) numbers sudden infant deaths, July 1, 1974 June 30, 1978 July 1, 1979 June 30, 1984 periods. Cressie Read (1985), listing county neighbours based shared boundaries (contiguity) given, Cressie Chan (1989), Cressie (1991, 386–89), different listing based criterion distance county seats, cutoff 30 miles. county seat location coordinates given miles local (unknown) coordinate reference system. data also used exemplify range functions spatial statistics module user’s manual (Kaluzny et al. 1996).","code":""},{"path":"https://r-spatial.github.io/spdep/articles/sids.html","id":"getting-the-data-into-r","dir":"Articles","previous_headings":"","what":"Getting the data into R","title":"Introduction to the North Carolina SIDS data set (re-revised)","text":"using spdep spreg packages, version: spdep, version 1.3-6, 2024-08-31, sf package tmap package. data sources referred documented help page nc.sids data set spData. actual data, included shapefile county boundaries North Carolina made available maptools package 1. data known geographical coordinates (longitude-latitude decimal degrees) assumed use NAD27 datum. ESRI Shapefile deprecated, replaced GeoPackage, written reading original files spData 2.3.1: shapefile format presupposed three files extensions .shp, .shx, .dbf, first contains geometry data, second spatial index, third attribute data. required name apart extension, read using sf::st_read() sf object nc; class defined sf. centroids largest polygon county available using st_centroid method sf sfc POINT object, can used place labels extraction coordinate matrix: can examine names columns data frame see contains — fact columns examining , others useful cleaning data set. Let’s check different versions data - sf spData NC SIDS files, GeoDa Center two forms: actual CRS unknown, spData reports missing, although may well +proj=longlat +datum=NAD27 Next, geometries ? sf::st_equals returns logical matrix, ’ll check diagonal values TRUE, values TRUE summing recalling n 100: Next, let’s download GeoDa files repeat comparisons: looks though external files assuming WGS84/NAD83 datum, also contain geometries. Now contents files - sids2 also contains rates, file spData contains coordinates given Cressie (1991), parcels contiguous counties p. 554, aggregations used median polishing. spData data set columns reordered surprise: difference NWBIR74: spData follows Cressie (1991) sf Geoda follow Cressie Chan (1989) NWBIR74 Chowan county. now examine data set reproduced Cressie collaborators, included spData (formerly spdep), add neighbour relationships used Cressie Chan (1989) background map graph shown Figure : Printing neighbour object shows neighbour list object, sparse structure — displayed matrix, 3.94% cells filled. Objects class nb contain list long number counties; component list vector index numbers neighbours county question, neighbours county region.id 37001 can retreived matching indices. information can obtained using summary() nb object. Finally, associate vector names neighbour list, row.names argument. names unique, data frame row names. neighbour list object records neighbours order relation list , neighbours list county region.id “37001” seventeenth, nineteenth, thirty-second, forty-first sixty-eighth list. can retreive codes looking region.id attribute. also note neighbour criterion generates two counties neighbours, Dare Hyde, whose county seats 30 miles nearest neighbours. card() function returns cardinality neighbour set. need return methods handling -neighbour objects later . also show new neighbours lists may constructed , compare literature.","code":"library(spdep) nc <- st_read(system.file(\"shapes/sids.gpkg\", package=\"spData\")[1], quiet=TRUE) #st_crs(nc) <- \"EPSG:4267\" row.names(nc) <- as.character(nc$FIPSNO) sf_use_s2(TRUE) plot(st_geometry(nc), axes=TRUE) text(st_coordinates(st_centroid(st_geometry(nc), of_largest_polygon=TRUE)), label=nc$FIPSNO, cex=0.5) names(nc) ##  [1] \"CNTY_ID\"   \"AREA\"      \"PERIMETER\" \"CNTY_\"     \"NAME\"      \"FIPS\"      ##  [7] \"FIPSNO\"    \"CRESS_ID\"  \"BIR74\"     \"SID74\"     \"NWBIR74\"   \"BIR79\"     ## [13] \"SID79\"     \"NWBIR79\"   \"east\"      \"north\"     \"x\"         \"y\"         ## [19] \"lon\"       \"lat\"       \"L_id\"      \"M_id\"      \"geom\" summary(nc) ##     CNTY_ID          AREA          PERIMETER         CNTY_      ##  Min.   :1825   Min.   :0.0420   Min.   :0.999   Min.   :1825   ##  1st Qu.:1902   1st Qu.:0.0910   1st Qu.:1.324   1st Qu.:1902   ##  Median :1982   Median :0.1205   Median :1.609   Median :1982   ##  Mean   :1986   Mean   :0.1263   Mean   :1.673   Mean   :1986   ##  3rd Qu.:2067   3rd Qu.:0.1542   3rd Qu.:1.859   3rd Qu.:2067   ##  Max.   :2241   Max.   :0.2410   Max.   :3.640   Max.   :2241   ##      NAME               FIPS               FIPSNO         CRESS_ID      ##  Length:100         Length:100         Min.   :37001   Min.   :  1.00   ##  Class :character   Class :character   1st Qu.:37050   1st Qu.: 25.75   ##  Mode  :character   Mode  :character   Median :37100   Median : 50.50   ##                                        Mean   :37100   Mean   : 50.50   ##                                        3rd Qu.:37150   3rd Qu.: 75.25   ##                                        Max.   :37199   Max.   :100.00   ##      BIR74           SID74          NWBIR74           BIR79       ##  Min.   :  248   Min.   : 0.00   Min.   :   1.0   Min.   :  319   ##  1st Qu.: 1077   1st Qu.: 2.00   1st Qu.: 190.0   1st Qu.: 1336   ##  Median : 2180   Median : 4.00   Median : 697.5   Median : 2636   ##  Mean   : 3300   Mean   : 6.67   Mean   :1051.0   Mean   : 4224   ##  3rd Qu.: 3936   3rd Qu.: 8.25   3rd Qu.:1168.5   3rd Qu.: 4889   ##  Max.   :21588   Max.   :44.00   Max.   :8027.0   Max.   :30757   ##      SID79          NWBIR79             east           north       ##  Min.   : 0.00   Min.   :    3.0   Min.   : 19.0   Min.   :  6.0   ##  1st Qu.: 2.00   1st Qu.:  250.5   1st Qu.:178.8   1st Qu.: 97.0   ##  Median : 5.00   Median :  874.5   Median :285.0   Median :125.5   ##  Mean   : 8.36   Mean   : 1352.8   Mean   :271.3   Mean   :122.1   ##  3rd Qu.:10.25   3rd Qu.: 1406.8   3rd Qu.:361.2   3rd Qu.:151.5   ##  Max.   :57.00   Max.   :11631.0   Max.   :482.0   Max.   :182.0   ##        x                 y             lon              lat        ##  Min.   :-328.04   Min.   :3757   Min.   :-84.08   Min.   :33.92   ##  1st Qu.: -60.55   1st Qu.:3920   1st Qu.:-81.20   1st Qu.:35.26   ##  Median : 114.38   Median :3963   Median :-79.26   Median :35.68   ##  Mean   :  91.46   Mean   :3953   Mean   :-79.51   Mean   :35.62   ##  3rd Qu.: 240.03   3rd Qu.:4000   3rd Qu.:-77.87   3rd Qu.:36.05   ##  Max.   : 439.65   Max.   :4060   Max.   :-75.67   Max.   :36.52   ##       L_id           M_id                 geom     ##  Min.   :1.00   Min.   :1.00   MULTIPOLYGON :100   ##  1st Qu.:1.00   1st Qu.:2.00   epsg:4267    :  0   ##  Median :2.00   Median :3.00   +proj=long...:  0   ##  Mean   :2.12   Mean   :2.67                       ##  3rd Qu.:3.00   3rd Qu.:3.25                       ##  Max.   :4.00   Max.   :4.00 library(sf) nc_sf <- st_read(system.file(\"shape/nc.shp\", package=\"sf\"),                  quiet=TRUE) st_crs(nc_sf) ## Coordinate Reference System: ##   User input: NAD27  ##   wkt: ## GEOGCRS[\"NAD27\", ##     DATUM[\"North American Datum 1927\", ##         ELLIPSOID[\"Clarke 1866\",6378206.4,294.978698213898, ##             LENGTHUNIT[\"metre\",1]]], ##     PRIMEM[\"Greenwich\",0, ##         ANGLEUNIT[\"degree\",0.0174532925199433]], ##     CS[ellipsoidal,2], ##         AXIS[\"latitude\",north, ##             ORDER[1], ##             ANGLEUNIT[\"degree\",0.0174532925199433]], ##         AXIS[\"longitude\",east, ##             ORDER[2], ##             ANGLEUNIT[\"degree\",0.0174532925199433]], ##     ID[\"EPSG\",4267]] nc <- st_read(system.file(\"shapes/sids.shp\",                  package=\"spData\"), quiet=TRUE) st_crs(nc) ## Coordinate Reference System: NA st_crs(nc) <- \"+proj=longlat +datum=NAD27\" suppressWarnings(st_crs(nc_sf) <- st_crs(nc)) xx <- st_equals(nc, nc_sf, sparse=FALSE) all(diag(xx)) && sum(xx) == 100L ## [1] TRUE td <- tempdir() #download.file(\"https://geodacenter.github.io/data-and-lab//data/sids.zip\", file.path(td, \"sids.zip\"), quiet=TRUE)  # local copy (2020-10-22) as repository sometimes offline file.copy(system.file(\"etc/misc/sids.zip\", package=\"spdep\"), td) ## [1] TRUE unzip(file.path(td, \"sids.zip\"), c(\"sids/sids.dbf\", \"sids/sids.prj\", \"sids/sids.shp\", \"sids/sids.shx\"), exdir=td) sids_sf <- st_read(file.path(td, \"sids/sids.shp\"), quiet=TRUE) #download.file(\"https://geodacenter.github.io/data-and-lab//data/sids2.zip\", file.path(td, \"sids2.zip\"), quiet=TRUE) file.copy(system.file(\"etc/misc/sids2.zip\", package=\"spdep\"), td) ## [1] TRUE unzip(file.path(td, \"sids2.zip\"), c(\"sids2/sids2.dbf\", \"sids2/sids2.prj\", \"sids2/sids2.shp\", \"sids2/sids2.shx\"), exdir=td) sids2_sf <- st_read(file.path(td, \"sids2/sids2.shp\"), quiet=TRUE) st_crs(sids_sf) ## Coordinate Reference System: ##   User input: WGS 84  ##   wkt: ## GEOGCRS[\"WGS 84\", ##     DATUM[\"World Geodetic System 1984\", ##         ELLIPSOID[\"WGS 84\",6378137,298.257223563, ##             LENGTHUNIT[\"metre\",1]]], ##     PRIMEM[\"Greenwich\",0, ##         ANGLEUNIT[\"degree\",0.0174532925199433]], ##     CS[ellipsoidal,2], ##         AXIS[\"latitude\",north, ##             ORDER[1], ##             ANGLEUNIT[\"degree\",0.0174532925199433]], ##         AXIS[\"longitude\",east, ##             ORDER[2], ##             ANGLEUNIT[\"degree\",0.0174532925199433]], ##     ID[\"EPSG\",4326]] st_crs(sids2_sf) ## Coordinate Reference System: ##   User input: WGS 84  ##   wkt: ## GEOGCRS[\"WGS 84\", ##     DATUM[\"World Geodetic System 1984\", ##         ELLIPSOID[\"WGS 84\",6378137,298.257223563, ##             LENGTHUNIT[\"metre\",1]]], ##     PRIMEM[\"Greenwich\",0, ##         ANGLEUNIT[\"degree\",0.0174532925199433]], ##     CS[ellipsoidal,2], ##         AXIS[\"latitude\",north, ##             ORDER[1], ##             ANGLEUNIT[\"degree\",0.0174532925199433]], ##         AXIS[\"longitude\",east, ##             ORDER[2], ##             ANGLEUNIT[\"degree\",0.0174532925199433]], ##     ID[\"EPSG\",4326]] suppressWarnings(st_crs(sids_sf) <- st_crs(nc_sf)) xx <- st_equals(sids_sf, nc_sf, sparse=FALSE) all(diag(xx)) && sum(xx) == 100L ## [1] FALSE suppressWarnings(st_crs(sids2_sf) <- st_crs(nc_sf)) xx <- st_equals(sids2_sf, nc_sf, sparse=FALSE) all(diag(xx)) && sum(xx) == 100L ## [1] FALSE all.equal(as.data.frame(nc_sf)[,1:14], as.data.frame(sids_sf)[,1:14]) ##  [1] \"Names: 12 string mismatches\"                                   ##  [2] \"Component 4: Modes: numeric, character\"                        ##  [3] \"Component 4: target is numeric, current is character\"          ##  [4] \"Component 5: 100 string mismatches\"                            ##  [5] \"Component 6: Modes: character, numeric\"                        ##  [6] \"Component 6: target is character, current is numeric\"          ##  [7] \"Component 7: Mean relative difference: 0.9986388\"              ##  [8] \"Component 8: Mean relative difference: 64.33901\"               ##  [9] \"Component 9: Mean relative difference: 0.9979786\"              ## [10] \"Component 10: Mean relative difference: 156.5427\"              ## [11] \"Component 11: Mean relative difference: 3.01968\"               ## [12] \"Component 12: Mean relative difference: 0.9980208\"             ## [13] \"Component 13: Mean relative difference: 160.8194\"              ## [14] \"Component 14: Modes: numeric, list\"                            ## [15] \"Component 14: Attributes: < target is NULL, current is list >\" ## [16] \"Component 14: target is numeric, current is sfc_MULTIPOLYGON\" all.equal(as.data.frame(nc_sf)[,1:14], as.data.frame(sids2_sf)[,1:14]) ##  [1] \"Names: 12 string mismatches\"                          ##  [2] \"Component 4: Modes: numeric, character\"               ##  [3] \"Component 4: target is numeric, current is character\" ##  [4] \"Component 5: 100 string mismatches\"                   ##  [5] \"Component 6: Modes: character, numeric\"               ##  [6] \"Component 6: target is character, current is numeric\" ##  [7] \"Component 7: Mean relative difference: 0.9986388\"     ##  [8] \"Component 8: Mean relative difference: 64.33901\"      ##  [9] \"Component 9: Mean relative difference: 0.9979786\"     ## [10] \"Component 10: Mean relative difference: 156.5427\"     ## [11] \"Component 11: Mean relative difference: 3.01968\"      ## [12] \"Component 12: Mean relative difference: 0.9980208\"    ## [13] \"Component 13: Mean relative difference: 160.8194\"     ## [14] \"Component 14: Mean relative difference: 0.9984879\" all.equal(as.data.frame(nc_sf)[,1:14], as.data.frame(nc)[,c(2,3,4,1,5:14)]) ## [1] \"Component \\\"NWBIR74\\\": Mean relative difference: 0.04891304\" which(!(nc_sf$NWBIR74 == nc$NWBIR74)) ## [1] 21 c(nc$NWBIR74[21], nc_sf$NWBIR74[21]) ## [1] 386 368 gal_file <- system.file(\"weights/ncCR85.gal\", package=\"spData\")[1] ncCR85 <- read.gal(gal_file, region.id=nc$FIPSNO) ncCR85 ## Neighbour list object: ## Number of regions: 100  ## Number of nonzero links: 492  ## Percentage nonzero weights: 4.92  ## Average number of links: 4.92 gal_file <- system.file(\"weights/ncCC89.gal\", package=\"spData\")[1] ncCC89 <- read.gal(gal_file, region.id=nc$FIPSNO) ncCC89 ## Neighbour list object: ## Number of regions: 100  ## Number of nonzero links: 394  ## Percentage nonzero weights: 3.94  ## Average number of links: 3.94  ## 2 regions with no links: ## 37055, 37095 ## 3 disjoint connected subgraphs plot(st_geometry(nc), border=\"grey\") plot(ncCC89, st_centroid(st_geometry(nc), of_largest_polygon), add=TRUE, col=\"blue\") r.id <- attr(ncCC89, \"region.id\") ncCC89[[match(\"37001\", r.id)]] ## [1] 11 26 29 30 48 r.id[ncCC89[[match(\"37001\", r.id)]]] ## [1] 37033 37081 37135 37063 37037 as.character(nc$NAME)[card(ncCC89) == 0] ## [1] \"Dare\" \"Hyde\""},{"path":"https://r-spatial.github.io/spdep/articles/sids.html","id":"probability-mapping","dir":"Articles","previous_headings":"Getting the data into R","what":"Probability mapping","title":"Introduction to the North Carolina SIDS data set (re-revised)","text":"Rather review functions measuring modelling spatial dependence spdep package, focus probability mapping disease rates data. Typically, counts incidence disease spatial unit, associated counts populations risk. task try establish whether spatial units seem characterised higher lower counts cases might expected general terms (Bailey Gatrell 1995). early approach Choynowski (1959), described Cressie Read (1985) Bailey Gatrell (1995), assumes, given true rate spatial units small, population risk increases infinity, spatial unit case counts Poisson mean value equal population risk times rate study area whole. Choynowski’s approach folds two tails measured probabilities together, small values, chosen α\\alpha, occur spatial units either unusually high low rates. reason, high low counties plotted separately . Note cut returns factor labeled cut intervals.  complicated thematic maps, may helpful use ColorBrewer (https://colorbrewer2.org) colour palettes. use palettes accessed tmap, available R RColorBrewer package. choynowski() function provides probability map values required, probmap() function returns raw (crude) rates, expected counts (assuming constant rate across study area), relative risks, Poisson probability map values calculated using standard cumulative distribution function ppois(). fold tails together, counties lower observed counts expected, based population size, values lower tail, higher observed counts expected values upper tail, can see.  Marilia Carvalho (personal communication) Virgilio Gómez Rubio (Gómez-Rubio, Ferrándiz-Ferragud, López-Quílez 2005) pointed unusual shape distribution Poisson probability values (histogram ), repeating doubts probability mapping voiced Cressie (1991, 392): “extreme value …\\ldots may due lack fit Poisson model deviation constant rate assumption”. many high values one expected, suggesting perhaps overdispersion, ratio variance mean larger unity.  One ad-hoc way assess impact possible failure assumption counts follow Poisson distribution estimate dispersion fitting generalized linear model observed counts including intercept (null model) offset observed population risk (suggested Marilia Carvalho associates):  dispersion equal 2.2786188, much greater unity; calculate corrected probability map values taking standardised residuals model, taking size dispersion account; results shown . Many fewer counties appear now unexpectedly large small numbers cases. ad-hoc adjustment made R provides access wide range model-fitting functions can used help check assumptions. Gómez-Rubio, Ferrándiz-Ferragud, López-Quílez (2005) chose rather construct probability map hypothesis data drawn Negative Binomial distribution. far, none maps presented made use spatial dependence possibly present data. elementary step can taken map Empirical Bayes estimates rates, smoothed relation raw rates. underlying question linked larger variance associated rate estimates counties small populations risk compared counties large populations risk. Empirical Bayes estimates place credence raw rates counties large populations risk, modify much less modify rates small counties. case small populations risk, confidence placed either global rate study area whole, local Empirical Bayes estimates, rates larger moving window including neighbours county estimated. function used spdep EBlocal(), initially contributed Marilia Carvalho. parallels similar function GeoDa, uses Bailey Gatrell (1995) interpretation Marshall (1991), rather GeoDa (Anselin, Syabri, Smirnov 2002).  results shown Figure . Like relevant functions spdep,EBlocal() takes zero.policy argument allow missing values passed . case, local estimate available two counties neighbours, marked stars. addition Empirical Bayes smoothing globally, used disease mapping Assuncão Reis correction Moran’s II rates data (shrink towards global rate population risk small, Monte Carlo test), lists local neighbours can used shrink towards local rate.","code":"ch <- choynowski(nc$SID74, nc$BIR74) nc$ch_pmap_low <- ifelse(ch$type, ch$pmap, NA) nc$ch_pmap_high <- ifelse(!ch$type, ch$pmap, NA) prbs <- c(0,.001,.01,.05,.1,1) nc$high = cut(nc$ch_pmap_high, prbs) nc$low = cut(nc$ch_pmap_low,prbs ) is_tmap <- FALSE if (require(tmap, quietly=TRUE)) is_tmap <- TRUE is_tmap ## [1] TRUE library(tmap) tmap4 <- packageVersion(\"tmap\") >= \"3.99\" if (tmap4) {   tm_shape(nc) + tm_polygons(fill=c(\"low\", \"high\"), fill.scale = tm_scale(values=\"brewer.set1\"), fill.legend = tm_legend(\"p-values\", frame=FALSE, item.r = 0), fill.free=FALSE, lwd=0.01) + tm_layout(panel.labels=c(\"low\", \"high\")) } else { tm_shape(nc) + tm_fill(c(\"low\", \"high\"), palette=\"Set1\", title=\"p-values\") +   tm_facets(free.scales=FALSE) + tm_layout(panel.labels=c(\"low\", \"high\")) } pmap <- probmap(nc$SID74, nc$BIR74) nc$pmap <- pmap$pmap brks <- c(0,0.001,0.01,0.025,0.05,0.95,0.975,0.99,0.999,1) if (tmap4) {   tm_shape(nc) + tm_polygons(fill=\"pmap\", fill.scale = tm_scale(values=\"brewer.rd_bu\", midpoint=0.5, breaks=brks), fill.legend = tm_legend(frame=FALSE, item.r = 0, position = tm_pos_out(\"right\", \"center\")), lwd=0.01) + tm_layout(component.autoscale=FALSE) } else { tm_shape(nc) + tm_fill(\"pmap\", breaks=brks, midpoint=0.5, palette=\"RdBu\") + tm_layout(legend.outside=TRUE) } hist(nc$pmap, main=\"\") res <- glm(SID74 ~ offset(log(BIR74)), data=nc, family=\"quasipoisson\") nc$stdres <- rstandard(res) brks <- c(-4, -3, -2, -1.5, -1, -0.5, 0.5, 1, 1.5, 2, 3, 4) if (tmap4) {   tm_shape(nc) + tm_polygons(fill=\"stdres\", fill.scale = tm_scale(values=\"brewer.rd_bu\", midpoint=0.5, breaks=brks), fill.legend = tm_legend(frame=FALSE, item.r = 0, position = tm_pos_out(\"right\", \"center\")), lwd=0.01) + tm_layout(component.autoscale=FALSE) } else {   tm_shape(nc) + tm_fill(\"stdres\", breaks=brks, midpoint=0, palette=\"RdBu\") + tm_layout(legend.outside=TRUE) } global_rate <- sum(nc$SID74)/sum(nc$BIR74) nc$Expected <- global_rate * nc$BIR74 res <- EBlocal(nc$SID74, nc$Expected, ncCC89, zero.policy=TRUE) nc$EB_loc <- res$est brks <- c(0, 0.25, 0.5, 0.75, 1, 2, 3, 4, 5) nc_miss <- st_centroid(st_geometry(nc[card(ncCC89) == 0,]), of_largest_polygon) if (tmap4) {   tm_shape(nc) + tm_polygons(fill=\"stdres\", fill.scale = tm_scale(values=\"brewer.rd_bu\", midpoint=0.5, breaks=brks), fill.legend = tm_legend(frame=FALSE, item.r = 0, position = tm_pos_out(\"right\", \"center\")), lwd=0.01) + tm_layout(component.autoscale=FALSE) + tm_shape(nc_miss) + tm_symbols(shape=8, size=0.5) } else { tm_shape(nc) + tm_fill(\"EB_loc\", breaks=brks, midpoint=1, palette=\"RdBu\") + tm_layout(legend.outside=TRUE) + tm_shape(nc_miss) + tm_symbols(shape=8, size=0.5) } set.seed(1) EBImoran.mc(nc$SID74, nc$BIR74, nb2listw(ncCC89, style=\"B\", zero.policy=TRUE), nsim=999, zero.policy=TRUE) ##  ##  Monte-Carlo simulation of Empirical Bayes Index (mean subtracted) ##  ## data:  cases: nc$SID74, risk population: nc$BIR74 ## weights: nb2listw(ncCC89, style = \"B\", zero.policy = TRUE) ## number of simulations + 1: 1000 ##  ## statistic = 0.25789, observed rank = 998, p-value = 0.002 ## alternative hypothesis: greater"},{"path":"https://r-spatial.github.io/spdep/articles/sids.html","id":"exploration-and-modelling-of-the-data","dir":"Articles","previous_headings":"","what":"Exploration and modelling of the data","title":"Introduction to the North Carolina SIDS data set (re-revised)","text":"One first steps taken Cressie Read (1985) try bring spatial trends dividing North Carolina 4×44\\times4 rough rectangles. Just see works, let us map rough rectangles proceeding .  Cressie constructs transformed SIDS rates variable, 1974–78, analyses (co-workers). can replicate stem--leaf figure p. 396 book, taken Cressie Read (1989):","code":"nc$both <- factor(paste(nc$L_id, nc$M_id, sep=\":\")) nboth <- length(table(unclass(nc$both))) if (tmap4) {   tm_shape(nc) + tm_polygons(fill=\"both\", fill.scale=tm_scale(values=\"brewer.set1\"), fill.legend = tm_legend(\"rough\\nrectangles\", frame=FALSE, item.r = 0, position = tm_pos_out(\"right\", \"center\")), lwd=0.01) + tm_layout(component.autoscale=FALSE) } else { tm_shape(nc) + tm_fill(\"both\", palette=\"Set1\", title=\"rough\\nrectangles\") + tm_layout(legend.outside=TRUE) } nc$ft.SID74 <- sqrt(1000)*(sqrt(nc$SID74/nc$BIR74) + sqrt((nc$SID74+1)/nc$BIR74)) stem(round(nc$ft.SID74, 1), scale=2) ##  ##   The decimal point is at the | ##  ##   0 | 9 ##   1 | 111244 ##   1 | 567789999 ##   2 | 0011111222334444 ##   2 | 55555666677778999999999 ##   3 | 000111122333333344444444 ##   3 | 5568999 ##   4 | 013344 ##   4 | 555557 ##   5 | 2 ##   5 |  ##   6 | 3"},{"path":"https://r-spatial.github.io/spdep/articles/sids.html","id":"medpol","dir":"Articles","previous_headings":"Exploration and modelling of the data","what":"Median polish smoothing","title":"Introduction to the North Carolina SIDS data set (re-revised)","text":"Cressie (1991, 46–48, 393–400) discusses detail smoothing may used partition variation data smooth rough. order try North Carolina SIDS data set, use coarse gridding four columns four rows given Cressie (1991, 553–54), four grid cells empty; given variables L_id M_id object nc. Next aggregate number live births number SIDS cases 1974–1978 grid cells: Using Freeman-Tukey transformation used county data, coerce data correctly configured matrix, cells empty. medpolish function applied matrix, told remove empty cells; function iterates rows columns matrix using median extract overall effect, row column effects, residuals: Returning factors linking rows columns counties, generating matrices dummy variables using model.matrix, can calculate fitted values Freeman-Tukey adjusted rate county, residuals subtracting fitted value observed rate. Naturally, fitted value counties grid cell:  figure shows median polish smoothing results three maps, observed Freeman-Tukey transformed SIDS rates, fitted smoothed values, residuals. addition, plot median polish object also shown, plotting smooth residuals outer product row column effects divided overall effect, indicate lack additivity row column case — relevant analysis tables covariates rather geographical grids.","code":"mBIR74 <- tapply(nc$BIR74, nc$both, sum) mSID74 <- tapply(nc$SID74, nc$both, sum) mFT <- sqrt(1000)*(sqrt(mSID74/mBIR74) + sqrt((mSID74+1)/mBIR74)) # mFT1 <- t(matrix(mFT, 4, 4, byrow=TRUE)) # wrong assignment of 12 elements to a 4x4 matrix detected by CRAN test 2021-05-22 rc <- do.call(\"rbind\", lapply(strsplit(names(mFT), \":\"), as.integer)) mFT1 <- matrix(as.numeric(NA), 4, 4) for (i in 1:nrow(rc)) mFT1[rc[i,1], rc[i,2]] <- mFT[i] med <- medpolish(mFT1, na.rm=TRUE, trace.iter=FALSE) med ##  ## Median Polish Results (Dataset: \"mFT1\") ##  ## Overall: 2.90965 ##  ## Row Effects: ## [1] -0.05686791 -0.37236370  0.05686791  0.79541774 ##  ## Column Effects: ## [1] -0.005484562 -0.446250551  0.003656375  0.726443256 ##  ## Residuals: ##           [,1]     [,2]      [,3]     [,4] ## [1,]        NA -0.45800  0.000000  0.37556 ## [2,] -0.092554  0.00000  0.101695  0.00000 ## [3,]  0.092554  0.30464 -0.090726 -0.55364 ## [4,]        NA       NA  0.000000       NA mL_id <- model.matrix(~ as.factor(nc$L_id) -1) mM_id <- model.matrix(~ as.factor(nc$M_id) -1) nc$pred <- c(med$overall + mL_id %*% med$row + mM_id %*% med$col) nc$mp_resid <- nc$ft.SID74 - nc$pred if (tmap4) {   out1 <- tm_shape(nc) + tm_polygons(fill=c(\"ft.SID74\", \"pred\"), fill.scale=tm_scale(values=\"brewer.yl_or_br\"), fill.legend=tm_legend(position=tm_pos_out(\"right\", \"center\"), frame=FALSE, item.r = 0), fill.free=FALSE, lwd=0.01) + tm_layout(panel.labels=c(\"Observed\", \"Median polish prediction\"))   out2 <- tm_shape(nc) + tm_polygons(fill=\"mp_resid\", fill.scale=tm_scale(values=\"brewer.rd_yl_gn\", midpoint=0), fill.legend=tm_legend(position=tm_pos_out(\"right\", \"center\"), frame=FALSE, item.r = 0), lwd=0.01) } else { out1 <- tm_shape(nc) + tm_fill(c(\"ft.SID74\", \"pred\")) + tm_facets(free.scales=FALSE) + tm_layout(panel.labels=c(\"Observed\", \"Median polish prediction\")) out2 <- tm_shape(nc) + tm_fill(\"mp_resid\", midpoint=0) + tm_layout(legend.outside=TRUE) } tmap_arrange(out1, out2, ncol=1)"},{"path":[]},{"path":"https://r-spatial.github.io/spdep/articles/subgraphs.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"No-neighbour observation and subgraph handling","text":"spdep package always careful disconnected graphs, especially disconnected observations graph nodes neighbours, incoming outgoing edges. nb neighbour objects, encoded integer vectors length 1 containing integer 0, invalid index [1,N][1, N], NN observation count. Functions taking neighbour objects arguments use zero.policy argument guide handle -neighbour observations. spdep also n.comp.nb find number disjoint connected subgraphs nb object, contributed Nicholas Lewin-Koh 2001 using depth-first search symmetric neighbours, showing addition observations belong subgraph. Obviously, -neighbour observations singleton graph nodes, subgraphs also troubling spatial analysis, connection spatial processes subgraphs. ripples one pond cross separate pond connected. spdep 1.3-1, steps began raise awareness possibility neighbour objects might created disconnected way, mostly warnings, computation subgraph measures default. vignette intended provide background steps.","code":""},{"path":"https://r-spatial.github.io/spdep/articles/subgraphs.html","id":"no-neighbour-observations","dir":"Articles","previous_headings":"","what":"No-neighbour observations","title":"No-neighbour observation and subgraph handling","text":"start, nb objects recorded -neighbour observations integer vector unit length value 0, neighbours recorded ID values 1 N, N observation count. print summary methods always reported presence -neighbour observations, listed IDs (region.id values). nb object contains -neighbour observations, user decide whether drop observations, retained, value give weights. zero.policy argument uses zero value TRUE, FALSE causes nb2listw fail. value zero.policy call functions like nb2listw, subset.listw mat2listw creating listw objects representing sparse spatial weights matrices added created object attribute, used subsequently pass choice functions. example, moran.test takes value attribute default zero.policy argument: observation ii neighbours, weights sum ∑j=1Nwij=0\\sum_{j=1}^N w_{ij} = 0, wij=0,∀jw_{ij} = 0, \\forall j (see discussion Bivand Portnov (2004)). eigenvalue also zero, consequences analytical inference: adjust.n argument measures spatial autocorrelation default TRUE, subtracts count singleton nodes NN attempt acknowledge reduction information available. discussion address problems arising analysing areal/lattice data, neighbours defined polygon features contiguous boundaries. One way -neighbour observations may occur islands. clearly case Freni-Sterrantino, Ventrucci, Rue (2018), Capraia Giglio Isles singleton nodes. take Westminster constituencies Wales used July 2024 UK general election. GDAL least version 3.7.0, driver supports compressed GeoPackage files, must decompressed first. boundaries taken Ordnance Survey Boundary-Line site, https://osdatahub.os.uk/downloads/open/BoundaryLine, choosing 2024 Westminster constituencies (https://www.os.uk/opendata/licence), simplified using tolerance 50m reduce object size, merged selected voting outcomes constituencies Great Britain https://electionresults.parliament.uk/countries/1, (https://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/). , subset Wales useful see: two subgraphs singleton Ynys Môn 31 constituencies: left map shows Ynys Môn can shown selecting name, black border, zero cardinality neighbour set, using card, filling polygon. right map shows location island, known English Anglesey, north-west Welsh mainland, neighbour links:  maps, can see island close two constituencies across Afon Menai (Menai Strait English), three simplified polygons less 280m apart, measured polygon boundaries: Using snap distance 280m, can join island two obvious proximate neighbours:  case, increasing snap default 10mm (close equivalents geometries known metrics; previously sqrt(.Machine$double.eps) 1.4901161^{-8} cases) helps. symmetric links added : always going case, strait narrow. islands much offshore, steps may required, large snap distance draw extra neighbours already connected observations. also possible increasing snap distance may fail link islands considered candidate neighbours, extents (bounding boxes), buffered snap value, intersect. can also use distances pick neighbour candidates meet criterion 280m, taking care lose ordering needed identify correct observations: candidates island , two neighbours across Menai Strait: addlinks1 function can used add links Ynys Môn neighbours, symmetry Ynys Môn. approach means island treated separately (scripted sequence), risk adding spurious neighbours denser parts study area. Since constituency observations areal support, surprising changing support points using kk-nearest neighbours work adequately, distance measurements points representing polygons rather areal unit boundaries: , Clwyd North, east Bangor Aberconwy, given neighbour Ynys Môn Dwyfor Meirionnydd, west Bangor Aberconwy, . addition, two subgraphs, still remain k=6k=6.","code":"library(spdep) ## Loading required package: spData ## Loading required package: sf ## Linking to GEOS 3.13.0, GDAL 3.9.2, PROJ 9.5.0; sf_use_s2() is TRUE args(moran.test) ## function (x, listw, randomisation = TRUE, zero.policy = attr(listw,  ##     \"zero.policy\"), alternative = \"greater\", rank = FALSE, na.action = na.fail,  ##     spChk = NULL, adjust.n = TRUE, drop.EI2 = FALSE)  ## NULL eigen(0)$values ## [1] 0 (GDAL37 <- as.numeric_version(unname(sf_extSoftVersion()[\"GDAL\"])) >= \"3.7.0\") ## [1] TRUE file <- \"etc/shapes/GB_2024_Wales_50m.gpkg.zip\" zipfile <- system.file(file, package=\"spdep\") if (GDAL37) {     w50m <- st_read(zipfile) } else {     td <- tempdir()     bn <- sub(\".zip\", \"\", basename(file), fixed=TRUE)     target <- unzip(zipfile, files=bn, exdir=td)     w50m <- st_read(target) } ## Reading layer `GB_2024_Wales_50m' from data source  ##   `/tmp/RtmpqhccSk/temp_libpath108a2257736002/spdep/etc/shapes/GB_2024_Wales_50m.gpkg.zip'  ##   using driver `GPKG' ## Simple feature collection with 32 features and 19 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 146597.1 ymin: 164536.5 xmax: 355287 ymax: 395993.5 ## Projected CRS: OSGB36 / British National Grid (w50m |> poly2nb(row.names=as.character(w50m$Constituency)) -> nb_W_50m) ## Warning in poly2nb(w50m, row.names = as.character(w50m$Constituency)): some observations have no neighbours; ## if this seems unexpected, try increasing the snap argument. ## Warning in poly2nb(w50m, row.names = as.character(w50m$Constituency)): neighbour object has 2 sub-graphs; ## if this sub-graph count seems unexpected, try increasing the snap argument. ## Neighbour list object: ## Number of regions: 32  ## Number of nonzero links: 136  ## Percentage nonzero weights: 13.28125  ## Average number of links: 4.25  ## 1 region with no links: ## Ynys Môn ## 2 disjoint connected subgraphs attr(nb_W_50m, \"ncomp\")$comp.id |>table() |> table() ##  ##  1 31  ##  1  1 ynys_mon <- w50m$Constituency == \"Ynys Môn\" pts <- st_point_on_surface(st_geometry(w50m)) opar <- par(mfrow=c(1, 2)) plot(st_geometry(w50m), border=\"grey75\") plot(st_geometry(w50m)[ynys_mon], add=TRUE) plot(st_geometry(w50m)[card(nb_W_50m) == 0L], add=TRUE, border=\"transparent\", col=\"wheat1\") plot(st_geometry(w50m), border=\"grey75\") plot(nb_W_50m, pts, add=TRUE) par(opar) dym <- c(st_distance(w50m[ynys_mon,], w50m)) sort(dym)[1:12] ## Units: [m] ##  [1]      0.0000    123.4132    277.5414  16658.7265  37985.7086  54096.7729 ##  [7]  58146.4320  65550.2491  67696.3323  93741.9873 113007.3659 137858.1826 (nb_W_50m_snap <- poly2nb(w50m, row.names=as.character(w50m$Constituency), snap=280)) ## Neighbour list object: ## Number of regions: 32  ## Number of nonzero links: 140  ## Percentage nonzero weights: 13.67188  ## Average number of links: 4.375 plot(st_geometry(w50m), border=\"grey75\") plot(nb_W_50m_snap, pts, add=TRUE) attr(nb_W_50m_snap, \"region.id\")[nb_W_50m_snap[[which(ynys_mon)]]] ## [1] \"Bangor Aberconwy\"   \"Dwyfor Meirionnydd\" (meet_criterion <- sum(dym <= units::set_units(280, \"m\"))) ## [1] 3 (cands <- attr(nb_W_50m, \"region.id\")[order(dym)[1:meet_criterion]]) ## [1] \"Ynys Môn\"           \"Bangor Aberconwy\"   \"Dwyfor Meirionnydd\" (nb_W_50m_add <- addlinks1(nb_W_50m, from = cands[1], to = cands[2:meet_criterion])) ## Neighbour list object: ## Number of regions: 32  ## Number of nonzero links: 140  ## Percentage nonzero weights: 13.67188  ## Average number of links: 4.375 all.equal(nb_W_50m_add, nb_W_50m_snap, check.attributes=FALSE) ## [1] TRUE k2 <- knn2nb(knearneigh(pts, k=2), row.names=as.character(w50m$Constituency), sym=TRUE) ## Warning in knn2nb(knearneigh(pts, k = 2), row.names = ## as.character(w50m$Constituency), : neighbour object has 2 sub-graphs attr(k2, \"region.id\")[k2[[which(ynys_mon)]]] ## [1] \"Bangor Aberconwy\" \"Clwyd North\""},{"path":"https://r-spatial.github.io/spdep/articles/subgraphs.html","id":"subgraphs","dir":"Articles","previous_headings":"","what":"Subgraphs","title":"No-neighbour observation and subgraph handling","text":"Subgraphs may found -neighbour observations present, also graph split two blocks observations path observation block another block, across low population density constituencies mid-Wales: can show block structure displaying binary spatial weights matrix:  occurs frequently point support, may also occur areal support, Freni-Sterrantino, Ventrucci, Rue (2018) find eight municipalities island Elba. spdep 1.3-6, igraph spatialreg packages available, n.comp.nb uses igraph::components compute graph components, also using depth-first search. original implementation fast, directed (asymmetric) graphs converts first symmetry, igraph::components can handle directed graphs without conversion (see https://github.com/r-spatial/spdep/issues/160 details). Another case demonstrates cyclical subgraphs may appear; taken constituencies 2024 UK general election, subsetted England south London. second subgraph two members, others’ neighbours, known cyclical component. constituencies Isle Wight:  consequences eigenvalues spatial weights matrix, pointed Smirnov Anselin (2009) Bivand, Hauke, Kossowski (2013). row-standardised weights, eigenvalues component : “takes ” lower domain boundary, whole data set now : compared lower domain boundary remainder study area: subgraph may added remainder shown : Using 5km cutoff seems prudent, work snap value. Taking Isle Wight East first, four constituencies boundaries within 5km: Obviously contiguous neighbour among zero distance, needs dropped, although addlinks1 drop duplicate: Although constituencies now linked, see whether using 5km criterion brings extra neighbours Isle Wight West: , , need beware sorting order zero self-distance contiguous neighbour distance, now second position: yields links north-west:  remains add suitable generalisation addlinks1 handle vector argument argument taking list vectors.","code":"(k6 <- knn2nb(knearneigh(pts, k=6), row.names=as.character(w50m$Constituency), sym=TRUE)) ## Warning in knn2nb(knearneigh(pts, k = 6), row.names = ## as.character(w50m$Constituency), : neighbour object has 2 sub-graphs ## Neighbour list object: ## Number of regions: 32  ## Number of nonzero links: 238  ## Percentage nonzero weights: 23.24219  ## Average number of links: 7.4375  ## 2 disjoint connected subgraphs plot(st_geometry(w50m), border=\"grey75\") plot(k6, pts, add=TRUE) o <- order(attr(k6, \"ncomp\")$comp.id) image(t(nb2mat(k6, style=\"B\")[o, rev(o)]), axes=FALSE, asp=1) (k6a <- knn2nb(knearneigh(pts, k=6), row.names=as.character(w50m$Constituency))) ## Warning in knn2nb(knearneigh(pts, k = 6), row.names = ## as.character(w50m$Constituency)): neighbour object has 2 sub-graphs ## Neighbour list object: ## Number of regions: 32  ## Number of nonzero links: 192  ## Percentage nonzero weights: 18.75  ## Average number of links: 6  ## 2 disjoint connected subgraphs ## Non-symmetric neighbours list file <- \"etc/shapes/GB_2024_southcoast_50m.gpkg.zip\" zipfile <- system.file(file, package=\"spdep\") if (GDAL37) {     sc50m <- st_read(zipfile) } else {     td <- tempdir()     bn <- sub(\".zip\", \"\", basename(file), fixed=TRUE)     target <- unzip(zipfile, files=bn, exdir=td)     sc50m <- st_read(target) } ## Reading layer `GB_2024_southcoast_50m' from data source  ##   `/tmp/RtmpqhccSk/temp_libpath108a2257736002/spdep/etc/shapes/GB_2024_southcoast_50m.gpkg.zip'  ##   using driver `GPKG' ## Simple feature collection with 119 features and 19 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 82643.12 ymin: 5342.9 xmax: 640301.6 ymax: 187226.2 ## Projected CRS: OSGB36 / British National Grid (nb_sc_50m <- poly2nb(sc50m, row.names=as.character(sc50m$Constituency))) ## Warning in poly2nb(sc50m, row.names = as.character(sc50m$Constituency)): neighbour object has 2 sub-graphs; ## if this sub-graph count seems unexpected, try increasing the snap argument. ## Neighbour list object: ## Number of regions: 119  ## Number of nonzero links: 530  ## Percentage nonzero weights: 3.742674  ## Average number of links: 4.453782  ## 2 disjoint connected subgraphs nc <- attr(nb_sc_50m, \"ncomp\")$comp.id table(nc) ## nc ##   1   2  ## 117   2 (sub2 <- attr(nb_sc_50m, \"region.id\")[nc == 2L]) ## [1] \"Isle of Wight East\" \"Isle of Wight West\" pts <- st_point_on_surface(st_geometry(sc50m)) plot(st_geometry(sc50m), border=\"grey75\") plot(st_geometry(sc50m)[nc == 2L], border=\"orange\", lwd=2, add=TRUE) plot(nb_sc_50m, pts, add=TRUE) 1/range(eigen(cbind(c(0, 1), c(1, 0)))$values) ## [1] -1  1 1/range(eigen(nb2mat(subset(nb_sc_50m, nc == 2L), style=\"W\"))$values) ## [1] -1  1 1/range(eigen(nb2mat(nb_sc_50m, style=\"W\"))$values) ## [1] -1  1 1/range(eigen(nb2mat(subset(nb_sc_50m, nc == 1L), style=\"W\"))$values) ## [1] -1.094637  1.000000 iowe <- match(sub2[1], attr(nb_sc_50m, \"region.id\")) diowe <- c(st_distance(sc50m[iowe,], sc50m)) sort(diowe)[1:12] ## Units: [m] ##  [1]     0.000     0.000  1886.833  3509.366  6693.575  6943.672  7678.999 ##  [8]  8576.454 10579.530 12163.332 16875.920 17161.786 ioww <- match(sub2[2], attr(nb_sc_50m, \"region.id\")) dioww <- c(st_distance(sc50m[ioww,], sc50m)) sort(dioww)[1:12] ## Units: [m] ##  [1]     0.000     0.000  1232.724  2541.318  5746.764  5770.602  8902.579 ##  [8]  9747.265 10529.540 10909.845 12250.564 12379.871 (meet_criterion <- sum(diowe <= units::set_units(5000, \"m\"))) ## [1] 4 (cands <- attr(nb_sc_50m, \"region.id\")[order(diowe)[1:meet_criterion]]) ## [1] \"Isle of Wight East\" \"Isle of Wight West\" \"Portsmouth South\"   ## [4] \"Gosport\" (nb_sc_50m_iowe <- addlinks1(nb_sc_50m, from = cands[1], to = cands[3:meet_criterion])) ## Neighbour list object: ## Number of regions: 119  ## Number of nonzero links: 534  ## Percentage nonzero weights: 3.77092  ## Average number of links: 4.487395 (meet_criterion <- sum(dioww <= units::set_units(5000, \"m\"))) ## [1] 4 (cands <- attr(nb_sc_50m, \"region.id\")[order(dioww)[1:meet_criterion]]) ## [1] \"Isle of Wight East\" \"Isle of Wight West\" \"New Forest West\"    ## [4] \"New Forest East\" (nb_sc_50m_iow <- addlinks1(nb_sc_50m_iowe, from = cands[2], to = cands[3:meet_criterion])) ## Neighbour list object: ## Number of regions: 119  ## Number of nonzero links: 538  ## Percentage nonzero weights: 3.799167  ## Average number of links: 4.521008 pts <- st_point_on_surface(st_geometry(sc50m)) plot(st_geometry(sc50m), border=\"grey75\") plot(st_geometry(sc50m)[nc == 2L], border=\"orange\", lwd=2, add=TRUE) plot(nb_sc_50m_iow, pts, add=TRUE)"},{"path":"https://r-spatial.github.io/spdep/articles/subgraphs.html","id":"per-session-control-of-function-behaviour","dir":"Articles","previous_headings":"","what":"Per-session control of function behaviour","title":"No-neighbour observation and subgraph handling","text":"early , default value zero.policy argument many methods functions NULL. value NULL, zero.policy set get.ZeroPolicyOption: loading spdep, internal option set FALSE, functions methods using zero.policy need choose handle islands: case, shown island may reasonably associated proximate constituencies mainland. , however, user wishes override default, set.ZeroPolicyOption may used set different per-session default: listw object created zero.policy set TRUE, choice added output object attribute applied object used (unless specifically overridden). Note also 32 constituencies, observation count reported spweights.constants called print method listw object argument adjust.n TRUE, dropping -neighbour observations observation count. internal options introduced suppress -neighbour subgraph warnings creating nb objects. default values follows: get.NoNeighbourOption controls issuing warnings nb objects created -neighbour observations; get.SubgraphOption works similarly warnings issued one graph component; TRUE default. get.SubgraphCeiling sets integer value graph nodes plus graph edges calculating graph considered costly compute time, default 100,000. corresponds dense neighbour set just 300 nodes (almost 100000 edges) needed use inverse distance weights, just 14,000 nodes average neighbour count 6. print method nb objects reports -neighbour subgraph status anyway, careful users always examine generated objects may prefer supress warnings, warnings seem prudent users may examine objects, generation subsetting larger objects, example creation training test data sets. Welsh constituency boundaries used show behaviour internal options: Turning removes warnings: get.SubgraphOption FALSE, attribute containing output n.comp.nb added: reduction ceiling node count 32 plus edge count 136 also supresses calculation graph components: Restoring remaining default values:","code":"get.ZeroPolicyOption() ## [1] FALSE try(nb2listw(nb_W_50m)) ## Error in nb2listw(nb_W_50m) :  ##   Empty neighbour sets found (zero.policy: FALSE) set.ZeroPolicyOption(TRUE) get.ZeroPolicyOption() ## [1] TRUE (lw <- nb2listw(nb_W_50m)) ## Characteristics of weights list object: ## Neighbour list object: ## Number of regions: 32  ## Number of nonzero links: 136  ## Percentage nonzero weights: 13.28125  ## Average number of links: 4.25  ## 1 region with no links: ## Ynys Môn ## 2 disjoint connected subgraphs ##  ## Weights style: W  ## Weights constants summary: ##    n  nn S0       S1      S2 ## W 31 961 31 15.36355 129.051 attr(lw, \"zero.policy\") ## [1] TRUE set.ZeroPolicyOption(FALSE) get.NoNeighbourOption() ## [1] TRUE get.SubgraphOption() ## [1] TRUE get.SubgraphCeiling() ## [1] 100000 set.NoNeighbourOption(FALSE) (w50m |> poly2nb(row.names=as.character(w50m$Constituency)) -> nb_W_50mz) ## Warning in poly2nb(w50m, row.names = as.character(w50m$Constituency)): neighbour object has 2 sub-graphs; ## if this sub-graph count seems unexpected, try increasing the snap argument. ## Neighbour list object: ## Number of regions: 32  ## Number of nonzero links: 136  ## Percentage nonzero weights: 13.28125  ## Average number of links: 4.25  ## 1 region with no links: ## Ynys Môn ## 2 disjoint connected subgraphs set.SubgraphOption(FALSE) (w50m |> poly2nb(row.names=as.character(w50m$Constituency)) -> nb_W_50my) ## Neighbour list object: ## Number of regions: 32  ## Number of nonzero links: 136  ## Percentage nonzero weights: 13.28125  ## Average number of links: 4.25  ## 1 region with no links: ## Ynys Môn str(attr(nb_W_50my, \"ncomp\")) ##  NULL set.SubgraphOption(TRUE) set.SubgraphCeiling(100L) (w50m |> poly2nb(row.names=as.character(w50m$Constituency)) -> nb_W_50mx) ## Neighbour list object: ## Number of regions: 32  ## Number of nonzero links: 136  ## Percentage nonzero weights: 13.28125  ## Average number of links: 4.25  ## 1 region with no links: ## Ynys Môn str(attr(nb_W_50mx, \"ncomp\")) ##  NULL set.SubgraphCeiling(100000L) set.NoNeighbourOption(TRUE)"},{"path":"https://r-spatial.github.io/spdep/articles/subgraphs.html","id":"unintentional-disconnected-graphs","dir":"Articles","previous_headings":"","what":"Unintentional disconnected graphs","title":"No-neighbour observation and subgraph handling","text":"Sometimes apparently sensible polygons turn represented way disconnected graphs generated extracting contiguities. One case raised https://github.com/r-spatial/spdep/issues/162, subdivisions Tokyo. original data file tokyomet262.* https://sgsup.asu.edu/sites/default/files/SparcFiles/tokyo_0.zip created twenty years ago Tomoki Nakaya Martin Charlton, geometry issues known time. possibility may affect legacy files projection geometries 32-bit platforms, known whether affected file. re-packaged compressed GeoPackage: correcting invalid polygons: applying poly2nb legacy default snap value produced numerous singleton observations well many multiple-observation subgraphs: legacy default snap value coordinates measured metres 15 nanometres, effectively assumed coordinates making polygon boundaries identical: Stepping little 2mm, lack contact ceased problem. basis, default changed spdep 1.3-6 10mm projected polygons, snap value used returned attribute neighbour object: polygons represented geographical (spherical) coordinates, new default spdep 1.3-6 set value mimicking 10mm: default snap value used poly2nb polygons expressed decimal degrees : set based apparent “size” 10mm decimal degrees:","code":"file <- \"etc/shapes/tokyo.gpkg.zip\" zipfile <- system.file(file, package=\"spdep\") if (GDAL37) {     tokyo <- st_read(zipfile) } else {     td <- tempdir()     bn <- sub(\".zip\", \"\", basename(file), fixed=TRUE)     target <- unzip(zipfile, files=bn, exdir=td)     tokyo <- st_read(target) } ## Reading layer `tokyo' from data source  ##   `/tmp/RtmpqhccSk/temp_libpath108a2257736002/spdep/etc/shapes/tokyo.gpkg.zip'  ##   using driver `GPKG' ## Simple feature collection with 262 features and 3 fields ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 266206.6 ymin: -90932.11 xmax: 411400.3 ymax: 37142.75 ## Projected CRS: Tokyo / Japan Plane Rectangular CS VI all(st_is_valid(tokyo)) ## [1] TRUE tokyo <- st_make_valid(tokyo) (nb_t0 <- poly2nb(tokyo, snap=sqrt(.Machine$double.eps))) ## Warning in poly2nb(tokyo, snap = sqrt(.Machine$double.eps)): some observations have no neighbours; ## if this seems unexpected, try increasing the snap argument. ## Warning in poly2nb(tokyo, snap = sqrt(.Machine$double.eps)): neighbour object has 23 sub-graphs; ## if this sub-graph count seems unexpected, try increasing the snap argument. ## Neighbour list object: ## Number of regions: 262  ## Number of nonzero links: 946  ## Percentage nonzero weights: 1.378125  ## Average number of links: 3.610687  ## 10 regions with no links: ## 101, 127, 134, 135, 152, 154, 167, 237, 242, 243 ## 23 disjoint connected subgraphs units::set_units(units::set_units(attr(nb_t0, \"snap\"), \"m\"), \"nm\") ## 14.90116 [nm] (nb_t1 <- poly2nb(tokyo, snap=0.002)) ## Neighbour list object: ## Number of regions: 262  ## Number of nonzero links: 1390  ## Percentage nonzero weights: 2.02494  ## Average number of links: 5.305344 units::set_units(units::set_units(attr(nb_t1, \"snap\"), \"m\"), \"mm\") ## 2 [mm] (nb_t2 <- poly2nb(tokyo)) ## Neighbour list object: ## Number of regions: 262  ## Number of nonzero links: 1390  ## Percentage nonzero weights: 2.02494  ## Average number of links: 5.305344 units::set_units(units::set_units(attr(nb_t2, \"snap\"), \"m\"), \"mm\") ## 10 [mm] (nb_t3 <- poly2nb(st_transform(tokyo, \"OGC:CRS84\"))) ## Neighbour list object: ## Number of regions: 262  ## Number of nonzero links: 1336  ## Percentage nonzero weights: 1.946274  ## Average number of links: 5.099237 attr(nb_t3, \"snap\") ## [1] 9e-08 (180 * 0.01) / (pi * 6378137) ## [1] 8.983153e-08"},{"path":[]},{"path":"https://r-spatial.github.io/spdep/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Roger Bivand. Maintainer, author. Micah Altman. Contributor. Luc Anselin. Contributor. Renato Assunção. Contributor. Anil Bera. Contributor. Olaf Berke. Contributor. F. Guillaume Blanchet. Contributor. Marilia Carvalho. Contributor. Bjarke Christensen. Contributor. Yongwan Chun. Contributor. Carsten Dormann. Contributor. Stéphane Dray. Contributor. Dewey Dunnington. Contributor. Virgilio Gómez-Rubio. Contributor. Malabika Koley. Contributor. Tomasz Kossowski. Contributor. Elias Krainski. Contributor. Pierre Legendre. Contributor. Nicholas Lewin-Koh. Contributor. Angela Li. Contributor. Giovanni Millo. Contributor. Werner Mueller. Contributor. Hisaji Ono. Contributor. Josiah Parry. Contributor. Pedro Peres-Neto. Contributor. Michał Pietrzak. Contributor. Gianfranco Piras. Contributor. Markus Reder. Contributor. Jeff Sauer. Contributor. Michael Tiefelsdorf. Contributor. René Westerholt. Contributor. Justyna Wilk. Contributor. Levi Wolf. Contributor. Danlin Yu. Contributor.","code":""},{"path":"https://r-spatial.github.io/spdep/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bivand R, Wong D (2018). “Comparing implementations global local indicators spatial association.” TEST, 27(3), 716–748. doi:10.1007/s11749-018-0599-x. Roger Bivand (2022). “R Packages Analyzing Spatial Data: Comparative Case Study Areal Data.” Geographical Analysis, 54(3), 488-518. doi:10.1111/gean.12319. Bivand R, Pebesma E, Gómez-Rubio V (2013). Applied spatial data analysis R, Second edition. Springer, NY. https://asdar-book.org/. Pebesma E, Bivand R (2023). Spatial Data Science Applications R. Chapman & Hall. https://r-spatial.org/book/.","code":"@Article{,   author = {Roger Bivand and David W. S. Wong},   title = {Comparing implementations of global and local indicators of spatial association},   journal = {TEST},   year = {2018},   volume = {27},   number = {3},   pages = {716--748},   doi = {10.1007/s11749-018-0599-x}, } @Article{,   author = {{Roger Bivand}},   title = {R Packages for Analyzing Spatial Data: A Comparative Case Study with Areal Data},   journal = {Geographical Analysis},   year = {2022},   volume = {54},   number = {3},   pages = {488-518},   doi = {10.1111/gean.12319}, } @Book{,   author = {Roger S. Bivand and Edzer Pebesma and Virgilio Gómez-Rubio},   title = {Applied spatial data analysis with {R}, Second edition},   year = {2013},   publisher = {Springer, NY},   url = {https://asdar-book.org/}, } @Book{,   author = {Edzer Pebesma and Roger S. Bivand},   title = {Spatial Data Science With Applications in {R}},   year = {2023},   publisher = {Chapman & Hall},   url = {https://r-spatial.org/book/}, }"},{"path":[]},{"path":"https://r-spatial.github.io/spdep/index.html","id":"spatial-dependence-weighting-schemes-and-statistics","dir":"","previous_headings":"","what":"Spatial Dependence: Weighting Schemes and Statistics","title":"Spatial Dependence: Weighting Schemes, Statistics","text":"collection functions create spatial weights matrix objects polygon contiguities, point patterns distance tessellations, summarizing objects, permitting use spatial data analysis, including regional aggregation minimum spanning tree; collection tests spatial autocorrelation, including global Morans Gearys C proposed Cliff Ord (1973, ISBN: 0850860369) (1981, ISBN: 0850860814), Hubert/Mantel general cross product statistic, Empirical Bayes estimates Assunção/Reis (1999) (https://doi.org/10.1002/(SICI)1097-0258(19990830)18:16%3C2147%3A%3AAID-SIM179%3E3.0.CO%3B2-) Index, Getis/Ord G (Getis Ord 1992) (https://doi.org/10.1111/j.1538-4632.1992.tb00261.x) multicoloured join count statistics, APLE (Li et al. ) (https://doi.org/10.1111/j.1538-4632.2007.00708.x), local Morans (Anselin 1995) (https://doi.org/10.1111/j.1538-4632.1995.tb00338.x) Getis/Ord G (Ord Getis 1995) (https://doi.org/10.1111/j.1538-4632.1995.tb00912.x), saddlepoint approximations (Tiefelsdorf 2002) (https://doi.org/10.1111/j.1538-4632.2002.tb01084.x) exact tests global local Morans (Bivand et al. 2009) (https://doi.org/10.1016/j.csda.2008.07.021) LOSH local indicators spatial heteroscedasticity (Ord Getis) (https://doi.org/10.1007/s00168-011-0492-y), extensions ‘Bivand’ (2022) doi:10.1111/gean.12319. implementation measures described Bivand Wong (2018) (https://doi.org/10.1007/s11749-018-0599-x). Extra measures contributed Josiah Parry. Lagrange multiplier tests spatial dependence linear models provided (Anselin et al. 1996) (https://doi.org/10.1016/0166-0462(95)02111-6), Rao’s score tests hypothesised spatial Durbin models based fitted linear models (Koley Bera 2024) (https://doi.org/10.1080/17421772.2023.2256810). sfdep (https://cran.r-project.org/package=sfdep) provides piped interface spdep. spdep spatialreg versions >= 1.2-1, model fitting functions previously present package defunct spdep may found spatialreg. Default branch now main Moved R-Forge","code":""},{"path":"https://r-spatial.github.io/spdep/reference/COL.OLD.html","id":null,"dir":"Reference","previous_headings":"","what":"Columbus OH spatial analysis data set - old numbering — oldcol","title":"Columbus OH spatial analysis data set - old numbering — oldcol","text":"COL.OLD data frame 49 rows 22 columns. observations ordered numbered original analyses data set SpaceStat documentation Anselin, L. 1988 Spatial econometrics: methods models, Dordrecht: Kluwer. Unit analysis: 49 neighbourhoods Columbus, OH, 1980 data. addition data set includes COL.nb, neighbours list used Anselin (1988).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/COL.OLD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Columbus OH spatial analysis data set - old numbering — oldcol","text":"","code":"data(oldcol)"},{"path":"https://r-spatial.github.io/spdep/reference/COL.OLD.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Columbus OH spatial analysis data set - old numbering — oldcol","text":"data frame contains following columns: AREA_PL computed ArcView (agrees areas polygons “columbus” data set PERIMETER computed ArcView COLUMBUS. internal polygon ID (ignore) COLUMBUS.another internal polygon ID (ignore) POLYID yet another polygon ID NEIG neighborhood id value (1-49);              conforms id value used Spatial Econometrics book. HOVAL housing value ($1,000) INC household income ($1,000) CRIME residential burglaries vehicle thefts per thousand         households neighborhood OPEN open space neighborhood PLUMB percentage housing units without plumbin DISCBD distance CBD X x coordinate (arbitrary digitizing units, polygon coordinates) Y y coordinate (arbitrary digitizing units, polygon coordinates) AREA_SS neighborhood area (computed SpaceStat) NSA north-south dummy (North=1) NSB north-south dummy (North=1) EW east-west dummy (East=1) CP core-periphery dummy (Core=1) THOUS constant=1,000 NEIGNO NEIG+1,000, alternative neighborhood id value PERIM polygon perimeter (computed SpaceStat)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/COL.OLD.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Columbus OH spatial analysis data set - old numbering — oldcol","text":"row names COL.OLD region.id attribute COL.nb set columbus$NEIGNO.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/COL.OLD.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Columbus OH spatial analysis data set - old numbering — oldcol","text":"Anselin, Luc.  1988.  Spatial econometrics: methods models.  Dordrecht: Kluwer Academic, Table 12.1 p. 189.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/COL.OLD.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Columbus OH spatial analysis data set - old numbering — oldcol","text":"source data files prepared Luc Anselin, Spatial Analysis Laboratory, Department Agricultural Consumer Economics, University Illinois, Urbana-Champaign.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBImoran.mc.html","id":null,"dir":"Reference","previous_headings":"","what":"Permutation test for empirical Bayes index — EBImoran.mc","title":"Permutation test for empirical Bayes index — EBImoran.mc","text":"empirical Bayes index modification Moran's testing spatial autocorrelation rate, typically number observed cases population risk. index value tested using nsim random permutations index given spatial weighting scheme, establish rank observed statistic relation nsim simulated values.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBImoran.mc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permutation test for empirical Bayes index — EBImoran.mc","text":"","code":"EBImoran.mc(n, x, listw, nsim, zero.policy = attr(listw, \"zero.policy\"),   alternative = \"greater\", spChk=NULL, return_boot=FALSE,  subtract_mean_in_numerator=TRUE)"},{"path":"https://r-spatial.github.io/spdep/reference/EBImoran.mc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permutation test for empirical Bayes index — EBImoran.mc","text":"n numeric vector counts cases length neighbours list listw x numeric vector populations risk length neighbours list listw listw listw object created example nb2listw nsim number permutations zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA alternative character string specifying alternative hypothesis, must one \"greater\" (default), \"two.sided\", \"less\" spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() return_boot return object class boot equivalent permutation bootstrap rather object class htest subtract_mean_in_numerator default TRUE, TRUE subtract mean z numerator EBI equation p. 2157 reference (consulted Renato Assunção 2016-02-19); February 2016 default FALSE agreeing printed paper.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBImoran.mc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Permutation test for empirical Bayes index — EBImoran.mc","text":"statistic used (m number observations): $$EBI = \\frac{m}{\\sum_{=1}^{m}\\sum_{j=1}^{m}w_{ij}} \\frac{\\sum_{=1}^{m}\\sum_{j=1}^{m}w_{ij}z_i z_j}{\\sum_{=1}^{m}(z_i - \\bar{z})^2} $$ : $$z_i = \\frac{p_i - b}{\\sqrt{v_i}}$$ : $$p_i = n_i / x_i$$ $$v_i = + (b / x_i)$$ $$b = \\sum_{=1}^{m} n_i / \\sum_{=1}^{m} x_i $$ $$= s^2 - b / (\\sum_{=1}^{m} x_i / m)$$ $$s^2 = \\sum_{=1}^{m} x_i (p_i - b)^2 / \\sum_{=1}^{m} x_i $$","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBImoran.mc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permutation test for empirical Bayes index — EBImoran.mc","text":"list class htest mc.sim containing following components: statistic value observed Moran's . parameter rank observed Moran's . p.value pseudo p-value test. alternative character string describing alternative hypothesis. method character string giving method used. data.name character string giving name(s) data, number simulations. res nsim simulated values statistic, final value observed statistic z numerical vector Empirical Bayes indices z ","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBImoran.mc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Permutation test for empirical Bayes index — EBImoran.mc","text":"Assunção RM, Reis EA 1999 new proposal adjust Moran's population density. Statistics Medicine 18, pp. 2147–2162; Bivand RS, Wong DWS 2018 Comparing implementations global local indicators spatial association. TEST, 27(3), 716–748 doi:10.1007/s11749-018-0599-x","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBImoran.mc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Permutation test for empirical Bayes index — EBImoran.mc","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/EBImoran.mc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Permutation test for empirical Bayes index — EBImoran.mc","text":"","code":"nc.sids <- st_read(system.file(\"shapes/sids.gpkg\", package=\"spData\")[1], quiet=TRUE) rn <- as.character(nc.sids$FIPS) ncCC89_nb <- read.gal(system.file(\"weights/ncCC89.gal\", package=\"spData\")[1],  region.id=rn) #> Warning: neighbour object has 3 sub-graphs EBImoran.mc(nc.sids$SID74, nc.sids$BIR74,  nb2listw(ncCC89_nb, style=\"B\", zero.policy=TRUE), nsim=999,  alternative=\"two.sided\", zero.policy=TRUE) #> The default for subtract_mean_in_numerator set TRUE from February 2016 #>  #> \tMonte-Carlo simulation of Empirical Bayes Index (mean subtracted) #>  #> data:  cases: nc.sids$SID74, risk population: nc.sids$BIR74 #> weights: nb2listw(ncCC89_nb, style = \"B\", zero.policy = TRUE) #> number of simulations + 1: 1000 #>  #> statistic = 0.25789, observed rank = 999, p-value = 0.002 #> alternative hypothesis: two.sided #>  sids.p <- nc.sids$SID74 / nc.sids$BIR74 moran.mc(sids.p, nb2listw(ncCC89_nb, style=\"B\", zero.policy=TRUE),  nsim=999, alternative=\"two.sided\", zero.policy=TRUE) #>  #> \tMonte-Carlo simulation of Moran I #>  #> data:  sids.p  #> weights: nb2listw(ncCC89_nb, style = \"B\", zero.policy = TRUE)   #> number of simulations + 1: 1000  #>  #> statistic = 0.20904, observed rank = 997, p-value = 0.006 #> alternative hypothesis: two.sided #>"},{"path":"https://r-spatial.github.io/spdep/reference/EBest.html","id":null,"dir":"Reference","previous_headings":"","what":"Global Empirical Bayes estimator — EBest","title":"Global Empirical Bayes estimator — EBest","text":"function computes global empirical Bayes estimates rates \"shrunk\" overall mean.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Global Empirical Bayes estimator — EBest","text":"","code":"EBest(n, x, family=\"poisson\")"},{"path":"https://r-spatial.github.io/spdep/reference/EBest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Global Empirical Bayes estimator — EBest","text":"n numeric vector counts cases x numeric vector populations risk family either \"poisson\" rare conditions \"binomial\" non-rare conditions","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBest.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Global Empirical Bayes estimator — EBest","text":"Details implementation \"poisson\" family found Marshall, p. 284–5, Bailey Gatrell p. 303–306 exercise 8.2, pp. 328–330. \"binomial\" family, see Martuzzi Elliott (implementation Olaf Berke).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Global Empirical Bayes estimator — EBest","text":"data frame two columns: raw numerical vector raw (crude) rates estmm numerical vector empirical Bayes estimates parameters attribute list components:  global method moments phi value m global method moments gamma value","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Global Empirical Bayes estimator — EBest","text":"Marshall R M (1991) Mapping disease mortality rates using Empirical Bayes Estimators, Applied Statistics, 40, 283–294; Bailey T, Gatrell (1995) Interactive Spatial Data Analysis, Harlow: Longman, pp. 303–306, Martuzzi M, Elliott P (1996) Empirical Bayes estimation small area prevalence non-rare conditions, Statistics Medicine 15, 1867–1873.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Global Empirical Bayes estimator — EBest","text":"Roger Bivand Roger.Bivand@nhh.Olaf Berke, Population Medicine, OVC, University Guelph, CANADA","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/EBest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Global Empirical Bayes estimator — EBest","text":"","code":"auckland <- st_read(system.file(\"shapes/auckland.gpkg\", package=\"spData\")[1], quiet=TRUE) res <- EBest(auckland$M77_85, 9*auckland$Und5_81) attr(res, \"parameters\") #> $a #> [1] 7.284173e-07 #>  #> $b #> [1] 0.002633436 #>  auckland$estmm000 <- res$estmm*1000 plot(auckland[,\"estmm000\"], breaks=c(0,2,2.5,3,3.5,5),  main=\"Infant mortality per 1000 per year\")  data(huddersfield, package=\"spData\") res <- EBest(huddersfield$cases, huddersfield$total, family=\"binomial\") round(res[,1:2],4)*100 #>      raw estmm #> 1  42.86 34.44 #> 2  28.95 29.56 #> 3  28.31 28.94 #> 4  21.43 28.93 #> 5  33.33 30.72 #> 6  30.86 30.43 #> 7  33.70 31.85 #> 8  45.61 35.93 #> 9  26.67 28.95 #> 10 29.41 29.95 #> 11 27.76 28.36 #> 12 33.75 31.75 #> 13 32.67 31.84 #> 14 22.91 25.36 #> 15 34.21 32.33 #> 16 33.77 31.72 #> 17 29.09 29.69 #> 18 15.87 24.36 #> 19 40.91 32.11 #> 20 40.00 31.01 #> 21 28.79 29.53 #> 22 38.89 31.47 #> 23 28.32 29.10 #> 24 33.33 31.44 #> 25 13.95 22.36 #> 26 33.77 31.72 #> 27 31.58 30.31 #> 28 33.33 30.42 #> 29 26.67 28.26 #> 30 63.64 33.57 #> 31 34.38 32.24 #> 32 20.00 27.62 #> 33 19.15 24.60 #> 34 25.53 28.54 #> 35 24.14 27.79 #> 36 44.00 32.98 #> 37 25.33 27.95 #> 38 18.18 26.96 #> 39 31.78 30.97 #> 40 32.20 30.88 #> 41 26.19 28.23 #> 42 19.05 26.65 #> 43 16.67 26.81 #> 44 20.00 28.66 #> 45 32.99 31.54 #> 46 50.00 31.97 #> 47 37.21 32.30 #> 48 32.79 31.13 #> 49 38.89 31.47 #> 50 25.00 27.26 #> 51 26.03 28.29 #> 52 30.43 30.18 #> 53 19.75 25.28 #> 54 50.00 31.61 #> 55 21.62 27.67 #> 56 22.22 27.88 #> 57 36.36 30.71 #> 58 31.25 30.22 #> 59  0.00 29.73 #> 60 29.41 29.95 #> 61 31.16 30.71 #> 62 33.33 30.58 #> 63 33.87 32.22 #> 64 30.00 30.04 #> 65 30.34 30.19 #> 66 40.74 35.00 #> 67 46.43 38.96 #> 68 34.21 31.91 #> 69 24.26 26.10 #> 70 29.41 29.75 #> 71 47.17 39.13"},{"path":"https://r-spatial.github.io/spdep/reference/EBlocal.html","id":null,"dir":"Reference","previous_headings":"","what":"Local Empirical Bayes estimator — EBlocal","title":"Local Empirical Bayes estimator — EBlocal","text":"function computes local empirical Bayes estimates rates \"shrunk\" neighbourhood mean neighbourhoods given nb neighbourhood list.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBlocal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Local Empirical Bayes estimator — EBlocal","text":"","code":"EBlocal(ri, ni, nb, zero.policy = NULL, spChk = NULL, geoda=FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/EBlocal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Local Empirical Bayes estimator — EBlocal","text":"ri numeric vector counts cases length neighbours list nb; many zero counts, estimates may affected division zero, see https://stat.ethz.ch/pipermail/r-sig-geo/2022-January/028882.html ni numeric vector populations risk length neighbours list nb nb nb object neighbour relationships zero.policy default NULL, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() geoda default=FALSE, following Marshall's algorithm interpreted Bailey Gatrell, pp. 305-307, exercise 8.2, pp. 328-330 definition phi; TRUE definition phi used GeoDa (see discussion OpenSpace mailing list June 2003: http://agec221.agecon.uiuc.edu/pipermail/openspace/2003-June/thread.html)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBlocal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Local Empirical Bayes estimator — EBlocal","text":"Details implementation found Marshall, p. 286, Bailey Gatrell p. 307 exercise 8.2, pp. 328–330. example results fully correspond sources slightly differing neighbourhoods, generally close. many zero counts, estimates may affected division zero, see https://stat.ethz.ch/pipermail/r-sig-geo/2022-January/028882.html.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBlocal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Local Empirical Bayes estimator — EBlocal","text":"data frame two columns: raw numerical vector raw (crude) rates est numerical vector local empirical Bayes estimates parameters attribute list components (zero, estimate NaN, https://stat.ethz.ch/pipermail/r-sig-geo/2022-January/028882.html):  numerical vector local phi values m numerical vector local gamma values","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBlocal.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Local Empirical Bayes estimator — EBlocal","text":"Marshall R M (1991) Mapping disease mortality rates using Empirical Bayes Estimators, Applied Statistics, 40, 283–294; Bailey T, Gatrell (1995) Interactive Spatial Data Analysis, Harlow: Longman, pp. 303–306.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/EBlocal.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Local Empirical Bayes estimator — EBlocal","text":"Roger Bivand Roger.Bivand@nhh., based contributions Marilia Carvalho","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/EBlocal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Local Empirical Bayes estimator — EBlocal","text":"","code":"auckland <- st_read(system.file(\"shapes/auckland.gpkg\", package=\"spData\")[1], quiet=TRUE) auckland.nb <- poly2nb(auckland) res <- EBlocal(auckland$M77_85,  9*auckland$Und5_81, auckland.nb) auckland$est000 <- res$est*1000 plot(auckland[,\"est000\"], breaks=c(0,2,2.5,3,3.5,8),  main=\"Infant mortality per 1000 per year\")"},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.cs.html","id":null,"dir":"Reference","previous_headings":"","what":"Chi-square based test for local spatial heteroscedasticity — LOSH.cs","title":"Chi-square based test for local spatial heteroscedasticity — LOSH.cs","text":"function implements chi-square based test statistic local spatial heteroscedasticity (LOSH) proposed Ord & Getis (2012).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.cs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chi-square based test for local spatial heteroscedasticity — LOSH.cs","text":"","code":"LOSH.cs(x, listw, zero.policy = attr(listw, \"zero.policy\"), na.action = na.fail,                   p.adjust.method = \"none\", spChk = NULL)"},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.cs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chi-square based test for local spatial heteroscedasticity — LOSH.cs","text":"x numeric vector length neighbours list listw listw listw object created example nb2listw zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA na.action function (default na.fail), can also na.omit na.exclude - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. na.pass used, zero substituted NA values calculating spatial lag. (Note na.exclude work properly starting R 1.9.0, na.omit na.exclude assign wrong classes 1.8.*) p.adjust.method character string specifying probability value adjustment multiple tests, default \"none\"; see p.adjustSP. Note number multiple tests region taken number neighbours + 1 region, rather total number regions. spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption()","code":""},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.cs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chi-square based test for local spatial heteroscedasticity — LOSH.cs","text":"test uses = 2 (see LOSH) chi-square based inference applicable exponents. function makes use LOSH calculations.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.cs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chi-square based test for local spatial heteroscedasticity — LOSH.cs","text":"Hi LOSH statistic E.Hi expectation LOSH Var.Hi variance LOSH Z.Hi approximately chi-square distributed test statistics x_bar_i local spatially weighted mean values ei residuals local spatially weighted mean values Pr() p-values Hi obtained non-central Chi-square distribution \\(2/Var.Hi\\) degrees freedom","code":""},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.cs.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Chi-square based test for local spatial heteroscedasticity — LOSH.cs","text":"Ord, J. K., & Getis, . 2012. Local spatial heteroscedasticity (LOSH), Annals Regional Science, 48 (2), 529–539.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.cs.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Chi-square based test for local spatial heteroscedasticity — LOSH.cs","text":"René Westerholt rene.westerholt@tu-dortmund.de","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.cs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chi-square based test for local spatial heteroscedasticity — LOSH.cs","text":"","code":"data(boston, package=\"spData\")     resLOSH <- LOSH.cs(boston.c$NOX, nb2listw(boston.soi))     hist(resLOSH[,\"Hi\"])      mean(resLOSH[,\"Hi\"]) #> [1] 0.9919329"},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.html","id":null,"dir":"Reference","previous_headings":"","what":"Local spatial heteroscedasticity — LOSH","title":"Local spatial heteroscedasticity — LOSH","text":"Local spatial heteroscedasticity calculated location based spatial weights object used. statistic :     $$H_i = \\frac{\\sum_j^n w_{ij} \\cdot |e_j|^}{h_1 \\cdot \\sum_j^n w_{ij}}$$ $$e_j = x_j - \\bar{x}_j$$ $$\\bar{x}_j = \\frac{\\sum_k^n w_{jk} \\cdot x_k}{\\sum_k^n w_{jk}}$$     expectation variance given Ord & Getis (2012). exponent allows investigating different types mean dispersal.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Local spatial heteroscedasticity — LOSH","text":"","code":"LOSH(x, listw, a=2, var_hi=TRUE, zero.policy=attr(listw, \"zero.policy\"),  na.action=na.fail, spChk=NULL)"},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Local spatial heteroscedasticity — LOSH","text":"x numeric vector length neighbours list listw listw listw object created example nb2listw exponent applied local residuals; default value 2 leads measure heterogeneity spatial variance var_hi default TRUE, moments test statistics calculated location; FALSE, plain LOSH measures, \\(\\bar{x}_i\\) \\(e_i\\) calculated zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA na.action function (default na.fail), can also na.omit na.exclude - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. na.pass used, zero substituted NA values calculating spatial lag. (Note na.exclude work properly starting R 1.9.0, na.omit na.exclude assign wrong classes 1.8.*) spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption()","code":""},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Local spatial heteroscedasticity — LOSH","text":"addition LOSH measure, values returned include local spatially weighted mean values \\(\\bar{x}_i\\) local residuals \\(e_i\\) estimated means. values facilitate interpretation LOSH values. , specified var_hi, statistical moments test statistics proposed Ord & Getis (2012) also calculated returned.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Local spatial heteroscedasticity — LOSH","text":"Hi LOSH statistic E.Hi (optional) expectation LOSH Var.Hi (optional) variance LOSH Z.Hi (optional) approximately Chi-square distributed test statistics x_bar_i local spatially weighted mean values ei residuals local spatially weighted mean values","code":""},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Local spatial heteroscedasticity — LOSH","text":"Ord, J. K., & Getis, . 2012. Local spatial heteroscedasticity (LOSH),     Annals Regional Science, 48 (2), 529–539.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Local spatial heteroscedasticity — LOSH","text":"René Westerholt rene.westerholt@tu-dortmund.de","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Local spatial heteroscedasticity — LOSH","text":"","code":"data(boston, package=\"spData\")     resLOSH <- LOSH(boston.c$NOX, nb2listw(boston.soi))     hist(resLOSH[,\"Hi\"])      mean(resLOSH[,\"Hi\"]) #> [1] 0.9919329"},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.mc.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrapping-based test for local spatial heteroscedasticity — LOSH.mc","title":"Bootstrapping-based test for local spatial heteroscedasticity — LOSH.mc","text":"function draws inferences local spatial heteroscedasticity (LOSH) means randomisation-based Monte-Carlo bootstrap proposed Xu et al. (2014).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.mc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrapping-based test for local spatial heteroscedasticity — LOSH.mc","text":"","code":"LOSH.mc(x, listw, a = 2, nsim = 99, zero.policy = attr(listw, \"zero.policy\"),  na.action = na.fail, spChk = NULL, adjust.n = TRUE, p.adjust.method = \"none\")"},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.mc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrapping-based test for local spatial heteroscedasticity — LOSH.mc","text":"x numeric vector length neighbours list listw listw listw object created example nb2listw exponent applied local residuals; default value 2 leads measure heterogeneity spatial variance nsim number randomisations used bootstrap zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA na.action function (default na.fail), can also na.omit na.exclude - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. na.pass used, zero substituted NA values calculating spatial lag. (Note na.exclude work properly starting R 1.9.0, na.omit na.exclude assign wrong classes 1.8.*) spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() adjust.n default TRUE, FALSE number observations adjusted -neighbour observations, TRUE, number observations adjusted p.adjust.method character string specifying probability value adjustment multiple tests, default \"none\"; see p.adjustSP. Note number multiple tests region taken number neighbours + 1 region, rather total number regions.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.mc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bootstrapping-based test for local spatial heteroscedasticity — LOSH.mc","text":"test calculates LOSH (see LOSH) estimates pseudo p-values conditional bootstrap. Thereby, -th value location held fixed, whereas values permuted nsim times spatial units.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.mc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrapping-based test for local spatial heteroscedasticity — LOSH.mc","text":"Hi LOSH statistic E.Hi expectation LOSH Var.Hi variance LOSH Z.Hi approximately chi-square distributed test statistics x_bar_i local spatially weighted mean values ei residuals local spatially weighted mean values Pr() p-values Hi obtained conditional bootstrap distribution","code":""},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.mc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bootstrapping-based test for local spatial heteroscedasticity — LOSH.mc","text":"Ord, J. K., & Getis, . 2012. Local spatial heteroscedasticity (LOSH), Annals Regional Science, 48 (2), 529–539; Xu, M., Mei, C. L., & Yan, N. 2014. note null distribution local spatial heteroscedasticity (LOSH) statistic. Annals Regional Science, 52 (3), 697–710.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.mc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Bootstrapping-based test for local spatial heteroscedasticity — LOSH.mc","text":"René Westerholt rene.westerholt@tu-dortmund.de","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/LOSH.mc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bootstrapping-based test for local spatial heteroscedasticity — LOSH.mc","text":"","code":"data(columbus, package=\"spData\")     resLOSH_mc <- LOSH.mc(columbus$CRIME, nb2listw(col.gal.nb), 2, 100)     summary(resLOSH_mc) #>        Hi             x_bar_i            ei                 Pr()          #>  Min.   :0.03438   Min.   :13.85   Min.   :   0.0298   Min.   :0.009901   #>  1st Qu.:0.23838   1st Qu.:24.71   1st Qu.:   7.0114   1st Qu.:0.079208   #>  Median :0.66689   Median :35.90   Median :  52.1094   Median :0.653465   #>  Mean   :1.06592   Mean   :34.88   Mean   : 151.9232   Mean   :0.552233   #>  3rd Qu.:1.59680   3rd Qu.:45.39   3rd Qu.: 105.0551   3rd Qu.:0.900990   #>  Max.   :4.68765   Max.   :54.91   Max.   :2455.2201   Max.   :0.990099       resLOSH_cs <- LOSH.cs(columbus$CRIME, nb2listw(col.gal.nb))     summary(resLOSH_cs) #>        Hi               E.Hi       Var.Hi            Z.Hi         #>  Min.   :0.03438   Min.   :1   Min.   :0.4972   Min.   :0.04356   #>  1st Qu.:0.23838   1st Qu.:1   1st Qu.:0.9136   1st Qu.:0.35069   #>  Median :0.66689   Median :1   Median :1.4342   Median :1.19175   #>  Mean   :1.06592   Mean   :1   Mean   :1.4758   Mean   :1.89447   #>  3rd Qu.:1.59680   3rd Qu.:1   3rd Qu.:1.9547   3rd Qu.:2.65120   #>  Max.   :4.68765   Max.   :1   Max.   :2.9958   Max.   :7.25681   #>     x_bar_i            ei                 Pr()        #>  Min.   :13.85   Min.   :   0.0298   Min.   :0.0190   #>  1st Qu.:24.71   1st Qu.:   7.0114   1st Qu.:0.2050   #>  Median :35.90   Median :  52.1094   Median :0.5264   #>  Mean   :34.88   Mean   : 151.9232   Mean   :0.4507   #>  3rd Qu.:45.39   3rd Qu.: 105.0551   3rd Qu.:0.6529   #>  Max.   :54.91   Max.   :2455.2201   Max.   :0.9540       plot(resLOSH_mc[,\"Pr()\"], resLOSH_cs[,\"Pr()\"])"},{"path":"https://r-spatial.github.io/spdep/reference/SD.RStests.html","id":null,"dir":"Reference","previous_headings":"","what":"Rao's score and adjusted Rao's score tests of linear hypotheses for spatial Durbin and spatial Durbin error models — SD.RStests","title":"Rao's score and adjusted Rao's score tests of linear hypotheses for spatial Durbin and spatial Durbin error models — SD.RStests","text":"Rao's score adjusted Rao's score tests linear hypotheses applied fitted linear model examine whether either spatially lagged dependent variable lag spatially lagged independent variable(s) WX included model, (SDM). Adjusted tests provided lag WX adapting presence , joint test . joint test equal unadjusted one plus adjusted . addition, draft tests added Koley (2024, section 6) spatial Durbin error models examine whether either spatially lagged error err spatially lagged independent variable(s) WX included model, (SDEM); orthogonality, adjusted tests required.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/SD.RStests.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rao's score and adjusted Rao's score tests of linear hypotheses for spatial Durbin and spatial Durbin error models — SD.RStests","text":"","code":"SD.RStests(model, listw, zero.policy = attr(listw, \"zero.policy\"), test = \"SDM\",  Durbin = TRUE)"},{"path":"https://r-spatial.github.io/spdep/reference/SD.RStests.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rao's score and adjusted Rao's score tests of linear hypotheses for spatial Durbin and spatial Durbin error models — SD.RStests","text":"model object class lm returned lm listw listw object created example nb2listw, expected row-standardised (W-style) zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA test test=“SDM” computes SDM tests, character vector tests requested chosen SDM_RSlag, SDM_adjRSlag, SDM_RSWX, SDM_adjRSWX, SDM_Joint, test=“SDEM” computes SDEM tests, character vector tests requested chosen SDEM_RSerr, SDEM_RSWX, SDEM_Joint; test=“” computes tests Durbin default TRUE Durbin models including WX; TRUE, full spatial Durbin model; formula object, subset explanatory variables lag","code":""},{"path":"https://r-spatial.github.io/spdep/reference/SD.RStests.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rao's score and adjusted Rao's score tests of linear hypotheses for spatial Durbin and spatial Durbin error models — SD.RStests","text":"list class LMtestlist htest objects, : statistic value Lagrange Multiplier test. parameter number degrees freedom p.value p-value test. method character string giving method used. data.name character string giving name(s) data.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/SD.RStests.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Rao's score and adjusted Rao's score tests of linear hypotheses for spatial Durbin and spatial Durbin error models — SD.RStests","text":"Malabika Koley Anil K. Bera (2024) use, use spatial Durbin model? – question, Spatial Economic Analysis, 19:1, 30-56, doi:10.1080/17421772.2023.2256810 ; Malabika Koley (2024) Specification Testing General Nesting Spatial Model (Appendix C), https://sites.google.com/view/malabikakoley/research.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/SD.RStests.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Rao's score and adjusted Rao's score tests of linear hypotheses for spatial Durbin and spatial Durbin error models — SD.RStests","text":"Roger Bivand Roger.Bivand@nhh., Malabika Koley Anil K. Bera","code":""},{"path":"https://r-spatial.github.io/spdep/reference/SD.RStests.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Rao's score and adjusted Rao's score tests of linear hypotheses for spatial Durbin and spatial Durbin error models — SD.RStests","text":"results example agree Table 3, p. 22 Koley Bera (2024).","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/SD.RStests.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rao's score and adjusted Rao's score tests of linear hypotheses for spatial Durbin and spatial Durbin error models — SD.RStests","text":"","code":"columbus <- sf::st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1]) #> Reading layer `columbus' from data source  #>   `/home/rsb/lib/r_libs/spData/shapes/columbus.gpkg' using driver `GPKG' #> Simple feature collection with 49 features and 20 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 5.874907 ymin: 10.78863 xmax: 11.28742 ymax: 14.74245 #> Projected CRS: Undefined Cartesian SRS with unknown unit col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) col.listw <- nb2listw(col.gal.nb, style=\"W\") lm_obj <- lm(CRIME ~ INC + HOVAL, data=columbus) summary(lm.RStests(lm_obj, col.listw, test=\"all\")) #> \tRao's score (a.k.a Lagrange multiplier) diagnostics for spatial #> \tdependence #> data:   #> model: lm(formula = CRIME ~ INC + HOVAL, data = columbus) #> test weights: col.listw #>   #>          statistic parameter  p.value    #> RSerr     4.611126         1 0.031765 *  #> RSlag     7.855675         1 0.005066 ** #> adjRSerr  0.033514         1 0.854744    #> adjRSlag  3.278064         1 0.070212 .  #> SARMA     7.889190         2 0.019359 *  #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 res <- SD.RStests(lm_obj, col.listw, test=\"SDM\") summary(res) #> \tRao's score test spatial Durbin diagnostics #> data:   #> model: lm(formula = CRIME ~ INC + HOVAL, data = columbus) #> weights: col.listw #>   #>              statistic parameter  p.value    #> SDM_RSlag       7.8557         1 0.005066 ** #> SDM_adjRSlag    4.6111         1 0.031765 *  #> SDM_RSWX        6.1376         2 0.046477 *  #> SDM_adjRSWX     2.8931         2 0.235386    #> SDM_Joint      10.7487         3 0.013165 *  #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 all.equal(unname(res$SDM_Joint$statistic),  unname(res$SDM_RSlag$statistic + res$SDM_adjRSWX$statistic)) #> [1] TRUE all.equal(unname(res$SDM_Joint$statistic),  unname(res$SDM_adjRSlag$statistic + res$SDM_RSWX$statistic)) #> [1] TRUE res <- SD.RStests(lm_obj, col.listw, test=\"SDEM\") summary(res) #> \tRao's score test spatial Durbin diagnostics #> data:   #> model: lm(formula = CRIME ~ INC + HOVAL, data = columbus) #> weights: col.listw #>   #>            statistic parameter p.value   #> SDEM_RSerr    4.6111         1 0.03177 * #> SDEM_RSWX     6.1376         2 0.04648 * #> SDEM_Joint   10.7487         3 0.01317 * #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 all.equal(unname(res$SDEM_Joint$statistic),  unname(res$SDEM_RSerr$statistic + res$SDEM_RSWX$statistic)) #> [1] TRUE summary(SD.RStests(lm_obj, nb2listw(col.gal.nb, style=\"C\"), test=\"all\")) #> Warning: Spatial weights matrix not row standardized #> \tRao's score test spatial Durbin diagnostics #> data:   #> model: lm(formula = CRIME ~ INC + HOVAL, data = columbus) #> weights: nb2listw(col.gal.nb, style = \"C\") #>   #>              statistic parameter  p.value    #> SDM_RSlag      10.6095         1 0.001125 ** #> SDM_adjRSlag    4.8428         1 0.027762 *  #> SDM_RSWX        9.2305         3 0.026378 *  #> SDM_adjRSWX     3.4637         3 0.325498    #> SDM_Joint      14.0733         4 0.007065 ** #> SDEM_RSerr      4.8428         1 0.027762 *  #> SDEM_RSWX       9.2305         3 0.026378 *  #> SDEM_Joint     14.0733         4 0.007065 ** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 summary(SD.RStests(lm_obj, col.listw, test=\"all\", Durbin= ~ INC)) #> \tRao's score test spatial Durbin diagnostics #> data:   #> model: lm(formula = CRIME ~ INC + HOVAL, data = columbus) #> weights: col.listw #> Durbin: ~ INC #>   #>              statistic parameter  p.value    #> SDM_RSlag      7.85568         1 0.005066 ** #> SDM_adjRSlag   3.16076         1 0.075428 .  #> SDM_RSWX       4.92399         1 0.026486 *  #> SDM_adjRSWX    0.22908         1 0.632210    #> SDM_Joint      8.08475         2 0.017556 *  #> SDEM_RSerr     4.61113         1 0.031765 *  #> SDEM_RSWX      4.92399         1 0.026486 *  #> SDEM_Joint     9.53512         2 0.008501 ** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 lm_obj0 <- lm(I(scale(CRIME)) ~ 0 + I(scale(INC)) + I(scale(HOVAL)),  data=columbus) summary(SD.RStests(lm_obj0, col.listw, test=\"all\")) #> \tRao's score test spatial Durbin diagnostics #> data:   #> model: lm(formula = I(scale(CRIME)) ~ 0 + I(scale(INC)) + #> I(scale(HOVAL)), data = columbus) #> weights: col.listw #>   #>              statistic parameter  p.value    #> SDM_RSlag       7.8250         1 0.005153 ** #> SDM_adjRSlag    4.6111         1 0.031765 *  #> SDM_RSWX        6.0609         2 0.048295 *  #> SDM_adjRSWX     2.8470         2 0.240873    #> SDM_Joint      10.6720         3 0.013638 *  #> SDEM_RSerr      4.6111         1 0.031765 *  #> SDEM_RSWX       6.0609         2 0.048295 *  #> SDEM_Joint     10.6720         3 0.013638 *  #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 columbusNA <- columbus columbusNA$HOVAL[15] <- NA lm_objNA <- lm(CRIME ~ INC + HOVAL, data=columbusNA) summary(SD.RStests(lm_objNA, col.listw, test=\"all\")) #> \tRao's score test spatial Durbin diagnostics #> data:   #> model: lm(formula = CRIME ~ INC + HOVAL, data = columbusNA) #> weights: col.listw #>   #>              statistic parameter  p.value    #> SDM_RSlag       7.6010         1 0.005834 ** #> SDM_adjRSlag    4.4716         1 0.034463 *  #> SDM_RSWX        6.0812         2 0.047807 *  #> SDM_adjRSWX     2.9518         2 0.228576    #> SDM_Joint      10.5527         3 0.014407 *  #> SDEM_RSerr      4.4716         1 0.034463 *  #> SDEM_RSWX       6.0812         2 0.047807 *  #> SDEM_Joint     10.5527         3 0.014407 *  #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1"},{"path":"https://r-spatial.github.io/spdep/reference/aggregate.nb.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate a spatial neighbours object — aggregate.nb","title":"Aggregate a spatial neighbours object — aggregate.nb","text":"method aggregates spatial neighbours object, creating new object listing neighbours aggregates.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/aggregate.nb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate a spatial neighbours object — aggregate.nb","text":"","code":"# S3 method for class 'nb' aggregate(x, IDs, remove.self = TRUE, ...)"},{"path":"https://r-spatial.github.io/spdep/reference/aggregate.nb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate a spatial neighbours object — aggregate.nb","text":"x nb neighbour object IDs character vector IDs grouping members neighbour object remove.self default TRUE: remove self-neighbours resulting aggregation ... unused - arguments passed ","code":""},{"path":"https://r-spatial.github.io/spdep/reference/aggregate.nb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregate a spatial neighbours object — aggregate.nb","text":"nb neighbour object, empty aggregates dropped.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/aggregate.nb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Aggregate a spatial neighbours object — aggregate.nb","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/aggregate.nb.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Aggregate a spatial neighbours object — aggregate.nb","text":"Method suggested Roberto Patuelli","code":""},{"path":"https://r-spatial.github.io/spdep/reference/aggregate.nb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aggregate a spatial neighbours object — aggregate.nb","text":"","code":"data(used.cars, package=\"spData\") data(state) cont_st <- match(attr(usa48.nb, \"region.id\"), state.abb) cents <- as.matrix(as.data.frame(state.center))[cont_st,] opar <- par(mfrow=c(2,1)) plot(usa48.nb, cents, xlim=c(-125, -65), ylim=c(25, 50)) IDs <- as.character(state.division[cont_st]) agg_cents <- aggregate(cents, list(IDs), mean) agg_nb <- aggregate(usa48.nb, IDs) plot(agg_nb, agg_cents[, 2:3], xlim=c(-125, -65), ylim=c(25, 50)) text(agg_cents[, 2:3], agg_cents[, 1], cex=0.6)  par(opar)"},{"path":"https://r-spatial.github.io/spdep/reference/airdist.html","id":null,"dir":"Reference","previous_headings":"","what":"Measure distance from plot — airdist","title":"Measure distance from plot — airdist","text":"Measure distance two points plot using locator; function checks par(\"plt\") par(\"usr\") try ensure aspect ratio y/x 1, units measurement x y equivalent.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/airdist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Measure distance from plot — airdist","text":"","code":"airdist(ann=FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/airdist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Measure distance from plot — airdist","text":"ann annotate plot line measured distance","code":""},{"path":"https://r-spatial.github.io/spdep/reference/airdist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Measure distance from plot — airdist","text":"list members: dist distance measured coords coordinates distance measured","code":""},{"path":"https://r-spatial.github.io/spdep/reference/airdist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Measure distance from plot — airdist","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/autocov_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Distance-weighted autocovariate — autocov_dist","title":"Distance-weighted autocovariate — autocov_dist","text":"Calculates autocovariate used autonormal, autopoisson autologistic regression. Three distance-weighting schemes available.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/autocov_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distance-weighted autocovariate — autocov_dist","text":"","code":"autocov_dist(z, xy, nbs = 1, type = \"inverse\", zero.policy = NULL,  style = \"B\", longlat=NULL)"},{"path":"https://r-spatial.github.io/spdep/reference/autocov_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distance-weighted autocovariate — autocov_dist","text":"z response variable xy matrix coordinates SpatialPoints, sf sfc points object nbs neighbourhood radius; default 1 type weighting scheme: \"one\" gives equal weight data points neighbourhood; \"inverse\" (default) weights inverse distance; \"inverse.squared\" weights square \"inverse\" zero.policy default NULL, use global option value; FALSE stop error empty neighbour sets, TRUE permit weights list formed zero-length weights vectors style default “B” (changed “W” 2015-01-27); style can take values “W”, “B”, “C”, “U”, “S” longlat TRUE point coordinates longitude-latitude decimal, case distances measured kilometers; xy SpatialPoints object, value taken object ","code":""},{"path":"https://r-spatial.github.io/spdep/reference/autocov_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distance-weighted autocovariate — autocov_dist","text":"numeric vector autocovariate values","code":""},{"path":"https://r-spatial.github.io/spdep/reference/autocov_dist.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Distance-weighted autocovariate — autocov_dist","text":"validity approach strongly hinges correct choice neighbourhood scheme! Using style=\"B\" ensures symmetry neighbourhood matrix (.e. \\(w_{nm} = w_{mn}\\)). Please see Bardos et al. (2015) details.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/autocov_dist.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Distance-weighted autocovariate — autocov_dist","text":"Augustin N.H., Mugglestone M.. Buckland S.T. (1996) autologistic model spatial distribution wildlife. Journal Applied Ecology, 33, 339-347; Gumpertz M.L., Graham J.M. Ristaino J.B. (1997) Autologistic model spatial pattern Phytophthora epidemic bell pepper: effects soil variables disease presence. Journal Agricultural, Biological Environmental Statistics, 2, 131-156; Bardos, D.C., Guillera-Arroita, G. Wintle, B.. (2015) Valid auto-models spatially autocorrelated occupancy abundance data. arXiv, 1501.06529.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/autocov_dist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Distance-weighted autocovariate — autocov_dist","text":"Carsten F. Dormann Roger Bivand","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/autocov_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distance-weighted autocovariate — autocov_dist","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) #xy <- cbind(columbus$X, columbus$Y) xy <- st_coordinates(st_centroid(st_geometry(columbus),  of_largest_polygon=TRUE)) ac1a <- autocov_dist(columbus$CRIME, xy, nbs=10, style=\"B\",  type=\"one\") acinva <- autocov_dist(columbus$CRIME, xy, nbs=10, style=\"B\",  type=\"inverse\") acinv2a <- autocov_dist(columbus$CRIME, xy, nbs=10, style=\"B\",  type=\"inverse.squared\") plot(ac1a ~ columbus$CRIME, pch=16, ylim=c(0,9000)) points(acinva ~ columbus$CRIME, pch=16, col=\"red\") points(acinv2a ~ columbus$CRIME, pch=16, col=\"blue\") legend(\"topleft\", legend=c(\"one\", \"inverse\", \"inverse.squared\"),  col=c(\"black\", \"red\", \"blue\"), bty=\"n\", pch=16)  nb <- dnearneigh(xy, 0, 10) lw <- nb2listw(nb, style=\"B\") ac1b <- lag(lw, columbus$CRIME) all.equal(ac1b, ac1a) #> [1] TRUE nbd <- nbdists(nb, xy) gl <- lapply(nbd, function(x) 1/x) lw <- nb2listw(nb, glist=gl, style=\"B\") acinvb <- lag(lw, columbus$CRIME) all.equal(acinvb, acinva) #> [1] TRUE gl2 <- lapply(nbd, function(x) 1/(x^2)) lw <- nb2listw(nb, glist=gl2, style=\"B\") acinv2b <- lag(lw, columbus$CRIME) all.equal(acinv2b, acinv2a) #> [1] TRUE #xy <- SpatialPoints(xy) #acinva <- autocov_dist(columbus$CRIME, xy, nbs=10, style=\"W\", # type=\"inverse\") #nb <- dnearneigh(xy, 0, 10) #nbd <- nbdists(nb, xy) #gl <- lapply(nbd, function(x) 1/x) #lw <- nb2listw(nb, glist=gl) #acinvb <- lag(lw, columbus$CRIME) #all.equal(acinvb, acinva) acinvc <- autocov_dist(columbus$CRIME, st_centroid(st_geometry(columbus),  of_largest_polygon=TRUE), nbs=10, style=\"W\", type=\"inverse\") all.equal(acinvc, acinva) #> [1] \"Mean relative difference: 40.63575\""},{"path":"https://r-spatial.github.io/spdep/reference/bhicv.html","id":null,"dir":"Reference","previous_headings":"","what":"Data set with 4 life condition indices of Belo Horizonte region — bhicv","title":"Data set with 4 life condition indices of Belo Horizonte region — bhicv","text":"data collected inthe  Atlas condition indices published   Joao Pinheiro Foundation UNDP.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/bhicv.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data set with 4 life condition indices of Belo Horizonte region — bhicv","text":"shape polygon object seven variables: id identificator Name Name city Population population city HLCI Health Life Condition Index ELCI Education Life Condition Index CLCI Children Life Condition Index ELCI Economic Life Condition Index","code":""},{"path":"https://r-spatial.github.io/spdep/reference/bhicv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data set with 4 life condition indices of Belo Horizonte region — bhicv","text":"","code":"(GDAL37 <- as.numeric_version(unname(sf_extSoftVersion()[\"GDAL\"])) >= \"3.7.0\") #> [1] TRUE file <- \"etc/shapes/bhicv.gpkg.zip\" zipfile <- system.file(file, package=\"spdep\") if (GDAL37) {     bh <- st_read(zipfile) } else {     td <- tempdir()     bn <- sub(\".zip\", \"\", basename(file), fixed=TRUE)     target <- unzip(zipfile, files=bn, exdir=td)     bh <- st_read(target) } #> Reading layer `bhicv' from data source  #>   `/tmp/RtmpqhccSk/temp_libpath108a2257736002/spdep/etc/shapes/bhicv.gpkg.zip'  #>   using driver `GPKG' #> Simple feature collection with 98 features and 8 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -45.02175 ymin: -20.93007 xmax: -42.50321 ymax: -18.08342 #> Geodetic CRS:  Corrego Alegre 1970-72"},{"path":"https://r-spatial.github.io/spdep/reference/card.html","id":null,"dir":"Reference","previous_headings":"","what":"Cardinalities for neighbours lists — card","title":"Cardinalities for neighbours lists — card","text":"function tallies numbers neighbours regions neighbours list.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/card.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cardinalities for neighbours lists — card","text":"","code":"card(nb)"},{"path":"https://r-spatial.github.io/spdep/reference/card.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cardinalities for neighbours lists — card","text":"nb neighbours list object class nb","code":""},{"path":"https://r-spatial.github.io/spdep/reference/card.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cardinalities for neighbours lists — card","text":"integer vector numbers neighbours regions neighbours list.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/card.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cardinalities for neighbours lists — card","text":"“nb” objects stored lists integer vectors, vectors contain either indices range 1:n n length(nb) neighbours region , .integer(0) signal neighbours. function card(nb) used extract numbers neighbours “nb” object.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/card.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Cardinalities for neighbours lists — card","text":"Bivand R, Pebesma EJ, Gomez-Rubio V, (2008) Applied Spatial Data Analysis R, Springer, New York, pp. 239-251; Bivand R, Portnov B, (2004) Exploring spatial data analysis techniques using R: case observations neighbours. : Anselin L, Florax R, Rey S, (eds.), Advances Spatial Econometrics, Methodology, Tools Applications. Berlin: Springer-Verlag, pp. 121-142, doi:10.1007/978-3-662-05617-2_6 .","code":""},{"path":"https://r-spatial.github.io/spdep/reference/card.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cardinalities for neighbours lists — card","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/card.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cardinalities for neighbours lists — card","text":"","code":"col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) table(card(col.gal.nb)) #>  #>  2  3  4  5  6  7  8  9 10  #>  7  7 13  4  9  6  1  1  1"},{"path":"https://r-spatial.github.io/spdep/reference/cell2nb.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate neighbours list for grid cells — cell2nb","title":"Generate neighbours list for grid cells — cell2nb","text":"function generates list neighbours grid cells. Helper functions used convert vector indices row column grid positions, rook (shared edge) queen (shared edge vertex) neighbour definitions applied type. torus TRUE, grid mapped onto torus, removing edge effects.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/cell2nb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate neighbours list for grid cells — cell2nb","text":"","code":"cell2nb(nrow, ncol, type=\"rook\", torus=FALSE, legacy=FALSE, x=NULL) vi2mrc(i, nrow, ncol)"},{"path":"https://r-spatial.github.io/spdep/reference/cell2nb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate neighbours list for grid cells — cell2nb","text":"nrow number rows grid, may also object inheriting class \"SpatialGrid\" \"GridTopology\" cell2nb ncol number columns grid; nrow x object inheriting class \"SpatialGrid\" \"GridTopology\", may omitted type default rook, may also queen torus default FALSE, TRUE map grid onto torus legacy default FALSE, nrow/ncol reversed, TRUE wrong col/row directions (see https://github.com/r-spatial/spdep/issues/20) x given, object inheriting class \"SpatialGrid\" \"GridTopology\", replaces nrow ncol vector vector indices corresponding rowcol, matrix two columns row, column indices","code":""},{"path":"https://r-spatial.github.io/spdep/reference/cell2nb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate neighbours list for grid cells — cell2nb","text":"function returns object class nb list integer vectors containing neighbour region number ids. See card details “nb” objects.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/cell2nb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate neighbours list for grid cells — cell2nb","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/cell2nb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate neighbours list for grid cells — cell2nb","text":"","code":"nb7rt <- cell2nb(7, 7) summary(nb7rt) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 168  #> Percentage nonzero weights: 6.997085  #> Average number of links: 3.428571  #> Link number distribution: #>  #>  2  3  4  #>  4 20 25  #> 4 least connected regions: #> 1:1 7:1 1:7 7:7 with 2 links #> 25 most connected regions: #> 2:2 3:2 4:2 5:2 6:2 2:3 3:3 4:3 5:3 6:3 2:4 3:4 4:4 5:4 6:4 2:5 3:5 4:5 5:5 6:5 2:6 3:6 4:6 5:6 6:6 with 4 links xyc <- attr(nb7rt, \"region.id\") xy <- matrix(as.integer(unlist(strsplit(xyc, \":\"))), ncol=2, byrow=TRUE) plot(nb7rt, xy)  nb7rt <- cell2nb(7, 7, torus=TRUE) summary(nb7rt) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 196  #> Percentage nonzero weights: 8.163265  #> Average number of links: 4  #> Link number distribution: #>  #>  4  #> 49  #> 49 least connected regions: #> 1:1 2:1 3:1 4:1 5:1 6:1 7:1 1:2 2:2 3:2 4:2 5:2 6:2 7:2 1:3 2:3 3:3 4:3 5:3 6:3 7:3 1:4 2:4 3:4 4:4 5:4 6:4 7:4 1:5 2:5 3:5 4:5 5:5 6:5 7:5 1:6 2:6 3:6 4:6 5:6 6:6 7:6 1:7 2:7 3:7 4:7 5:7 6:7 7:7 with 4 links #> 49 most connected regions: #> 1:1 2:1 3:1 4:1 5:1 6:1 7:1 1:2 2:2 3:2 4:2 5:2 6:2 7:2 1:3 2:3 3:3 4:3 5:3 6:3 7:3 1:4 2:4 3:4 4:4 5:4 6:4 7:4 1:5 2:5 3:5 4:5 5:5 6:5 7:5 1:6 2:6 3:6 4:6 5:6 6:6 7:6 1:7 2:7 3:7 4:7 5:7 6:7 7:7 with 4 links run <- FALSE if (require(\"sp\", quietly=TRUE)) run <- TRUE if (run) { # https://github.com/r-spatial/spdep/issues/20 GT <- GridTopology(c(1, 1), c(1, 1), c(10, 50)) SPix <- as(SpatialGrid(GT), \"SpatialPixels\") nb_rook_cont <- poly2nb(as(SPix, \"SpatialPolygons\"), queen=FALSE) nb_rook_dist <- dnearneigh(coordinates(SPix), 0, 1.01) all.equal(nb_rook_cont, nb_rook_dist, check.attributes=FALSE) ## [1] TRUE } #> [1] TRUE if (run) { t.nb <- cell2nb(GT, type='rook', legacy=TRUE) isTRUE(all.equal(nb_rook_cont, t.nb, check.attributes=FALSE)) ## [1] FALSE } #> [1] FALSE if (run) { t.nb <- cell2nb(GT, type='rook') isTRUE(all.equal(nb_rook_cont, t.nb, check.attributes=FALSE)) ## [1] TRUE } #> [1] TRUE if (run) { # https://github.com/r-spatial/spdep/issues/55 # problem reported in issue caused by rep() cycling in unexpected order GT <- GridTopology(c(1, 1), c(1, 1), c(22, 11)) SPix <- as(SpatialGrid(GT), \"SpatialPixels\") nb_rook_cont <- poly2nb(as(SPix, \"SpatialPolygons\"), queen=FALSE) nb_rook_dist <- dnearneigh(coordinates(SPix), 0, 1.01) all.equal(nb_rook_cont, nb_rook_dist, check.attributes=FALSE) } #> [1] TRUE if (run) { t.nb <- cell2nb(GT, type='rook', legacy=TRUE) isTRUE(all.equal(nb_rook_cont, t.nb, check.attributes=FALSE)) ## [1] FALSE } #> [1] FALSE if (run) { t.nb <- cell2nb(GT, type='rook', legacy=FALSE) isTRUE(all.equal(nb_rook_cont, t.nb, check.attributes=FALSE)) ## [1] TRUE } #> [1] TRUE"},{"path":"https://r-spatial.github.io/spdep/reference/choynowski.html","id":null,"dir":"Reference","previous_headings":"","what":"Choynowski probability map values — choynowski","title":"Choynowski probability map values — choynowski","text":"Calculates Choynowski probability map values.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/choynowski.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Choynowski probability map values — choynowski","text":"","code":"choynowski(n, x, row.names=NULL, tol = .Machine$double.eps^0.5, legacy=FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/choynowski.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Choynowski probability map values — choynowski","text":"n numeric vector counts cases x numeric vector populations risk row.names row names passed output data frame tol accumulate values observed counts >= expected value less tol legacy default FALSE using vectorised alternating side ppois version, true use original version written sources iterating tol","code":""},{"path":"https://r-spatial.github.io/spdep/reference/choynowski.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Choynowski probability map values — choynowski","text":"data frame columns: pmap Poisson probability map values: probablility getting “extreme” count actually observed, one-tailed less expected expected folded together type logical: TRUE observed count less expected","code":""},{"path":"https://r-spatial.github.io/spdep/reference/choynowski.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Choynowski probability map values — choynowski","text":"Choynowski, M (1959) Maps based probabilities, Journal American Statistical Association, 54, 385–388; Cressie, N, Read, TRC (1985), sudden infant deaths come clusters? Statistics Decisions, Supplement Issue 2, 333–349; Bailey T, Gatrell (1995) Interactive Spatial Data Analysis, Harlow: Longman, pp. 300–303.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/choynowski.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Choynowski probability map values — choynowski","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/choynowski.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Choynowski probability map values — choynowski","text":"","code":"auckland <- st_read(system.file(\"shapes/auckland.gpkg\", package=\"spData\")[1], quiet=TRUE) auckland.nb <- poly2nb(auckland) res <- choynowski(auckland$M77_85, 9*auckland$Und5_81) resl <- choynowski(auckland$M77_85, 9*auckland$Und5_81, legacy=TRUE) all.equal(res, resl) #> [1] TRUE rt <- sum(auckland$M77_85)/sum(9*auckland$Und5_81) ch_ppois_pmap <- numeric(length(auckland$Und5_81)) side <- c(\"greater\", \"less\") for (i in seq(along=ch_ppois_pmap)) {   ch_ppois_pmap[i] <- poisson.test(auckland$M77_85[i], r=rt,     T=(9*auckland$Und5_81[i]), alternative=side[(res$type[i]+1)])$p.value } all.equal(ch_ppois_pmap, res$pmap) #> [1] TRUE res1 <- probmap(auckland$M77_85, 9*auckland$Und5_81) table(abs(res$pmap - res1$pmap) < 0.00001, res$type) #>         #>         FALSE TRUE #>   FALSE    74    0 #>   TRUE      0   93 lt005 <- (res$pmap < 0.05) & (res$type) ge005 <- (res$pmap < 0.05) & (!res$type) cols <- rep(\"nonsig\", length(lt005)) cols[lt005] <- \"low\" cols[ge005] <- \"high\" auckland$cols <- factor(cols) plot(auckland[,\"cols\"], main=\"Probability map\")"},{"path":"https://r-spatial.github.io/spdep/reference/columbus.html","id":null,"dir":"Reference","previous_headings":"","what":"Columbus OH spatial analysis data set — columbus","title":"Columbus OH spatial analysis data set — columbus","text":"data set now part spData package","code":""},{"path":"https://r-spatial.github.io/spdep/reference/columbus.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Columbus OH spatial analysis data set — columbus","text":"","code":"data(columbus)"},{"path":"https://r-spatial.github.io/spdep/reference/columbus.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Columbus OH spatial analysis data set — columbus","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1])"},{"path":"https://r-spatial.github.io/spdep/reference/compon.html","id":null,"dir":"Reference","previous_headings":"","what":"Depth First Search on Neighbor Lists — Graph Components","title":"Depth First Search on Neighbor Lists — Graph Components","text":"n.comp.nb() finds number disjoint connected subgraphs graph depicted nb.obj - spatial neighbours list object.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/compon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Depth First Search on Neighbor Lists — Graph Components","text":"","code":"n.comp.nb(nb.obj)"},{"path":"https://r-spatial.github.io/spdep/reference/compon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Depth First Search on Neighbor Lists — Graph Components","text":"nb.obj neighbours list object class nb","code":""},{"path":"https://r-spatial.github.io/spdep/reference/compon.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Depth First Search on Neighbor Lists — Graph Components","text":"attr(nb.obj, \"sym\") FALSE igraph::components available, components directed graph found simple breadth-first search; igraph::components available, object made symmetric (may time-consuming large numbers neighbours) components found depth-first search. attr(nb.obj, \"sym\") TRUE, components directed graph found depth-first search. time complexity algorithms used native code igraph::components linear sum number nodes number edges graph, see https://github.com/r-spatial/spdep/issues/160 details; dense neighbour objects large numbers edges.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/compon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Depth First Search on Neighbor Lists — Graph Components","text":"list : nc number disjoint connected subgraphs comp.id vector indices disjoint connected subgraphs  nodes nb.obj belong ","code":""},{"path":"https://r-spatial.github.io/spdep/reference/compon.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Depth First Search on Neighbor Lists — Graph Components","text":"Nicholas Lewin-Koh nikko@hailmail.net","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/compon.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Depth First Search on Neighbor Lists — Graph Components","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) coords <- st_coordinates(st_centroid(st_geometry(columbus))) plot(col.gal.nb, coords, col=\"grey\") col2 <- droplinks(col.gal.nb, 21) #> Warning: some observations have no neighbours #> Warning: neighbour object has 3 sub-graphs res <- n.comp.nb(col2) table(res$comp.id) #>  #>  1  2  3  #> 42  1  6  plot(col2, coords, add=TRUE) points(coords, col=res$comp.id, pch=16)  run <- FALSE if (require(\"igraph\", quietly=TRUE) && require(\"spatialreg\", quietly=TRUE)) run <- TRUE #>  #> Attaching package: ‘igraph’ #> The following objects are masked from ‘package:stats’: #>  #>     decompose, spectrum #> The following object is masked from ‘package:base’: #>  #>     union #>  #> Attaching package: ‘spatialreg’ #> The following objects are masked from ‘package:spdep’: #>  #>     get.ClusterOption, get.VerboseOption, get.ZeroPolicyOption, #>     get.coresOption, get.mcOption, set.ClusterOption, #>     set.VerboseOption, set.ZeroPolicyOption, set.coresOption, #>     set.mcOption if (run) { B <- as(nb2listw(col2, style=\"B\", zero.policy=TRUE), \"CsparseMatrix\") g1 <- graph_from_adjacency_matrix(B, mode=\"undirected\") c1 <- components(g1) print(c1$no == res$nc) } #> [1] TRUE if (run) { print(all.equal(c1$membership, res$comp.id)) } #> [1] \"names for target but not for current\" if (run) { print(all.equal(c1$csize, c(table(res$comp.id)), check.attributes=FALSE)) } #> [1] TRUE if (run) { W <- as(nb2listw(col2, style=\"W\", zero.policy=TRUE), \"CsparseMatrix\") g1W <- graph_from_adjacency_matrix(W, mode=\"directed\", weighted=\"W\") c1W <- components(g1W, mode=\"weak\") print(all.equal(c1W$membership, res$comp.id, check.attributes=FALSE)) } #> [1] TRUE # \\donttest{ if (run) { data(house, package=\"spData\") house <- sf::st_as_sf(house) k6 <- knn2nb(knearneigh(house, k=6)) is.symmetric.nb(k6) } #> [1] FALSE if (run) { print(k6) } #> Neighbour list object: #> Number of regions: 25357  #> Number of nonzero links: 152142  #> Percentage nonzero weights: 0.02366211  #> Average number of links: 6  #> Non-symmetric neighbours list if (run) { length(k6) + sum(card(k6)) } #> [1] 177499 if (run) { # no pre-computed graph components str(attr(k6, \"ncomp\")) } #>  NULL if (run) { # raising the subgraph compute ceiling to above |N|+|E| computes and stores the # object in the neighbour object set.SubgraphCeiling(180000L) k6 <- knn2nb(knearneigh(house, k=6)) str(attr(k6, \"ncomp\")) } #> Warning: neighbour object has 47 sub-graphs #> List of 2 #>  $ nc     : num 47 #>  $ comp.id: num [1:25357] 1 1 1 1 1 1 1 1 1 1 ... if (run) { print(k6) } #> Neighbour list object: #> Number of regions: 25357  #> Number of nonzero links: 152142  #> Percentage nonzero weights: 0.02366211  #> Average number of links: 6  #> 47 disjoint connected subgraphs #> Non-symmetric neighbours list if (run) { system.time(udir <- n.comp.nb(make.sym.nb(k6))) } #>    user  system elapsed  #>   2.034   0.000   2.041  if (run) { system.time(dir <- n.comp.nb(k6)) } #>    user  system elapsed  #>   0.680   0.002   0.684  if (run) { udir$nc } #> [1] 47 if (run) { dir$nc } #> [1] 47 if (run) { all.equal(dir, udir) } #> [1] TRUE # }"},{"path":"https://r-spatial.github.io/spdep/reference/diffnb.html","id":null,"dir":"Reference","previous_headings":"","what":"Differences between neighbours lists — diffnb","title":"Differences between neighbours lists — diffnb","text":"function finds differences lists neighbours, returning nb neighbour list found","code":""},{"path":"https://r-spatial.github.io/spdep/reference/diffnb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Differences between neighbours lists — diffnb","text":"","code":"diffnb(x, y, verbose=NULL)"},{"path":"https://r-spatial.github.io/spdep/reference/diffnb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Differences between neighbours lists — diffnb","text":"x object class nb y object class nb verbose default NULL, use global option value; report regions ids taken object attribute \"region.id\" differences","code":""},{"path":"https://r-spatial.github.io/spdep/reference/diffnb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Differences between neighbours lists — diffnb","text":"neighbours list class nb","code":""},{"path":"https://r-spatial.github.io/spdep/reference/diffnb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Differences between neighbours lists — diffnb","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/diffnb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Differences between neighbours lists — diffnb","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) coords <- st_centroid(st_geometry(columbus), of_largest_polygon=TRUE) rn <- row.names(columbus) knn1 <- knearneigh(coords, 1) knn2 <- knearneigh(coords, 2) nb1 <- knn2nb(knn1, row.names=rn) #> Warning: neighbour object has 13 sub-graphs nb2 <- knn2nb(knn2, row.names=rn) diffs <- diffnb(nb2, nb1) #> Warning: neighbour object has 10 sub-graphs opar <- par(no.readonly=TRUE) plot(st_geometry(columbus), border=\"grey\", reset=FALSE,  main=\"Plot of first (black) and second (red)\\nnearest neighbours\") plot(nb1, coords, add=TRUE) plot(diffs, coords, add=TRUE, col=\"red\", lty=2)  par(opar)"},{"path":"https://r-spatial.github.io/spdep/reference/dnearneigh.html","id":null,"dir":"Reference","previous_headings":"","what":"Neighbourhood contiguity by distance — dnearneigh","title":"Neighbourhood contiguity by distance — dnearneigh","text":"function identifies neighbours region points Euclidean distance metric points lower (greater equal (changed version 1.1-7)) upper (less equal ) bounds, longlat = TRUE, Great Circle distance kilometers. x \"sf\" object use_s2= TRUE, spherical distances km used.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/dnearneigh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Neighbourhood contiguity by distance — dnearneigh","text":"","code":"dnearneigh(x, d1, d2, row.names = NULL, longlat = NULL, bounds=c(\"GE\", \"LE\"),  use_kd_tree=TRUE, symtest=FALSE, use_s2=packageVersion(\"s2\") > \"1.0.7\", k=200,  dwithin=TRUE)"},{"path":"https://r-spatial.github.io/spdep/reference/dnearneigh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Neighbourhood contiguity by distance — dnearneigh","text":"x matrix point coordinates, object inheriting SpatialPoints \"sf\" \"sfc\" object; \"sf\" \"sfc\" object geometries geographical coordinates (use_s2=FALSE, sf::st_is_longlat(x) == TRUE sf::sf_use_s2() == TRUE), s2 used find neighbours (hope) use spatial indexing https://github.com/r-spatial/s2/issues/125 opposed legacy method uses brute-force (present s2 also uses brute-force) d1 lower distance bound metric points planar coordinates, km geographical coordinates d2 upper distance boundd metric points planar coordinates, km geographical coordinates row.names character vector region ids added neighbours list attribute region.id, default seq(1, nrow(x)) longlat TRUE point coordinates geographical longitude-latitude decimal degrees, case distances measured kilometers; x SpatialPoints object, value taken object , overrides argument NULL bounds character vector length 2, default c(\"GE\", \"LE\"), (GE: greater equal , LE: less equal ) finite closed interval [d1, d2], d1 <= x <= d2. first element may also \"GT\" (GT: greater ), second \"LT\" (LT: less ) finite, open intervals excluding bounds; first bound default changed \"GT\" \"GE\" release 1.1-7. creating multiple distance bands, finite, half-open right-closed intervals may used final interval avoid overlapping bounds: \"GE\", \"LT\", [d1, d2), d1 <= x < d2 use_kd_tree default TRUE, TRUE, use dbscan frNN available (permitting 3D distances). symtest Default FALSE; release 1.1-7, TRUE - run symmetry check output object, costly large numbers points. use_s2 default=packageVersion(\"s2\") > \"1.0.7\", s2 > 1.0-7, distance bound computations use spatial indexing sf::sf_use_s2() TRUE, s2::s2_dwithin_matrix() used distances sphere \"sf\" \"sfc\" objects s2 > 1.0-7. k default 200, number closest points consider searching using  s2::s2_closest_edges() dwithin default TRUE, FALSE, use s2::s2_closest_edges(), use_s2=TRUE, sf::st_is_longlat(x) == TRUE sf::sf_use_s2() == TRUE; s2::s2_dwithin_matrix() yields lists neighbours s2::s2_closest_edges() k= set correctly.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/dnearneigh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Neighbourhood contiguity by distance — dnearneigh","text":"function returns list integer vectors giving region id numbers neighbours satisfying distance criteria. See card details “nb” objects.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/dnearneigh.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Neighbourhood contiguity by distance — dnearneigh","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/dnearneigh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Neighbourhood contiguity by distance — dnearneigh","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) coords <- st_centroid(st_geometry(columbus), of_largest_polygon=TRUE) rn <- row.names(columbus) k1 <- knn2nb(knearneigh(coords)) #> Warning: neighbour object has 13 sub-graphs all.linked <- max(unlist(nbdists(k1, coords))) col.nb.0.all <- dnearneigh(coords, 0, all.linked, row.names=rn) #> Warning: neighbour object has 2 sub-graphs summary(col.nb.0.all, coords) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 252  #> Percentage nonzero weights: 10.49563  #> Average number of links: 5.142857  #> 2 disjoint connected subgraphs #> Link number distribution: #>  #>  1  2  3  4  5  6  7  8  9 10 11  #>  4  8  6  2  5  8  6  2  6  1  1  #> 4 least connected regions: #> 6 10 21 47 with 1 link #> 1 most connected region: #> 28 with 11 links opar <- par(no.readonly=TRUE) plot(st_geometry(columbus), border=\"grey\", reset=FALSE,  main=paste(\"Distance based neighbours 0-\",  format(all.linked), sep=\"\")) plot(col.nb.0.all, coords, add=TRUE)  par(opar) (sfc_obj <- st_centroid(st_geometry(columbus))) #> Geometry set for 49 features  #> Geometry type: POINT #> Dimension:     XY #> Bounding box:  xmin: 6.221943 ymin: 11.01003 xmax: 10.95359 ymax: 14.36908 #> Projected CRS: Undefined Cartesian SRS with unknown unit #> First 5 geometries: #> POINT (8.827218 14.36908) #> POINT (8.332658 14.03162) #> POINT (9.012265 13.81972) #> POINT (8.460801 13.71696) #> POINT (9.007982 13.29637) col.nb.0.all_sf <- dnearneigh(sfc_obj, 0, all.linked, row.names=rn) #> Warning: neighbour object has 2 sub-graphs all.equal(col.nb.0.all, col.nb.0.all_sf, check.attributes=FALSE) #> [1] TRUE data(state) us48.fipsno <- read.geoda(system.file(\"etc/weights/us48.txt\",  package=\"spdep\")[1]) if (as.numeric(paste(version$major, version$minor, sep=\"\")) < 19) {  m50.48 <- match(us48.fipsno$\"State.name\", state.name) } else {  m50.48 <- match(us48.fipsno$\"State_name\", state.name) } xy <- as.matrix(as.data.frame(state.center))[m50.48,] llk1 <- knn2nb(knearneigh(xy, k=1, longlat=FALSE)) #> Warning: neighbour object has 12 sub-graphs (all.linked <- max(unlist(nbdists(llk1, xy, longlat=FALSE)))) #> [1] 5.161223 ll.nb <- dnearneigh(xy, 0, all.linked, longlat=FALSE) #> Warning: neighbour object has 5 sub-graphs summary(ll.nb, xy, longlat=TRUE, scale=0.5) #> Neighbour list object: #> Number of regions: 48  #> Number of nonzero links: 190  #> Percentage nonzero weights: 8.246528  #> Average number of links: 3.958333  #> 5 disjoint connected subgraphs #> Link number distribution: #>  #>  1  2  3  4  5  7  8  9 10  #> 11  9  4  8  4  4  4  3  1  #> 11 least connected regions: #> 2 4 8 10 24 26 29 32 35 41 45 with 1 link #> 1 most connected region: #> 28 with 10 links gck1 <- knn2nb(knearneigh(xy, k=1, longlat=TRUE)) #> Warning: neighbour object has 11 sub-graphs (all.linked <- max(unlist(nbdists(gck1, xy, longlat=TRUE)))) #> [1] 523.5819 gc.nb <- dnearneigh(xy, 0, all.linked, longlat=TRUE) #> Warning: neighbour object has 2 sub-graphs summary(gc.nb, xy, longlat=TRUE, scale=0.5) #> Neighbour list object: #> Number of regions: 48  #> Number of nonzero links: 220  #> Percentage nonzero weights: 9.548611  #> Average number of links: 4.583333  #> 2 disjoint connected subgraphs #> Link number distribution: #>  #>  1  2  3  4  5  6  7  8  9 10  #>  5  9  6  8  5  2  3  3  5  2  #> 5 least connected regions: #> 2 4 8 41 45 with 1 link #> 2 most connected regions: #> 7 28 with 10 links plot(ll.nb, xy) plot(diffnb(ll.nb, gc.nb), xy, add=TRUE, col=\"red\", lty=2) #> Warning: neighbour object has 27 sub-graphs title(main=\"Differences Euclidean/Great Circle\")   #xy1 <- SpatialPoints((as.data.frame(state.center))[m50.48,], #  proj4string=CRS(\"+proj=longlat +ellps=GRS80\")) #gck1a <- knn2nb(knearneigh(xy1, k=1)) #(all.linked <- max(unlist(nbdists(gck1a, xy1)))) #gc.nb <- dnearneigh(xy1, 0, all.linked) #summary(gc.nb, xy1, scale=0.5)  xy1 <- st_as_sf((as.data.frame(state.center))[m50.48,], coords=1:2,   crs=st_crs(\"OGC:CRS84\")) old_use_s2 <- sf_use_s2() sf_use_s2(TRUE) gck1b <- knn2nb(knearneigh(xy1, k=1)) #> Warning: neighbour object has 11 sub-graphs system.time(o <- nbdists(gck1b, xy1)) #>    user  system elapsed  #>   0.006   0.000   0.007  (all.linked <- max(unlist(o))) #> [1] 522.4464 # use s2 brute-force dwithin_matrix approach for s2 <= 1.0.7 system.time(gc.nb.dwithin <- dnearneigh(xy1, 0, all.linked, use_s2=TRUE, dwithin=TRUE)) #> Warning: neighbour object has 3 sub-graphs #>    user  system elapsed  #>   0.012   0.000   0.013  summary(gc.nb, xy1, scale=0.5) #> Neighbour list object: #> Number of regions: 48  #> Number of nonzero links: 220  #> Percentage nonzero weights: 9.548611  #> Average number of links: 4.583333  #> 2 disjoint connected subgraphs #> Link number distribution: #>  #>  1  2  3  4  5  6  7  8  9 10  #>  5  9  6  8  5  2  3  3  5  2  #> 5 least connected regions: #> 2 4 8 41 45 with 1 link #> 2 most connected regions: #> 7 28 with 10 links # use s2 closest_edges approach s2 > 1.0.7 if (packageVersion(\"s2\") > \"1.0.7\") { (system.time(gc.nb.closest <- dnearneigh(xy1, 0, all.linked, dwithin=FALSE))) } #> Warning: neighbour object has 3 sub-graphs #>    user  system elapsed  #>    0.01    0.00    0.01  if (packageVersion(\"s2\") > \"1.0.7\") { system.time(gc.nb.dwithin <- dnearneigh(xy1, 0, all.linked, use_s2=TRUE, dwithin=TRUE)) } #> Warning: neighbour object has 3 sub-graphs #>    user  system elapsed  #>   0.012   0.000   0.012  if (packageVersion(\"s2\") > \"1.0.7\") { summary(gc.nb.dwithin, xy1, scale=0.5) } #> Neighbour list object: #> Number of regions: 48  #> Number of nonzero links: 218  #> Percentage nonzero weights: 9.461806  #> Average number of links: 4.541667  #> 1 region with no links: #> 2 #> 3 disjoint connected subgraphs #> Link number distribution: #>  #>  0  1  2  3  4  5  6  7  8  9 10  #>  1  5  8  6  8  5  2  3  3  5  2  #> 5 least connected regions: #> 4 8 29 41 45 with 1 link #> 2 most connected regions: #> 7 28 with 10 links if (packageVersion(\"s2\") > \"1.0.7\") { summary(gc.nb.closest, xy1, scale=0.5) } #> Neighbour list object: #> Number of regions: 48  #> Number of nonzero links: 218  #> Percentage nonzero weights: 9.461806  #> Average number of links: 4.541667  #> 1 region with no links: #> 2 #> 3 disjoint connected subgraphs #> Link number distribution: #>  #>  0  1  2  3  4  5  6  7  8  9 10  #>  1  5  8  6  8  5  2  3  3  5  2  #> 5 least connected regions: #> 4 8 29 41 45 with 1 link #> 2 most connected regions: #> 7 28 with 10 links # use legacy symmetric brute-force approach system.time(gc.nb.legacy <- dnearneigh(xy1, 0, all.linked, use_s2=FALSE)) #> Warning: neighbour object has 3 sub-graphs #>    user  system elapsed  #>   0.007   0.000   0.006  summary(gc.nb, xy1, scale=0.5) #> Neighbour list object: #> Number of regions: 48  #> Number of nonzero links: 220  #> Percentage nonzero weights: 9.548611  #> Average number of links: 4.583333  #> 2 disjoint connected subgraphs #> Link number distribution: #>  #>  1  2  3  4  5  6  7  8  9 10  #>  5  9  6  8  5  2  3  3  5  2  #> 5 least connected regions: #> 2 4 8 41 45 with 1 link #> 2 most connected regions: #> 7 28 with 10 links if (packageVersion(\"s2\") > \"1.0.7\") all.equal(gc.nb.closest, gc.nb.dwithin, check.attributes=FALSE) #> [1] TRUE # legacy is ellipsoidal, s2 spherical, so minor differences expected if (packageVersion(\"s2\") > \"1.0.7\") all.equal(gc.nb, gc.nb.closest, check.attributes=FALSE) #> [1] \"Component 2: Mean relative difference: 1\"     #> [2] \"Component 29: Numeric: lengths (2, 1) differ\" all.equal(gc.nb, gc.nb.dwithin, check.attributes=FALSE) #> [1] \"Component 2: Mean relative difference: 1\"     #> [2] \"Component 29: Numeric: lengths (2, 1) differ\" sf_use_s2(old_use_s2) # example of reading points with readr::read_csv() yielding a tibble load(system.file(\"etc/misc/coords.rda\", package=\"spdep\")) class(coords) #> [1] \"spec_tbl_df\" \"tbl_df\"      \"tbl\"         \"data.frame\"  k1 <- knn2nb(knearneigh(coords, k=1)) #> Warning: neighbour object has 29 sub-graphs all.linked <- max(unlist(nbdists(k1, coords))) dnearneigh(coords, 0, all.linked) #> Neighbour list object: #> Number of regions: 100  #> Number of nonzero links: 676  #> Percentage nonzero weights: 6.76  #> Average number of links: 6.76"},{"path":"https://r-spatial.github.io/spdep/reference/droplinks.html","id":null,"dir":"Reference","previous_headings":"","what":"Drop and add links in a neighbours list — droplinks","title":"Drop and add links in a neighbours list — droplinks","text":"droplinks drops links just region neighbours list. example corresponds Fingleton's Table 1, (1999) p. 6, lattices 5 19. addlinks1 adds links single region specified regions.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/droplinks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Drop and add links in a neighbours list — droplinks","text":"","code":"droplinks(nb, drop, sym=TRUE) addlinks1(nb, from, to, sym=TRUE)"},{"path":"https://r-spatial.github.io/spdep/reference/droplinks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Drop and add links in a neighbours list — droplinks","text":"nb neighbours list object class nb drop either logical vector length nb, character vector named regions corresponding nb's region.id attribute, integer vector region numbers sym TRUE removal \"row\" \"column\" links, FALSE \"row\" links; adding links, inserts links region regions single region adding links, either character vector length 1 named region corresponding nb's region.id attribute, integer vector length 1 holding region number regions, either character vector named regions corresponding nb's region.id attribute, integer vector region numbers","code":""},{"path":"https://r-spatial.github.io/spdep/reference/droplinks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Drop and add links in a neighbours list — droplinks","text":"function returns object class nb list integer vectors containing neighbour region number ids.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/droplinks.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Drop and add links in a neighbours list — droplinks","text":"B. Fingleton (1999) Spurious spatial regression: Monte Carlo results spatial unit root spatial cointegration, Journal Regional Science 39, pp. 1–19.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/droplinks.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Drop and add links in a neighbours list — droplinks","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/droplinks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Drop and add links in a neighbours list — droplinks","text":"","code":"# \\donttest{ rho <- c(0.2, 0.5, 0.95, 0.999, 1.0) ns <- c(5, 7, 9, 11, 13, 15, 17, 19) mns <- matrix(0, nrow=length(ns), ncol=length(rho)) rownames(mns) <- ns colnames(mns) <- rho mxs <- matrix(0, nrow=length(ns), ncol=length(rho)) rownames(mxs) <- ns colnames(mxs) <- rho for (i in 1:length(ns)) {   nblist <- cell2nb(ns[i], ns[i])   nbdropped <- droplinks(nblist, ((ns[i]*ns[i])+1)/2, sym=FALSE)   listw <- nb2listw(nbdropped, style=\"W\", zero.policy=TRUE)   wmat <- listw2mat(listw)   for (j in 1:length(rho)) {     mat <- diag(ns[i]*ns[i]) - rho[j] * wmat     res <- diag(solve(t(mat) %*% mat))     mns[i,j] <- mean(res)     mxs[i,j] <- max(res)   } } #> Warning: some observations have no neighbours #> Warning: some observations have no neighbours #> Warning: some observations have no neighbours #> Warning: some observations have no neighbours #> Warning: some observations have no neighbours #> Warning: some observations have no neighbours #> Warning: some observations have no neighbours #> Warning: some observations have no neighbours print(mns) #>         0.2      0.5      0.95     0.999          1 #> 5  1.038271 1.312627  9.486051  30.81487   32.04915 #> 7  1.036443 1.295621 10.899580  83.25437   92.09812 #> 9  1.035356 1.285145 10.798611 160.90951  195.02166 #> 11 1.034639 1.278279 10.383083 254.83998  347.71145 #> 13 1.034132 1.273442  9.968389 353.66366  555.88699 #> 15 1.033753 1.269852  9.619387 447.19245  824.46560 #> 17 1.033460 1.267082  9.337167 528.49015 1157.77630 #> 19 1.033227 1.264879  9.109487 594.23907 1559.69614 print(mxs) #>         0.2      0.5     0.95     0.999          1 #> 5  1.048834 1.401934 12.00215  39.22742   40.79967 #> 7  1.048834 1.402174 14.66823 106.90031  118.01556 #> 9  1.048834 1.402176 15.49606 207.28928  249.74893 #> 11 1.048834 1.402176 15.75744 329.22973  443.97194 #> 13 1.048834 1.402176 15.83957 458.75739  707.14827 #> 15 1.048834 1.402176 15.86474 583.50722 1044.75562 #> 17 1.048834 1.402176 15.87225 695.10288 1461.57017 #> 19 1.048834 1.402176 15.87445 789.50575 1961.84025  # }"},{"path":"https://r-spatial.github.io/spdep/reference/edit.nb.html","id":null,"dir":"Reference","previous_headings":"","what":"Interactive editing of neighbours lists — edit.nb","title":"Interactive editing of neighbours lists — edit.nb","text":"function provides simple interactive editing neighbours lists allow unneeded links deleted, missing links inserted. uses identify pick endpoints link deleted added, asks confirmation committing. result assigned new object, editing lost - edit. method relies direct contact graphics device. use RStudio.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/edit.nb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interactive editing of neighbours lists — edit.nb","text":"","code":"# S3 method for class 'nb' edit(name, coords, polys=NULL, ..., use_region.id=FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/edit.nb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interactive editing of neighbours lists — edit.nb","text":"name object class nb coords matrix region point coordinates; missing polys= inherits SpatialPolygons, label points object used polys polygon boundaries supplied, used background; must inherit SpatialPolygons ... arguments passed methods use_region.id default FALSE, identify use 1-based observation numbers, otherwise use nb region.id attribute values","code":""},{"path":"https://r-spatial.github.io/spdep/reference/edit.nb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interactive editing of neighbours lists — edit.nb","text":"function returns object class nb edited list integer vectors containing neighbour region number ids, added attributes tallying added deleted links.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/edit.nb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Interactive editing of neighbours lists — edit.nb","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/edit.nb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interactive editing of neighbours lists — edit.nb","text":"","code":"# \\dontrun{ columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) class(columbus) #> [1] \"sf\"         \"data.frame\" if (FALSE) nnb1 <- edit.nb(col.gal.nb, polys=as(columbus, \"Spatial\")) # }"},{"path":"https://r-spatial.github.io/spdep/reference/eire.html","id":null,"dir":"Reference","previous_headings":"","what":"Eire data sets — eire","title":"Eire data sets — eire","text":"data set now part spData package","code":""},{"path":"https://r-spatial.github.io/spdep/reference/eire.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Eire data sets — eire","text":"","code":"data(eire)"},{"path":"https://r-spatial.github.io/spdep/reference/geary.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Geary's C — geary","title":"Compute Geary's C — geary","text":"simple function compute Geary's C, called geary.test geary.mc; $$C = \\frac{(n-1)}{2\\sum_{=1}^{n}\\sum_{j=1}^{n}w_{ij}} \\frac{\\sum_{=1}^{n}\\sum_{j=1}^{n}w_{ij}(x_i-x_j)^2}{\\sum_{=1}^{n}(x_i - \\bar{x})^2} $$ geary.intern internal function used vary similarity criterion.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/geary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Geary's C — geary","text":"","code":"geary(x, listw, n, n1, S0, zero.policy=attr(listw, \"zero.policy\"), scale=TRUE) <!-- %geary.intern(x, listw, n, zero.policy, type=\"geary\") -->"},{"path":"https://r-spatial.github.io/spdep/reference/geary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Geary's C — geary","text":"x numeric vector length neighbours list listw listw listw object created example nb2listw n number zones n1 n - 1 S0 global sum weights zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA  scale default TRUE, may FALSE revert changes made accommodate localC November 2021 (see #151)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/geary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Geary's C — geary","text":"list C Geary's C K sample kurtosis x","code":""},{"path":"https://r-spatial.github.io/spdep/reference/geary.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute Geary's C — geary","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, p. 17.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/geary.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute Geary's C — geary","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/geary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Geary's C — geary","text":"","code":"data(oldcol) col.W <- nb2listw(COL.nb, style=\"W\") str(geary(COL.OLD$CRIME, col.W, length(COL.nb), length(COL.nb)-1,  Szero(col.W))) #> List of 2 #>  $ C: num 0.53 #>  $ K: num 2.23"},{"path":"https://r-spatial.github.io/spdep/reference/geary.mc.html","id":null,"dir":"Reference","previous_headings":"","what":"Permutation test for Geary's C statistic — geary.mc","title":"Permutation test for Geary's C statistic — geary.mc","text":"permutation test Geary's C statistic calculated using nsim random permutations x given spatial weighting scheme, establish rank observed statistic relation nsim simulated values.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/geary.mc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permutation test for Geary's C statistic — geary.mc","text":"","code":"geary.mc(x, listw, nsim, zero.policy=attr(listw, \"zero.policy\"), alternative=\"greater\",  spChk=NULL, adjust.n=TRUE, return_boot=FALSE, na.action=na.fail, scale=TRUE)"},{"path":"https://r-spatial.github.io/spdep/reference/geary.mc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permutation test for Geary's C statistic — geary.mc","text":"x numeric vector length neighbours list listw listw listw object created example nb2listw nsim number permutations zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA alternative character string specifying alternative hypothesis, must one \"greater\" (default), \"less\"; reversal corresponds geary.test described section output statistic value, based Cliff Ord 1973, p. 21 (changed 2011-04-11, thanks Daniel Garavito). spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() adjust.n default TRUE, FALSE number observations adjusted -neighbour observations, TRUE, number observations adjusted return_boot return object class boot equivalent permutation bootstrap rather object class htest na.action function (default na.fail), can also na.omit na.exclude - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. na.pass permitted meaningless permutation test. scale default TRUE, may FALSE revert changes made accommodate localC November 2021 (see #151)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/geary.mc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permutation test for Geary's C statistic — geary.mc","text":"list class htest mc.sim containing following components: statistic value observed Geary's C. parameter rank observed Geary's C. p.value pseudo p-value test. alternative character string describing alternative hypothesis. method character string giving method used. data.name character string giving name(s) data, number simulations. res nsim simulated values statistic, final value observed statistic","code":""},{"path":"https://r-spatial.github.io/spdep/reference/geary.mc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Permutation test for Geary's C statistic — geary.mc","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, p. 63-5.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/geary.mc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Permutation test for Geary's C statistic — geary.mc","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/geary.mc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Permutation test for Geary's C statistic — geary.mc","text":"","code":"data(oldcol) set.seed(1) sim1 <- geary.mc(COL.OLD$CRIME, nb2listw(COL.nb, style=\"W\"),  nsim=99, alternative=\"less\") sim1 #>  #> \tMonte-Carlo simulation of Geary C #>  #> data:  COL.OLD$CRIME  #> weights: nb2listw(COL.nb, style = \"W\")   #> number of simulations + 1: 100  #>  #> statistic = 0.52987, observed rank = 1, p-value = 0.99 #> alternative hypothesis: less #>  mean(sim1$res) #> [1] 1.002705 var(sim1$res) #> [1] 0.01043616 summary(sim1$res) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.5299  0.9362  1.0141  1.0027  1.0673  1.2459  colold.lags <- nblag(COL.nb, 3) sim2 <- geary.mc(COL.OLD$CRIME, nb2listw(colold.lags[[2]],  style=\"W\"), nsim=99) sim2 #>  #> \tMonte-Carlo simulation of Geary C #>  #> data:  COL.OLD$CRIME  #> weights: nb2listw(colold.lags[[2]], style = \"W\")   #> number of simulations + 1: 100  #>  #> statistic = 0.81129, observed rank = 1, p-value = 0.01 #> alternative hypothesis: greater #>  summary(sim2$res) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.8113  0.9500  1.0173  1.0147  1.0731  1.1962  sim3 <- geary.mc(COL.OLD$CRIME, nb2listw(colold.lags[[3]],  style=\"W\"), nsim=99) sim3 #>  #> \tMonte-Carlo simulation of Geary C #>  #> data:  COL.OLD$CRIME  #> weights: nb2listw(colold.lags[[3]], style = \"W\")   #> number of simulations + 1: 100  #>  #> statistic = 1.1303, observed rank = 89, p-value = 0.89 #> alternative hypothesis: greater #>  summary(sim3$res) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.7903  0.9609  0.9989  1.0148  1.0656  1.2726  crime <- COL.OLD$CRIME is.na(crime) <- sample(1:length(crime), 10) try(geary.mc(crime, nb2listw(COL.nb, style=\"W\"), nsim=99,  na.action=na.fail)) #> Error in na.fail.default(x) : missing values in object geary.mc(crime, nb2listw(COL.nb, style=\"W\"), nsim=99, zero.policy=TRUE,  na.action=na.omit) #> Warning: subsetting caused increase in subgraph count #>  #> \tMonte-Carlo simulation of Geary C #>  #> data:  crime  #> weights: nb2listw(COL.nb, style = \"W\")  #> omitted: 14, 16, 17, 21, 24, 31, 32, 42, 44, 47  #> number of simulations + 1: 100  #>  #> statistic = 0.49368, observed rank = 1, p-value = 0.01 #> alternative hypothesis: greater #>  geary.mc(crime, nb2listw(COL.nb, style=\"W\"), nsim=99, zero.policy=TRUE,  return_boot=TRUE, na.action=na.omit) #> Warning: subsetting caused increase in subgraph count #> NA observations omitted: 14, 16, 17, 21, 24, 31, 32, 42, 44, 47 #>  #> DATA PERMUTATION #>  #>  #> Call: #> boot(data = x, statistic = geary_boot, R = nsim, sim = \"permutation\",  #>     listw = listw, n = n, n1 = wc$n1, S0 = wc$S0, zero.policy = zero.policy,  #>     scale = scale, parallel = parallel, ncpus = ncpus, cl = cl) #>  #>  #> Bootstrap Statistics : #>      original    bias    std. error #> t1* 0.4936767 0.4891213   0.1517218 geary.mc(crime, nb2listw(COL.nb, style=\"W\"), nsim=99, zero.policy=TRUE,  na.action=na.exclude) #> Warning: subsetting caused increase in subgraph count #>  #> \tMonte-Carlo simulation of Geary C #>  #> data:  crime  #> weights: nb2listw(COL.nb, style = \"W\")  #> omitted: 14, 16, 17, 21, 24, 31, 32, 42, 44, 47  #> number of simulations + 1: 100  #>  #> statistic = 0.49368, observed rank = 1, p-value = 0.01 #> alternative hypothesis: greater #>  geary.mc(crime, nb2listw(COL.nb, style=\"W\"), nsim=99, zero.policy=TRUE,  return_boot=TRUE, na.action=na.exclude) #> Warning: subsetting caused increase in subgraph count #> NA observations omitted: 14, 16, 17, 21, 24, 31, 32, 42, 44, 47 #>  #> DATA PERMUTATION #>  #>  #> Call: #> boot(data = x, statistic = geary_boot, R = nsim, sim = \"permutation\",  #>     listw = listw, n = n, n1 = wc$n1, S0 = wc$S0, zero.policy = zero.policy,  #>     scale = scale, parallel = parallel, ncpus = ncpus, cl = cl) #>  #>  #> Bootstrap Statistics : #>      original    bias    std. error #> t1* 0.4936767 0.4570379   0.1307276 try(geary.mc(crime, nb2listw(COL.nb, style=\"W\"), nsim=99, na.action=na.pass)) #> Error in geary.mc(crime, nb2listw(COL.nb, style = \"W\"), nsim = 99, na.action = na.pass) :  #>   na.pass not permitted"},{"path":"https://r-spatial.github.io/spdep/reference/geary.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Geary's C test for spatial autocorrelation — geary.test","title":"Geary's C test for spatial autocorrelation — geary.test","text":"Geary's test spatial autocorrelation using spatial weights matrix weights list form. assumptions underlying test sensitive form graph neighbour relationships factors, results may checked geary.mc permutations.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/geary.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geary's C test for spatial autocorrelation — geary.test","text":"","code":"geary.test(x, listw, randomisation=TRUE, zero.policy=attr(listw, \"zero.policy\"),     alternative=\"greater\", spChk=NULL, adjust.n=TRUE, na.action=na.fail,     scale=TRUE)"},{"path":"https://r-spatial.github.io/spdep/reference/geary.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Geary's C test for spatial autocorrelation — geary.test","text":"x numeric vector length neighbours list listw listw listw object created example nb2listw randomisation variance calculated assumption randomisation, FALSE normality zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA alternative character string specifying alternative hypothesis, must one \"greater\" (default), \"less\" \"two.sided\". spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() adjust.n default TRUE, FALSE number observations adjusted -neighbour observations, TRUE, number observations adjusted na.action function (default na.fail), can also na.omit na.exclude - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. na.pass permitted. scale default TRUE, may FALSE revert changes made accommodate localC November 2021 (see #151)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/geary.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Geary's C test for spatial autocorrelation — geary.test","text":"list class htest containing following components: statistic value standard deviate Geary's C, order given Cliff Ord 1973, p. 21, (EC - C) / sqrt(VC), sign reversed respect usual (C - EC) / sqrt(VC); means “greater” alternative Geary C test corresponds “greater” alternative Moran's test. p.value p-value test. estimate value observed Geary's C, expectation  variance method assumption. alternative character string describing alternative hypothesis. method character string giving assumption used calculating  standard deviate. data.name character string giving name(s) data.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/geary.test.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Geary's C test for spatial autocorrelation — geary.test","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, p. 21, Cliff, . D., Ord, J. K. 1973 Spatial Autocorrelation, Pion, pp. 15-16, 21; Bivand RS, Wong DWS 2018 Comparing implementations global local indicators spatial association. TEST, 27(3), 716–748 doi:10.1007/s11749-018-0599-x","code":""},{"path":"https://r-spatial.github.io/spdep/reference/geary.test.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Geary's C test for spatial autocorrelation — geary.test","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/geary.test.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Geary's C test for spatial autocorrelation — geary.test","text":"derivation test (Cliff Ord, 1981, p. 18) assumes weights matrix symmetric. inherently non-symmetric matrices, k-nearest neighbour matrices, listw2U() can used make matrix symmetric. non-symmetric weights matrix cases, variance test statistic may negative (thanks Franz Munoz well documented bug report). Geary's C affected non-symmetric weights normality much Moran's . 0.4-35, sign standard deviate C changed match Cliff Ord (1973, p. 21).","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/geary.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Geary's C test for spatial autocorrelation — geary.test","text":"","code":"data(oldcol) geary.test(COL.OLD$CRIME, nb2listw(COL.nb, style=\"W\")) #>  #> \tGeary C test under randomisation #>  #> data:  COL.OLD$CRIME  #> weights: nb2listw(COL.nb, style = \"W\")    #>  #> Geary C statistic standard deviate = 4.7605, p-value = 9.655e-07 #> alternative hypothesis: Expectation greater than statistic #> sample estimates: #> Geary C statistic       Expectation          Variance  #>        0.52986993        1.00000000        0.00975278  #>  geary.test(COL.OLD$CRIME, nb2listw(COL.nb, style=\"W\"),  randomisation=FALSE) #>  #> \tGeary C test under normality #>  #> data:  COL.OLD$CRIME  #> weights: nb2listw(COL.nb, style = \"W\")    #>  #> Geary C statistic standard deviate = 4.6388, p-value = 1.752e-06 #> alternative hypothesis: Expectation greater than statistic #> sample estimates: #> Geary C statistic       Expectation          Variance  #>        0.52986993        1.00000000        0.01027137  #>  colold.lags <- nblag(COL.nb, 3) geary.test(COL.OLD$CRIME, nb2listw(colold.lags[[2]],  style=\"W\")) #>  #> \tGeary C test under randomisation #>  #> data:  COL.OLD$CRIME  #> weights: nb2listw(colold.lags[[2]], style = \"W\")    #>  #> Geary C statistic standard deviate = 2.2896, p-value = 0.01102 #> alternative hypothesis: Expectation greater than statistic #> sample estimates: #> Geary C statistic       Expectation          Variance  #>       0.811285136       1.000000000       0.006793327  #>  geary.test(COL.OLD$CRIME, nb2listw(colold.lags[[3]],  style=\"W\"), alternative=\"greater\") #>  #> \tGeary C test under randomisation #>  #> data:  COL.OLD$CRIME  #> weights: nb2listw(colold.lags[[3]], style = \"W\")    #>  #> Geary C statistic standard deviate = -1.5667, p-value = 0.9414 #> alternative hypothesis: Expectation greater than statistic #> sample estimates: #> Geary C statistic       Expectation          Variance  #>       1.130277918       1.000000000       0.006914551  #>  print(is.symmetric.nb(COL.nb)) #> [1] TRUE coords.OLD <- cbind(COL.OLD$X, COL.OLD$Y) COL.k4.nb <- knn2nb(knearneigh(coords.OLD, 4)) print(is.symmetric.nb(COL.k4.nb)) #> [1] FALSE geary.test(COL.OLD$CRIME, nb2listw(COL.k4.nb, style=\"W\")) #>  #> \tGeary C test under randomisation #>  #> data:  COL.OLD$CRIME  #> weights: nb2listw(COL.k4.nb, style = \"W\")    #>  #> Geary C statistic standard deviate = 6.4415, p-value = 5.916e-11 #> alternative hypothesis: Expectation greater than statistic #> sample estimates: #> Geary C statistic       Expectation          Variance  #>       0.399254423       1.000000000       0.008697812  #>  geary.test(COL.OLD$CRIME, nb2listw(COL.k4.nb, style=\"W\"),  randomisation=FALSE) #>  #> \tGeary C test under normality #>  #> data:  COL.OLD$CRIME  #> weights: nb2listw(COL.k4.nb, style = \"W\")    #>  #> Geary C statistic standard deviate = 6.2873, p-value = 1.615e-10 #> alternative hypothesis: Expectation greater than statistic #> sample estimates: #> Geary C statistic       Expectation          Variance  #>       0.399254423       1.000000000       0.009129529  #>  cat(\"Note non-symmetric weights matrix - use listw2U()\\n\") #> Note non-symmetric weights matrix - use listw2U() geary.test(COL.OLD$CRIME, listw2U(nb2listw(COL.k4.nb,  style=\"W\"))) #>  #> \tGeary C test under randomisation #>  #> data:  COL.OLD$CRIME  #> weights: listw2U(nb2listw(COL.k4.nb, style = \"W\"))    #>  #> Geary C statistic standard deviate = 6.4415, p-value = 5.916e-11 #> alternative hypothesis: Expectation greater than statistic #> sample estimates: #> Geary C statistic       Expectation          Variance  #>       0.399254423       1.000000000       0.008697812  #>  geary.test(COL.OLD$CRIME, listw2U(nb2listw(COL.k4.nb,  style=\"W\")), randomisation=FALSE) #>  #> \tGeary C test under normality #>  #> data:  COL.OLD$CRIME  #> weights: listw2U(nb2listw(COL.k4.nb, style = \"W\"))    #>  #> Geary C statistic standard deviate = 6.2873, p-value = 1.615e-10 #> alternative hypothesis: Expectation greater than statistic #> sample estimates: #> Geary C statistic       Expectation          Variance  #>       0.399254423       1.000000000       0.009129529  #>  crime <- COL.OLD$CRIME is.na(crime) <- sample(1:length(crime), 10) try(geary.test(crime, nb2listw(COL.nb, style=\"W\"), na.action=na.fail)) #> Error in na.fail.default(x) : missing values in object geary.test(crime, nb2listw(COL.nb, style=\"W\"), zero.policy=TRUE,  na.action=na.omit) #>  #> \tGeary C test under randomisation #>  #> data:  crime  #> weights: nb2listw(COL.nb, style = \"W\")  #> omitted: 3, 4, 10, 20, 21, 23, 27, 29, 31, 38   #>  #> Geary C statistic standard deviate = 4.2726, p-value = 9.661e-06 #> alternative hypothesis: Expectation greater than statistic #> sample estimates: #> Geary C statistic       Expectation          Variance  #>        0.45199742        1.00000000        0.01645071  #>  geary.test(crime, nb2listw(COL.nb, style=\"W\"), zero.policy=TRUE,  na.action=na.exclude) #>  #> \tGeary C test under randomisation #>  #> data:  crime  #> weights: nb2listw(COL.nb, style = \"W\")  #> omitted: 3, 4, 10, 20, 21, 23, 27, 29, 31, 38   #>  #> Geary C statistic standard deviate = 4.2726, p-value = 9.661e-06 #> alternative hypothesis: Expectation greater than statistic #> sample estimates: #> Geary C statistic       Expectation          Variance  #>        0.45199742        1.00000000        0.01645071  #>  try(geary.test(crime, nb2listw(COL.nb, style=\"W\"), na.action=na.pass)) #> Error in geary.test(crime, nb2listw(COL.nb, style = \"W\"), na.action = na.pass) :  #>   na.pass not permitted"},{"path":"https://r-spatial.github.io/spdep/reference/globalG.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Global G test for spatial autocorrelation — globalG.test","title":"Global G test for spatial autocorrelation — globalG.test","text":"global G statistic spatial autocorrelation, complementing local Gi LISA measures: localG.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/globalG.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Global G test for spatial autocorrelation — globalG.test","text":"","code":"globalG.test(x, listw, zero.policy=attr(listw, \"zero.policy\"), alternative=\"greater\",  spChk=NULL, adjust.n=TRUE, B1correct=TRUE, adjust.x=TRUE, Arc_all_x=FALSE,  na.action=na.fail)"},{"path":"https://r-spatial.github.io/spdep/reference/globalG.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Global G test for spatial autocorrelation — globalG.test","text":"x numeric vector length neighbours list listw listw listw object created example nb2listw; sequence distance bands used, recommended weights style binary (one c(\"B\", \"C\", \"U\")). zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA alternative character string specifying alternative hypothesis, must one \"greater\" (default), \"less\" \"two.sided\". spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() adjust.n default TRUE, FALSE number observations adjusted -neighbour observations, TRUE, number observations adjusted B1correct default TRUE, TRUE, erratum referenced : \"page 195, coefficient W2 B1, (just center page) 6,  3.\" applied; FALSE, 3 used (CrimeStat IV) adjust.x default TRUE, TRUE, x values observations neighbours omitted denominator G Arc_all_x default FALSE, Arc_all_x=TRUE adjust.x=TRUE, use full x vector part denominator term G na.action function (default na.fail), can also na.omit na.exclude - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. na.pass permitted.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/globalG.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Global G test for spatial autocorrelation — globalG.test","text":"list class htest containing following components: statistic value standard deviate Getis-Ord G. p.value p-value test. estimate value observed statistic, expectation variance. alternative character string describing alternative hypothesis. data.name character string giving name(s) data.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/globalG.test.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Global G test for spatial autocorrelation — globalG.test","text":"Getis. , Ord, J. K. 1992 analysis spatial association use distance statistics, Geographical Analysis, 24, p. 195; see also Getis. , Ord, J. K. 1993 Erratum, Geographical Analysis, 25, p. 276; Bivand RS, Wong DWS 2018 Comparing implementations global local indicators spatial association. TEST, 27(3), 716–748 doi:10.1007/s11749-018-0599-x","code":""},{"path":"https://r-spatial.github.io/spdep/reference/globalG.test.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Global G test for spatial autocorrelation — globalG.test","text":"Hisaji ONO hi-ono@mn.xdsl.ne.jp Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/globalG.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Global G test for spatial autocorrelation — globalG.test","text":"","code":"nc.sids <- st_read(system.file(\"shapes/sids.gpkg\", package=\"spData\")[1], quiet=TRUE) sidsrate79 <- (1000*nc.sids$SID79)/nc.sids$BIR79 dists <- c(10, 20, 30, 33, 40, 50, 60, 70, 80, 90, 100) ndists <- length(dists) ZG <- vector(mode=\"list\", length=ndists) names(ZG) <- as.character(dists) milesxy <- cbind(nc.sids$east, nc.sids$north) for (i in 1:ndists) {   thisnb <- dnearneigh(milesxy, 0, dists[i])   thislw <- nb2listw(thisnb, style=\"B\", zero.policy=TRUE)   ZG[[i]] <- globalG.test(sidsrate79, thislw, zero.policy=TRUE) } #> Warning: neighbour object has 98 sub-graphs #> Warning: neighbour object has 37 sub-graphs #> Warning: neighbour object has 3 sub-graphs t(sapply(ZG, function(x) c(x$estimate[1], x$statistic, p.value=unname(x$p.value)))) #>     Global G statistic standard deviate   p.value #> 10          0.33548581       0.04859237 0.4806221 #> 20          0.02024945      -0.73262399 0.7681061 #> 30          0.04032434      -0.75011405 0.7734070 #> 33          0.05312271       0.40157023 0.3440002 #> 40          0.07400279      -0.04345713 0.5173314 #> 50          0.11471743       0.58686472 0.2786473 #> 60          0.15457553      -0.35823892 0.6399177 #> 70          0.19839023      -0.27864299 0.6097406 #> 80          0.24606972      -0.18791364 0.5745278 #> 90          0.30073463       0.11457610 0.4543906 #> 100         0.34879996       0.31591356 0.3760341 for (i in 1:ndists) {   thisnb <- dnearneigh(milesxy, 0, dists[i])   thislw <- nb2listw(thisnb, style=\"B\", zero.policy=TRUE)   ZG[[i]] <- globalG.test(sidsrate79, thislw, zero.policy=TRUE, alternative=\"two.sided\") } #> Warning: neighbour object has 98 sub-graphs #> Warning: neighbour object has 37 sub-graphs #> Warning: neighbour object has 3 sub-graphs t(sapply(ZG, function(x) c(x$estimate[1], x$statistic, p.value=unname(x$p.value)))) #>     Global G statistic standard deviate   p.value #> 10          0.33548581       0.04859237 0.9612441 #> 20          0.02024945      -0.73262399 0.4637878 #> 30          0.04032434      -0.75011405 0.4531860 #> 33          0.05312271       0.40157023 0.6880003 #> 40          0.07400279      -0.04345713 0.9653371 #> 50          0.11471743       0.58686472 0.5572946 #> 60          0.15457553      -0.35823892 0.7201645 #> 70          0.19839023      -0.27864299 0.7805188 #> 80          0.24606972      -0.18791364 0.8509443 #> 90          0.30073463       0.11457610 0.9087811 #> 100         0.34879996       0.31591356 0.7520681 data(oldcol) crime <- COL.OLD$CRIME is.na(crime) <- sample(1:length(crime), 10) res <- try(globalG.test(crime, nb2listw(COL.nb, style=\"B\"),  na.action=na.fail)) #> Error in na.fail.default(x) : missing values in object res #> [1] \"Error in na.fail.default(x) : missing values in object\\n\" #> attr(,\"class\") #> [1] \"try-error\" #> attr(,\"condition\") #> <simpleError in na.fail.default(x): missing values in object> globalG.test(crime, nb2listw(COL.nb, style=\"B\"), zero.policy=TRUE,  na.action=na.omit) #> Warning: subsetting caused increase in subgraph count #>  #> \tGetis-Ord global G statistic #>  #> data:  crime  #> weights: nb2listw(COL.nb, style = \"B\")  #> omitted: 2, 3, 5, 6, 7, 10, 13, 30, 39, 49  #> n reduced by no-neighbour observations  #>  #> standard deviate = 3.8084, p-value = 6.993e-05 #> alternative hypothesis: greater #> sample estimates: #> Global G statistic        Expectation           Variance  #>       1.441233e-01       1.123755e-01       6.949287e-05  #>  globalG.test(crime, nb2listw(COL.nb, style=\"B\"), zero.policy=TRUE,  na.action=na.exclude) #> Warning: subsetting caused increase in subgraph count #>  #> \tGetis-Ord global G statistic #>  #> data:  crime  #> weights: nb2listw(COL.nb, style = \"B\")  #> omitted: 2, 3, 5, 6, 7, 10, 13, 30, 39, 49  #> n reduced by no-neighbour observations  #>  #> standard deviate = 3.8084, p-value = 6.993e-05 #> alternative hypothesis: greater #> sample estimates: #> Global G statistic        Expectation           Variance  #>       1.441233e-01       1.123755e-01       6.949287e-05  #>  try(globalG.test(crime, nb2listw(COL.nb, style=\"B\"), na.action=na.pass)) #> Error in globalG.test(crime, nb2listw(COL.nb, style = \"B\"), na.action = na.pass) :  #>   na.pass not permitted"},{"path":"https://r-spatial.github.io/spdep/reference/graphneigh.html","id":null,"dir":"Reference","previous_headings":"","what":"Graph based spatial weights — graphneigh","title":"Graph based spatial weights — graphneigh","text":"Functions return graph object containing list vertex coordinates indices defining edges. /functions assume coordinates exactly regularly spaced. helper function graph2nb converts graph object neighbour list. plot functions plot graph objects.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/graphneigh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Graph based spatial weights — graphneigh","text":"","code":"gabrielneigh(coords, nnmult=3) relativeneigh(coords, nnmult=3) <!-- %beta.skel(coords,beta) --> soi.graph(tri.nb, coords, quadsegs=10) graph2nb(gob, row.names=NULL,sym=FALSE) # S3 method for class 'Gabriel' plot(x, show.points=FALSE, add=FALSE, linecol=par(col), ...) # S3 method for class 'relative' plot(x, show.points=FALSE, add=FALSE, linecol=par(col),...)"},{"path":"https://r-spatial.github.io/spdep/reference/graphneigh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Graph based spatial weights — graphneigh","text":"coords matrix region point coordinates SpatialPoints object sfc points object nnmult scaling factor memory allocation, default 3; higher values required, function exit error; example thanks Dan Putler tri.nb neighbor list created tri2nb quadsegs number line segments making quarter circle buffer, see nQuadSegs argument geos_unary  gob graph object created graph funtions row.names character vector region ids added     neighbours list attribute region.id, default seq(1,       nrow(x)) sym logical argument indicating whether neighbors     symetric (->j j->) x object plotted show.points (logical) add points plot add (logical) add existing plot linecol edge plotting colour ... graphical parameters par(..)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/graphneigh.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Graph based spatial weights — graphneigh","text":"graph functions produce graphs 2d point set    subgraphs Delaunay triangulation. relative neighbor graph defined relation, x y neighbors $$d(x,y) \\le min(max(d(x,z),d(y,z))| z \\S)$$ d() distance, S set points z arbitrary point S. Gabriel graph subgraph delaunay triangulation relative neighbor graph sub-graph. relative neighbor graph defined relation x y Gabriel neighbors $$d(x,y) \\le min((d(x,z)^2 + d(y,z)^2)^{1/2} |z \\S)$$ x,y,z S . sphere influence graph defined finite point set S, let \\(r_x\\) distance point x nearest neighbor S, \\(C_x\\) circle centered x. x y SOI neigbors iff \\(C_x\\) \\(C_y\\) intersect least 2 places. 2016-05-31, Computational Geometry C code replaced calls functions dbscan sf; large quadsegs= argument, behaviour function , otherwise buffer intersections closely approximate original function. See card details “nb” objects.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/graphneigh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Graph based spatial weights — graphneigh","text":"list class Graph following elements np number input points array origin ids array destination ids nedges number edges graph x input x coordinates y input y coordinates helper functions return nb object list integer  vectors containing neighbour region number ids.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/graphneigh.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Graph based spatial weights — graphneigh","text":"Matula, D. W. Sokal R. R. 1980, Properties Gabriel   graphs relevant geographic variation research clustering   points plane, Geographic Analysis, 12(3), pp. 205-222. Toussaint, G. T. 1980, relative neighborhood graph finite   planar set, Pattern Recognition, 12(4), pp. 261-268. Kirkpatrick, D. G. Radke, J. D. 1985, framework   computational morphology. Computational Geometry,   Ed. G. T. Toussaint, North Holland.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/graphneigh.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Graph based spatial weights — graphneigh","text":"Nicholas Lewin-Koh nikko@hailmail.net","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/graphneigh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Graph based spatial weights — graphneigh","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) sf_obj <- st_centroid(st_geometry(columbus), of_largest_polygon) sp_obj <- as(sf_obj, \"Spatial\") coords <- st_coordinates(sf_obj) suppressMessages(col.tri.nb <- tri2nb(coords)) col.gab.nb <- graph2nb(gabrielneigh(coords), sym=TRUE) col.rel.nb <- graph2nb(relativeneigh(coords), sym=TRUE) par(mfrow=c(2,2)) plot(st_geometry(columbus), border=\"grey\") plot(col.tri.nb,coords,add=TRUE) title(main=\"Delaunay Triangulation\", cex.main=0.6) plot(st_geometry(columbus), border=\"grey\") plot(col.gab.nb, coords, add=TRUE) title(main=\"Gabriel Graph\", cex.main=0.6) plot(st_geometry(columbus), border=\"grey\") plot(col.rel.nb, coords, add=TRUE) title(main=\"Relative Neighbor Graph\", cex.main=0.6) plot(st_geometry(columbus), border=\"grey\") if (require(\"dbscan\", quietly=TRUE)) {   col.soi.nb <- graph2nb(soi.graph(col.tri.nb,coords), sym=TRUE)   plot(col.soi.nb, coords, add=TRUE)   title(main=\"Sphere of Influence Graph\", cex.main=0.6) } #>  #> Attaching package: ‘dbscan’ #> The following object is masked from ‘package:stats’: #>  #>     as.dendrogram  par(mfrow=c(1,1)) col.tri.nb_sf <- tri2nb(sf_obj) all.equal(col.tri.nb, col.tri.nb_sf, check.attributes=FALSE) #> [1] TRUE col.tri.nb_sp <- tri2nb(sp_obj) all.equal(col.tri.nb, col.tri.nb_sp, check.attributes=FALSE) #> [1] TRUE if (require(\"dbscan\", quietly=TRUE)) {   col.soi.nb_sf <- graph2nb(soi.graph(col.tri.nb, sf_obj), sym=TRUE)   all.equal(col.soi.nb, col.soi.nb_sf, check.attributes=FALSE)   col.soi.nb_sp <- graph2nb(soi.graph(col.tri.nb, sp_obj), sym=TRUE)   all.equal(col.soi.nb, col.soi.nb_sp, check.attributes=FALSE) } #> [1] TRUE col.gab.nb_sp <- graph2nb(gabrielneigh(sp_obj), sym=TRUE) all.equal(col.gab.nb, col.gab.nb_sp, check.attributes=FALSE) #> [1] TRUE col.gab.nb_sf <- graph2nb(gabrielneigh(sf_obj), sym=TRUE) all.equal(col.gab.nb, col.gab.nb_sf, check.attributes=FALSE) #> [1] TRUE col.rel.nb_sp <- graph2nb(relativeneigh(sp_obj), sym=TRUE) all.equal(col.rel.nb, col.rel.nb_sp, check.attributes=FALSE) #> [1] TRUE col.rel.nb_sf <- graph2nb(relativeneigh(sf_obj), sym=TRUE) all.equal(col.rel.nb, col.rel.nb_sf, check.attributes=FALSE) #> [1] TRUE dx <- rep(0.25*0:4,5) dy <- c(rep(0,5),rep(0.25,5),rep(0.5,5), rep(0.75,5),rep(1,5)) m <- cbind(c(dx, dx, 3+dx, 3+dx), c(dy, 3+dy, dy, 3+dy)) cat(try(res <- gabrielneigh(m), silent=TRUE), \"\\n\") #> Error in gabrielneigh(m) : number of neighbours overrun - increase nnmult #>   res <- gabrielneigh(m, nnmult=4) summary(graph2nb(res)) #> Neighbour list object: #> Number of regions: 100  #> Number of nonzero links: 342  #> Percentage nonzero weights: 3.42  #> Average number of links: 3.42  #> 1 region with no links: #> 100 #> Non-symmetric neighbours list #> Link number distribution: #>  #>  0  1  2  3  4  5  #>  1  8 10 18 55  8  #> 8 least connected regions: #> 46 47 48 49 96 97 98 99 with 1 link #> 8 most connected regions: #> 10 15 20 25 30 35 40 45 with 5 links grd <- as.matrix(expand.grid(x=1:5, y=1:5)) #gridded data r2 <- gabrielneigh(grd) set.seed(1) grd1 <- as.matrix(expand.grid(x=1:5, y=1:5)) + matrix(runif(50, .0001, .0006), nrow=25) r3 <- gabrielneigh(grd1) opar <- par(mfrow=c(1,2)) plot(r2, show=TRUE, linecol=2) plot(r3, show=TRUE, linecol=2)  par(opar) # example of reading points with readr::read_csv() yielding a tibble load(system.file(\"etc/misc/coords.rda\", package=\"spdep\")) class(coords) #> [1] \"spec_tbl_df\" \"tbl_df\"      \"tbl\"         \"data.frame\"  graph2nb(gabrielneigh(coords)) #> Neighbour list object: #> Number of regions: 100  #> Number of nonzero links: 179  #> Percentage nonzero weights: 1.79  #> Average number of links: 1.79  #> 23 regions with no links: #> 22, 39, 43, 53, 58, 61, 66, 70, 71, 73, 76, 78, 81, 88, 90, 93, 94, 95, #> 96, 97, 98, 99, 100 #> Non-symmetric neighbours list graph2nb(relativeneigh(coords)) #> Neighbour list object: #> Number of regions: 100  #> Number of nonzero links: 117  #> Percentage nonzero weights: 1.17  #> Average number of links: 1.17  #> 31 regions with no links: #> 22, 29, 33, 39, 41, 42, 43, 44, 53, 58, 61, 64, 65, 66, 70, 71, 73, 75, #> 76, 78, 81, 88, 90, 93, 94, 95, 96, 97, 98, 99, 100 #> Non-symmetric neighbours list"},{"path":"https://r-spatial.github.io/spdep/reference/grid2nb.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct neighbours for a GridTopology — grid2nb","title":"Construct neighbours for a GridTopology — grid2nb","text":"function builds neighbours list grid topology.   works k-dimentional grid topology, k>=1.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/grid2nb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct neighbours for a GridTopology — grid2nb","text":"","code":"grid2nb(grid, d = grid@cells.dim,         queen = TRUE, nb = TRUE, self = FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/grid2nb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct neighbours for a GridTopology — grid2nb","text":"grid object class GridTopology. One can avoid   supply just suplying dimentions d argument. d scalar (one dimentional grid) length k vector   specyfying number grid cells direction k   dimentions. queen Logical. Default TRUE. inform queen   neighbourhood structure considered. FALSE,   hyper-cube common face considered neighbour.   TRUE, single shared coordinate meets contiguity condition. nb Default TRUE. TRUE, return result neighbours   list class nb. FALSE, result matrix   3^k columns self = TRUE 3^k-1   self = FALSE. Zeros used hyper-cubes boundaries. self Default FALSE, indicate hyper-cube neighbour   considered neighbour.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/grid2nb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct neighbours for a GridTopology — grid2nb","text":"Either matrix, “nb” FALSE neighbours list   class nb. See card details “nb”   objects.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/grid2nb.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Construct neighbours for a GridTopology — grid2nb","text":"applies k-dimentional grid topology.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/grid2nb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Construct neighbours for a GridTopology — grid2nb","text":"Elias T Krainski eliaskrainski@gmail.com","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/grid2nb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct neighbours for a GridTopology — grid2nb","text":"","code":"nb <- grid2nb(d = c(5L, 5L, 5L)) nb #> Neighbour list object: #> Number of regions: 125  #> Number of nonzero links: 2072  #> Percentage nonzero weights: 13.2608  #> Average number of links: 16.576  summary(nb) #> Neighbour list object: #> Number of regions: 125  #> Number of nonzero links: 2072  #> Percentage nonzero weights: 13.2608  #> Average number of links: 16.576  #> Link number distribution: #>  #>  7 11 17 26  #>  8 36 54 27  #> 8 least connected regions: #> 1 5 21 25 101 105 121 125 with 7 links #> 27 most connected regions: #> 32 33 34 37 38 39 42 43 44 57 58 59 62 63 64 67 68 69 82 83 84 87 88 89 92 93 94 with 26 links if (require(\"sp\", quietly=TRUE)) { gt <- GridTopology(c(.125,.1), c(.25,.2), c(4L, 5L)) nb1 <- grid2nb(gt, queen = FALSE) nb2 <- grid2nb(gt)  sg <- SpatialGrid(gt) plot(sg, lwd=3) plot(nb1, coordinates(sg), add=TRUE, lty=2, col=2, lwd=2) plot(nb2, coordinates(sg), add=TRUE, lty=3, col=4)  str(grid2nb(d=5)) }  #> List of 5 #>  $ : int 2 #>  $ : int [1:2] 1 3 #>  $ : int [1:2] 2 4 #>  $ : int [1:2] 3 5 #>  $ : int 4 #>  - attr(*, \"class\")= chr \"nb\""},{"path":"https://r-spatial.github.io/spdep/reference/hotspotmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Cluster Classifications for Local Indicators of Spatial Association and Local Indicators for Categorical Data — hotspot","title":"Cluster Classifications for Local Indicators of Spatial Association and Local Indicators for Categorical Data — hotspot","text":"Used return factor showing -called cluster classification local indicators spatial association local Moran's , local Geary's C (multivariate variant) local Getis-Ord G. factor vector can added spatial object mapping. obj class licd, list six factors measures local composition (analytical permutation), local configuration (analytical permutation), combined measures, interaction composition configuration, simplified recoding .","code":""},{"path":"https://r-spatial.github.io/spdep/reference/hotspotmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cluster Classifications for Local Indicators of Spatial Association and Local Indicators for Categorical Data — hotspot","text":"","code":"hotspot(obj, ...)  # Default S3 method hotspot(obj, ...)  # S3 method for class 'localmoran' hotspot(obj, Prname, cutoff=0.005, quadrant.type=\"mean\",  p.adjust=\"fdr\", droplevels=TRUE, ...) # S3 method for class 'summary.localmoransad' hotspot(obj, Prname, cutoff=0.005,  quadrant.type=\"mean\", p.adjust=\"fdr\", droplevels=TRUE, ...) # S3 method for class 'data.frame.localmoranex' hotspot(obj, Prname, cutoff=0.005,  quadrant.type=\"mean\", p.adjust=\"fdr\", droplevels=TRUE, ...)  # S3 method for class 'localG' hotspot(obj, Prname, cutoff=0.005, p.adjust=\"fdr\", droplevels=TRUE, ...)  # S3 method for class 'localC' hotspot(obj, Prname, cutoff=0.005, p.adjust=\"fdr\", droplevels=TRUE, ...) # S3 method for class 'licd' hotspot(obj, type = \"both\", cutoff = 0.05, p.adjust = \"none\",   droplevels = TRUE, control = list(), ...)"},{"path":"https://r-spatial.github.io/spdep/reference/hotspotmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cluster Classifications for Local Indicators of Spatial Association and Local Indicators for Categorical Data — hotspot","text":"obj object class localmoran, localC localG Prname character string, name column containing probability values classified cluster type found “interesting” cutoff Default 0.005, probability value cutoff larger observation found “interesting” p.adjust Default \"fdr\", p.adjust() methood used, one c(\"holm\", \"hochberg\", \"hommel\", \"bonferroni\", \"BH\", \"\", \"fdr\", \"none\") droplevels Default TRUE, empty levels input cluster factor dropped quadrant.type Default \"mean\", \"localmoran\" objects , can c(\"mean\", \"median\", \"pysal\") partition Moran scatterplot; \"mean\" partitions means variable spatial lag, \"median\" medians variable spatial lag, \"pysal\" zero centred variable spatial lag type obj class licd, default , may also comp local composition config local configuration control obj class licd, default binomial_sidak 2, binomial_overlap TRUE, jcm_sidak 3. binomial_overlap  may set FALSE avoid Binomial probability values summing unity - tests Boots (2003, p. 141) overlap (>= <=), Šidák exponents may set 1 prevent -observation correction 2 Binomial 3 Normal probability values per observation ... arguments passed methods.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/hotspotmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cluster Classifications for Local Indicators of Spatial Association and Local Indicators for Categorical Data — hotspot","text":"factor showing -called cluster classification local indicators spatial association. obj class licd, list six factors measures local composition (analytical permutation), local configuration (analytical permutation), combined measures, interaction composition configuration, simplified recoding .","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/hotspotmap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Cluster Classifications for Local Indicators of Spatial Association and Local Indicators for Categorical Data — hotspot","text":"Roger Bivand","code":""},{"path":"https://r-spatial.github.io/spdep/reference/hotspotmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cluster Classifications for Local Indicators of Spatial Association and Local Indicators for Categorical Data — hotspot","text":"","code":"orig <- spData::africa.rook.nb listw <- nb2listw(orig) x <- spData::afcon$totcon  set.seed(1) C <- localC_perm(x, listw) Ch <- hotspot(C, Prname=\"Pr(z != E(Ci)) Sim\", cutoff=0.05, p.adjust=\"none\") table(addNA(Ch)) #>  #> High-High   Low-Low      <NA>  #>         4         1        37  set.seed(1) I <- localmoran_perm(x, listw) Ih <- hotspot(I, Prname=\"Pr(z != E(Ii)) Sim\", cutoff=0.05, p.adjust=\"none\") table(addNA(Ih)) #>  #> High-High      <NA>  #>         6        36  Is <- summary(localmoran.sad(lm(x ~ 1), nb=orig)) Ish <- hotspot(Is, Prname=\"Pr. (Sad)\", cutoff=0.05, p.adjust=\"none\") table(addNA(Ish)) #>  #> High-High      <NA>  #>         5        37  Ie <- as.data.frame(localmoran.exact(lm(x ~ 1), nb=orig)) Ieh <- hotspot(Ie, Prname=\"Pr. (exact)\", cutoff=0.05, p.adjust=\"none\") table(addNA(Ieh)) #>  #> High-High      <NA>  #>         5        37  set.seed(1) G <- localG_perm(x, listw) Gh <- hotspot(G, Prname=\"Pr(z != E(Gi)) Sim\", cutoff=0.05, p.adjust=\"none\") table(addNA(Gh)) #>  #> High <NA>  #>    6   36"},{"path":"https://r-spatial.github.io/spdep/reference/include.self.html","id":null,"dir":"Reference","previous_headings":"","what":"Include self in neighbours list — include.self","title":"Include self in neighbours list — include.self","text":"function includes region list neighbours, sets attribute \"self.included\" TRUE; remove.self reverts effects include.self.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/include.self.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Include self in neighbours list — include.self","text":"","code":"include.self(nb) remove.self(nb)"},{"path":"https://r-spatial.github.io/spdep/reference/include.self.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Include self in neighbours list — include.self","text":"nb input neighbours list class nb","code":""},{"path":"https://r-spatial.github.io/spdep/reference/include.self.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Include self in neighbours list — include.self","text":"function returns object class nb list integer vectors containing neighbour region number ids; attribute \"self.included\" set TRUE.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/include.self.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Include self in neighbours list — include.self","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/include.self.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Include self in neighbours list — include.self","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) coords <- st_coordinates(st_centroid(columbus)) #> Warning: st_centroid assumes attributes are constant over geometries summary(col.gal.nb, coords) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.579342  #> Average number of links: 4.693878  #> Link number distribution: #>  #>  2  3  4  5  6  7  8  9 10  #>  7  7 13  4  9  6  1  1  1  #> 7 least connected regions: #> 1 6 31 39 42 46 47 with 2 links #> 1 most connected region: #> 20 with 10 links summary(include.self(col.gal.nb), coords) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 279  #> Percentage nonzero weights: 11.62016  #> Average number of links: 5.693878  #> Link number distribution: #>  #>  3  4  5  6  7  8  9 10 11  #>  7  7 13  4  9  6  1  1  1  #> 7 least connected regions: #> 1 6 31 39 42 46 47 with 3 links #> 1 most connected region: #> 20 with 11 links summary(remove.self(include.self(col.gal.nb)), coords) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.579342  #> Average number of links: 4.693878  #> Link number distribution: #>  #>  2  3  4  5  6  7  8  9 10  #>  7  7 13  4  9  6  1  1  1  #> 7 least connected regions: #> 1 6 31 39 42 46 47 with 2 links #> 1 most connected region: #> 20 with 10 links"},{"path":"https://r-spatial.github.io/spdep/reference/joincount.mc.html","id":null,"dir":"Reference","previous_headings":"","what":"Permutation test for same colour join count statistics — joincount.mc","title":"Permutation test for same colour join count statistics — joincount.mc","text":"permutation test colour join count statistics calculated using nsim random permutations fx given spatial weighting scheme, establish ranks observed statistics (colour) relation nsim simulated values.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/joincount.mc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permutation test for same colour join count statistics — joincount.mc","text":"","code":"joincount.mc(fx, listw, nsim, zero.policy=attr(listw, \"zero.policy\"),  alternative=\"greater\", spChk=NULL)"},{"path":"https://r-spatial.github.io/spdep/reference/joincount.mc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permutation test for same colour join count statistics — joincount.mc","text":"fx factor length neighbours weights objects listw listw listw object created example nb2listw nsim number permutations zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA alternative character string specifying alternative hypothesis, must one \"greater\" (default), \"two.sided\", \"less\". spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption()","code":""},{"path":"https://r-spatial.github.io/spdep/reference/joincount.mc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permutation test for same colour join count statistics — joincount.mc","text":"list class jclist lists class htest mc.sim k colours containing following components: statistic value observed statistic. parameter rank observed statistic. method character string giving method used. data.name character string giving name(s) data. p.value pseudo p-value test. alternative character string describing alternative hypothesis. estimate mean variance simulated distribution. res nsim simulated values statistic, final element observed statistic","code":""},{"path":"https://r-spatial.github.io/spdep/reference/joincount.mc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Permutation test for same colour join count statistics — joincount.mc","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, p. 63-5.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/joincount.mc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Permutation test for same colour join count statistics — joincount.mc","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/joincount.mc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Permutation test for same colour join count statistics — joincount.mc","text":"","code":"data(oldcol) HICRIME <- cut(COL.OLD$CRIME, breaks=c(0,35,80), labels=c(\"low\",\"high\")) names(HICRIME) <- rownames(COL.OLD) joincount.mc(HICRIME, nb2listw(COL.nb, style=\"B\"), nsim=99, alternative=\"two.sided\") #>  #> \tMonte-Carlo simulation of join-count statistic #>  #> data:  HICRIME  #> weights: nb2listw(COL.nb, style = \"B\")  #> number of simulations + 1: 100  #>  #> Join-count statistic for low = 34, rank of observed statistic = 88.5, #> p-value = 0.23 #> alternative hypothesis: two.sided #> sample estimates: #>     mean of simulation variance of simulation  #>               28.96970               18.19295  #>  #>  #> \tMonte-Carlo simulation of join-count statistic #>  #> data:  HICRIME  #> weights: nb2listw(COL.nb, style = \"B\")  #> number of simulations + 1: 100  #>  #> Join-count statistic for high = 54, rank of observed statistic = 100, #> p-value < 2.2e-16 #> alternative hypothesis: two.sided #> sample estimates: #>     mean of simulation variance of simulation  #>               26.83838               20.13688  #>  joincount.test(HICRIME, nb2listw(COL.nb, style=\"B\"), alternative=\"two.sided\") #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: nb2listw(COL.nb, style = \"B\")  #>  #> Std. deviate for low = 1.0141, p-value = 0.3105 #> alternative hypothesis: two.sided #> sample estimates: #> Same colour statistic           Expectation              Variance  #>              34.00000              29.59184              18.89550  #>  #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: nb2listw(COL.nb, style = \"B\")  #>  #> Std. deviate for high = 6.3307, p-value = 2.44e-10 #> alternative hypothesis: two.sided #> sample estimates: #> Same colour statistic           Expectation              Variance  #>              54.00000              27.22449              17.88838  #>"},{"path":"https://r-spatial.github.io/spdep/reference/joincount.multi.html","id":null,"dir":"Reference","previous_headings":"","what":"BB, BW and Jtot join count statistic for k-coloured factors — joincount.multi","title":"BB, BW and Jtot join count statistic for k-coloured factors — joincount.multi","text":"function tallying join counts -colour different colour spatial objects, neighbour relations defined weights list. Given global counts colour, expected counts variances calculated non-free sampling, z-value reported. Since multiple tests reported, p-values given, allowing user adjust significance level applied. Jtot count different-colour joins.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/joincount.multi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BB, BW and Jtot join count statistic for k-coloured factors — joincount.multi","text":"","code":"joincount.multi(fx, listw, zero.policy = attr(listw, \"zero.policy\"),  spChk = NULL, adjust.n=TRUE) # S3 method for class 'jcmulti' print(x, ...)"},{"path":"https://r-spatial.github.io/spdep/reference/joincount.multi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BB, BW and Jtot join count statistic for k-coloured factors — joincount.multi","text":"fx factor length neighbours weights objects listw listw listw object created example nb2listw zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA adjust.n default TRUE, FALSE number observations adjusted -neighbour observations, TRUE, number observations adjusted consistently (including spdep 0.3-28 adjustment inconsistent - thanks Tomoki NAKAYA careful bug report) spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() x object printed ... arguments passed printing","code":""},{"path":"https://r-spatial.github.io/spdep/reference/joincount.multi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"BB, BW and Jtot join count statistic for k-coloured factors — joincount.multi","text":"matrix class jcmulti row column names observed expected counts, variance, z-value.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/joincount.multi.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"BB, BW and Jtot join count statistic for k-coloured factors — joincount.multi","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, p. 20; Upton, G., Fingleton, B. 1985 Spatial data analysis example: point pattern qualitative data, Wiley, pp. 158–170.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/joincount.multi.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"BB, BW and Jtot join count statistic for k-coloured factors — joincount.multi","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/joincount.multi.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"BB, BW and Jtot join count statistic for k-coloured factors — joincount.multi","text":"derivation test (Cliff Ord, 1981, p. 18) assumes weights matrix symmetric. inherently non-symmetric matrices, k-nearest neighbour matrices, listw2U() can used make matrix symmetric. non-symmetric weights matrix cases, variance test statistic may negative.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/joincount.multi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"BB, BW and Jtot join count statistic for k-coloured factors — joincount.multi","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) HICRIME <- cut(columbus$CRIME, breaks=c(0,35,80), labels=c(\"low\",\"high\")) (nb <- poly2nb(columbus)) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 236  #> Percentage nonzero weights: 9.829238  #> Average number of links: 4.816327  lw <- nb2listw(nb, style=\"B\") joincount.multi(HICRIME, lw) #>           Joincount Expected Variance z-value #> low:low      35.000   30.102   19.247  1.1164 #> high:high    54.000   27.694   18.219  6.1630 #> high:low     29.000   60.204   26.630 -6.0468 #> Jtot         29.000   60.204   26.630 -6.0468 col_geoms <- st_geometry(columbus) col_geoms[21] <- st_buffer(col_geoms[21], dist=-0.05) st_geometry(columbus) <- col_geoms (nb <- poly2nb(columbus)) #> Warning: some observations have no neighbours; #> if this seems unexpected, try increasing the snap argument. #> Warning: neighbour object has 3 sub-graphs; #> if this sub-graph count seems unexpected, try increasing the snap argument. #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.579342  #> Average number of links: 4.693878  #> 1 region with no links: #> 21 #> 3 disjoint connected subgraphs lw <- nb2listw(nb, style=\"B\", zero.policy=TRUE) joincount.multi(HICRIME, lw) #>           Joincount Expected Variance z-value #> low:low      35.000   30.585   19.350  1.0036 #> high:high    52.000   28.138   18.342  5.5716 #> high:low     28.000   61.170   25.882 -6.5200 #> Jtot         28.000   61.170   33.190 -5.7577 # \\dontrun{ data(oldcol) HICRIME <- cut(COL.OLD$CRIME, breaks=c(0,35,80), labels=c(\"low\",\"high\")) names(HICRIME) <- rownames(COL.OLD) joincount.multi(HICRIME, nb2listw(COL.nb, style=\"B\")) #>           Joincount Expected Variance z-value #> low:low      34.000   29.592   18.895  1.0141 #> high:high    54.000   27.224   17.888  6.3307 #> high:low     28.000   59.184   26.233 -6.0884 #> Jtot         28.000   59.184   26.233 -6.0884 data(hopkins, package=\"spData\") image(1:32, 1:32, hopkins[5:36,36:5], breaks=c(-0.5, 3.5, 20),  col=c(\"white\", \"black\")) box()  hopkins.rook.nb <- cell2nb(32, 32, type=\"rook\") unlist(spweights.constants(nb2listw(hopkins.rook.nb, style=\"B\"))) #>       n      n1      n2      n3      nn      S0      S1      S2  #>    1024    1023    1022    1021 1048576    3968    7936   61984  hopkins.queen.nb <- cell2nb(32, 32, type=\"queen\") hopkins.bishop.nb <- diffnb(hopkins.rook.nb, hopkins.queen.nb, verbose=FALSE) #> Warning: neighbour object has 2 sub-graphs hopkins4 <- hopkins[5:36,36:5] hopkins4[which(hopkins4 > 3, arr.ind=TRUE)] <- 4 hopkins4.f <- factor(hopkins4) table(hopkins4.f) #> hopkins4.f #>   0   1   2   3   4  #> 657 215  98  30  24  joincount.multi(hopkins4.f, nb2listw(hopkins.rook.nb, style=\"B\")) #>       Joincount   Expected   Variance z-value #> 0:0   864.00000  816.27273  116.05233  4.4304 #> 1:1    94.00000   87.14015   55.25216  0.9229 #> 2:2    18.00000   18.00379   14.81562 -0.0010 #> 3:3     2.00000    1.64773    1.55539  0.2825 #> 4:4     5.00000    1.04545    0.99845  3.9576 #> 1:0   503.00000  535.05682  227.76750 -2.1241 #> 2:0   213.00000  243.88636   97.21769 -3.1325 #> 2:1    99.00000   79.81061   59.01930  2.4978 #> 3:0    61.00000   74.65909   28.58592 -2.5547 #> 3:1    28.00000   24.43182   18.99976  0.8186 #> 3:2    15.00000   11.13636    9.82411  1.2327 #> 4:0    40.00000   59.72727   22.78583 -4.1327 #> 4:1    23.00000   19.54545   15.26564  0.8842 #> 4:2    14.00000    8.90909    7.90051  1.8112 #> 4:3     5.00000    2.72727    2.58616  1.4133 #> Jtot 1001.00000 1059.89015  273.78610 -3.5591 cat(\"replicates Upton & Fingleton table 3.4 (p. 166)\\n\") #> replicates Upton & Fingleton table 3.4 (p. 166) joincount.multi(hopkins4.f, nb2listw(hopkins.bishop.nb, style=\"B\")) #>       Joincount   Expected   Variance z-value #> 0:0   823.00000  790.76420  144.44877  2.6821 #> 1:1   101.00000   84.41702   55.98143  2.2164 #> 2:2    19.00000   17.44117   14.61542  0.4077 #> 3:3     3.00000    1.59624    1.51444  1.1407 #> 4:4     3.00000    1.01278    0.97111  2.0166 #> 1:0   497.00000  518.33629  234.93545 -1.3920 #> 2:0   216.00000  236.26491  104.42142 -1.9831 #> 2:1    81.00000   77.31652   58.70829  0.4807 #> 3:0    58.00000   72.32599   31.49151 -2.5529 #> 3:1    21.00000   23.66832   18.85316 -0.6145 #> 3:2    17.00000   10.78835    9.62487  2.0022 #> 4:0    48.00000   57.86080   25.15973 -1.9659 #> 4:1    21.00000   18.93466   15.14473  0.5307 #> 4:2    10.00000    8.63068    7.73708  0.4923 #> 4:3     4.00000    2.64205    2.51686  0.8560 #> Jtot  973.00000 1026.76858  284.51030 -3.1877 cat(\"replicates Upton & Fingleton table 3.6 (p. 168)\\n\") #> replicates Upton & Fingleton table 3.6 (p. 168) joincount.multi(hopkins4.f, nb2listw(hopkins.queen.nb, style=\"B\")) #>      Joincount  Expected  Variance z-value #> 0:0  1687.0000 1607.0369  303.8034  4.5877 #> 1:1   195.0000  171.5572  114.2057  2.1936 #> 2:2    37.0000   35.4450   29.6821  0.2854 #> 3:3     5.0000    3.2440    3.0687  1.0024 #> 4:4     8.0000    2.0582    1.9674  4.2361 #> 1:0  1000.0000 1053.3931  480.6959 -2.4353 #> 2:0   429.0000  480.1513  215.0360 -3.4882 #> 2:1   180.0000  157.1271  119.3987  2.0932 #> 3:0   119.0000  146.9851   65.1029 -3.4684 #> 3:1    49.0000   48.1001   38.3268  0.1454 #> 3:2    32.0000   21.9247   19.5237  2.2802 #> 4:0    88.0000  117.5881   52.0312 -4.1019 #> 4:1    44.0000   38.4801   30.7868  0.9948 #> 4:2    24.0000   17.5398   15.6933  1.6308 #> 4:3     9.0000    5.3693    5.0994  1.6078 #> Jtot 1974.0000 2086.6587  582.8326 -4.6665 cat(\"replicates Upton & Fingleton table 3.7 (p. 169)\\n\") #> replicates Upton & Fingleton table 3.7 (p. 169) # } GDAL37 <- as.numeric_version(unname(sf_extSoftVersion()[\"GDAL\"])) >= \"3.7.0\" file <- \"etc/shapes/GB_2024_southcoast_50m.gpkg.zip\" zipfile <- system.file(file, package=\"spdep\") if (GDAL37) {     sc50m <- st_read(zipfile) } else {     td <- tempdir()     bn <- sub(\".zip\", \"\", basename(file), fixed=TRUE)     target <- unzip(zipfile, files=bn, exdir=td)     sc50m <- st_read(target) } #> Reading layer `GB_2024_southcoast_50m' from data source  #>   `/tmp/RtmpqhccSk/temp_libpath108a2257736002/spdep/etc/shapes/GB_2024_southcoast_50m.gpkg.zip'  #>   using driver `GPKG' #> Simple feature collection with 119 features and 19 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 82643.12 ymin: 5342.9 xmax: 640301.6 ymax: 187226.2 #> Projected CRS: OSGB36 / British National Grid sc50m$Winner <- factor(sc50m$Winner, levels=c(\"Con\", \"Green\", \"Lab\", \"LD\")) plot(sc50m[,\"Winner\"], pal=c(\"#2297E6\", \"#61D04F\", \"#DF536B\", \"#F5C710\"))  nb_sc_50m <- poly2nb(sc50m, row.names=as.character(sc50m$Constituency)) #> Warning: neighbour object has 2 sub-graphs; #> if this sub-graph count seems unexpected, try increasing the snap argument. sub2 <- attr(nb_sc_50m, \"region.id\")[attr(nb_sc_50m, \"ncomp\")$comp.id == 2L] iowe <- match(sub2[1], attr(nb_sc_50m, \"region.id\")) diowe <- c(st_distance(sc50m[iowe,], sc50m)) meet_criterion <- sum(diowe <= units::set_units(5000, \"m\")) cands <- attr(nb_sc_50m, \"region.id\")[order(diowe)[1:meet_criterion]] nb_sc_50m_iowe <- addlinks1(nb_sc_50m, from = cands[1],  to = cands[3:meet_criterion]) ioww <- match(sub2[2], attr(nb_sc_50m, \"region.id\")) dioww <- c(st_distance(sc50m[ioww,], sc50m)) meet_criterion <- sum(dioww <= units::set_units(5000, \"m\")) cands <- attr(nb_sc_50m, \"region.id\")[order(dioww)[1:meet_criterion]] nb_sc_50m_iow <- addlinks1(nb_sc_50m_iowe, from = cands[2], to = cands[3:meet_criterion]) nb_sc_1_2 <- nblag_cumul(nblag(nb_sc_50m_iow, 2)) joincount.multi(sc50m$Winner, nb2listw(nb_sc_1_2, style=\"B\")) #>             Joincount Expected Variance z-value #> Con:Con      146.0000  84.4324 116.3530  5.7077 #> Green:Green    0.0000   0.0000   0.0000     NaN #> Lab:Lab       63.0000  98.1057 136.0379 -3.0099 #> LD:LD        100.0000  75.8866 103.9440  2.3651 #> Green:Con      4.0000   4.4438   5.8532 -0.1834 #> Lab:Con      184.0000 186.6401 180.9233 -0.1963 #> Lab:Green      3.0000   4.7856   6.4663 -0.7022 #> LD:Con       198.0000 164.4210 166.3583  2.6034 #> LD:Green       4.0000   4.2159   5.4573 -0.0924 #> LD:Lab        98.0000 177.0688 175.2035 -5.9736 #> Jtot         491.0000 541.5753 153.6123 -4.0806"},{"path":"https://r-spatial.github.io/spdep/reference/joincount.test.html","id":null,"dir":"Reference","previous_headings":"","what":"BB join count statistic for k-coloured factors — joincount.test","title":"BB join count statistic for k-coloured factors — joincount.test","text":"BB join count test spatial autocorrelation using spatial weights matrix weights list form testing whether -colour joins occur frequently expected zones labelled spatially random way. assumptions underlying test sensitive form graph neighbour relationships factors, results may checked joincount.mc permutations.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/joincount.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BB join count statistic for k-coloured factors — joincount.test","text":"","code":"joincount.test(fx, listw, zero.policy=attr(listw, \"zero.policy\"), alternative=\"greater\",  sampling=\"nonfree\", spChk=NULL, adjust.n=TRUE) # S3 method for class 'jclist' print(x, ...)"},{"path":"https://r-spatial.github.io/spdep/reference/joincount.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BB join count statistic for k-coloured factors — joincount.test","text":"fx factor length neighbours weights objects listw listw listw object created example nb2listw zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA alternative character string specifying alternative hypothesis, must one \"greater\" (default), \"less\" \"two.sided\". sampling default “nonfree”, may “free” adjust.n default TRUE, FALSE number observations adjusted -neighbour observations, TRUE, number observations adjusted consistently (including spdep 0.3-28 adjustment inconsistent - thanks Tomoki NAKAYA careful bug report) spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() x object printed ... arguments passed printing","code":""},{"path":"https://r-spatial.github.io/spdep/reference/joincount.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"BB join count statistic for k-coloured factors — joincount.test","text":"list class jclist lists class htest k colours containing following components: statistic value standard deviate join count statistic. p.value p-value test. estimate value observed statistic, expectation variance non-free sampling. alternative character string describing alternative hypothesis. method character string giving method used. data.name character string giving name(s) data.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/joincount.test.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"BB join count statistic for k-coloured factors — joincount.test","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, pp. 19-20.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/joincount.test.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"BB join count statistic for k-coloured factors — joincount.test","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/joincount.test.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"BB join count statistic for k-coloured factors — joincount.test","text":"derivation test (Cliff Ord, 1981, p. 18) assumes weights matrix symmetric. inherently non-symmetric matrices, k-nearest neighbour matrices, listw2U() can used make matrix symmetric. non-symmetric weights matrix cases, variance test statistic may negative.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/joincount.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"BB join count statistic for k-coloured factors — joincount.test","text":"","code":"data(oldcol) HICRIME <- cut(COL.OLD$CRIME, breaks=c(0,35,80), labels=c(\"low\",\"high\")) names(HICRIME) <- rownames(COL.OLD) joincount.test(HICRIME, nb2listw(COL.nb, style=\"B\")) #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: nb2listw(COL.nb, style = \"B\")  #>  #> Std. deviate for low = 1.0141, p-value = 0.1553 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>              34.00000              29.59184              18.89550  #>  #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: nb2listw(COL.nb, style = \"B\")  #>  #> Std. deviate for high = 6.3307, p-value = 1.22e-10 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>              54.00000              27.22449              17.88838  #>  joincount.test(HICRIME, nb2listw(COL.nb, style=\"B\"), sampling=\"free\") #>  #> \tJoin count test under free sampling #>  #> data:  HICRIME  #> weights: nb2listw(COL.nb, style = \"B\")  #>  #> Std. deviate for low = 0.3993, p-value = 0.3448 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>              34.00000              30.19575              90.76809  #>  #>  #> \tJoin count test under free sampling #>  #> data:  HICRIME  #> weights: nb2listw(COL.nb, style = \"B\")  #>  #> Std. deviate for high = 2.8518, p-value = 0.002173 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>               54.0000               27.8284               84.2198  #>  joincount.test(HICRIME, nb2listw(COL.nb, style=\"C\")) #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: nb2listw(COL.nb, style = \"C\")  #>  #> Std. deviate for low = 1.0141, p-value = 0.1553 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>             7.1810345             6.2500000             0.8428969  #>  #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: nb2listw(COL.nb, style = \"C\")  #>  #> Std. deviate for high = 6.3307, p-value = 1.22e-10 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>            11.4051724             5.7500000             0.7979712  #>  joincount.test(HICRIME, nb2listw(COL.nb, style=\"S\")) #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: nb2listw(COL.nb, style = \"S\")  #>  #> Std. deviate for low = 2.5786, p-value = 0.00496 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>             8.2425673             6.2500000             0.5971141  #>  #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: nb2listw(COL.nb, style = \"S\")  #>  #> Std. deviate for high = 6.1736, p-value = 3.337e-10 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>            10.4249914             5.7500000             0.5734265  #>  joincount.test(HICRIME, nb2listw(COL.nb, style=\"W\")) #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: nb2listw(COL.nb, style = \"W\")  #>  #> Std. deviate for low = 4.6675, p-value = 1.524e-06 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>             9.5190476             6.2500000             0.4905378  #>  #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: nb2listw(COL.nb, style = \"W\")  #>  #> Std. deviate for high = 5.1205, p-value = 1.523e-07 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>             9.2920635             5.7500000             0.4784979  #>  by(card(COL.nb), HICRIME, summary) #> HICRIME: low #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>    2.00    2.00    4.00    3.84    4.00   10.00  #> ------------------------------------------------------------  #> HICRIME: high #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   3.000   4.750   6.000   5.667   7.000   9.000  print(is.symmetric.nb(COL.nb)) #> [1] TRUE coords.OLD <- cbind(COL.OLD$X, COL.OLD$Y) COL.k4.nb <- knn2nb(knearneigh(coords.OLD, 4)) print(is.symmetric.nb(COL.k4.nb)) #> [1] FALSE joincount.test(HICRIME, nb2listw(COL.k4.nb, style=\"B\")) #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: nb2listw(COL.k4.nb, style = \"B\")  #>  #> Std. deviate for low = 4.3698, p-value = 6.217e-06 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>             36.500000             25.000000              6.925749  #>  #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: nb2listw(COL.k4.nb, style = \"B\")  #>  #> Std. deviate for high = 6.7293, p-value = 8.523e-12 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>             40.500000             23.000000              6.762918  #>  cat(\"Note non-symmetric weights matrix - use listw2U()\\n\") #> Note non-symmetric weights matrix - use listw2U() joincount.test(HICRIME, listw2U(nb2listw(COL.k4.nb, style=\"B\"))) #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: listw2U(nb2listw(COL.k4.nb, style = \"B\"))  #>  #> Std. deviate for low = 4.3698, p-value = 6.217e-06 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>             36.500000             25.000000              6.925749  #>  #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: listw2U(nb2listw(COL.k4.nb, style = \"B\"))  #>  #> Std. deviate for high = 6.7293, p-value = 8.523e-12 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>             40.500000             23.000000              6.762918  #>  columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) HICRIME <- cut(columbus$CRIME, breaks=c(0,35,80), labels=c(\"low\",\"high\")) (nb <- poly2nb(columbus)) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 236  #> Percentage nonzero weights: 9.829238  #> Average number of links: 4.816327  lw <- nb2listw(nb, style=\"B\") joincount.test(HICRIME, lw) #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: lw  #>  #> Std. deviate for low = 1.1164, p-value = 0.1321 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>              35.00000              30.10204              19.24708  #>  #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: lw  #>  #> Std. deviate for high = 6.163, p-value = 3.57e-10 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>              54.00000              27.69388              18.21936  #>  col_geoms <- st_geometry(columbus) col_geoms[21] <- st_buffer(col_geoms[21], dist=-0.05) st_geometry(columbus) <- col_geoms (nb <- poly2nb(columbus)) #> Warning: some observations have no neighbours; #> if this seems unexpected, try increasing the snap argument. #> Warning: neighbour object has 3 sub-graphs; #> if this sub-graph count seems unexpected, try increasing the snap argument. #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.579342  #> Average number of links: 4.693878  #> 1 region with no links: #> 21 #> 3 disjoint connected subgraphs lw <- nb2listw(nb, style=\"B\", zero.policy=TRUE) joincount.test(HICRIME, lw) #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: lw  #>  #> Std. deviate for low = 1.0036, p-value = 0.1578 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>              35.00000              30.58511              19.35032  #>  #>  #> \tJoin count test under nonfree sampling #>  #> data:  HICRIME  #> weights: lw  #>  #> Std. deviate for high = 5.5716, p-value = 1.262e-08 #> alternative hypothesis: greater #> sample estimates: #> Same colour statistic           Expectation              Variance  #>              52.00000              28.13830              18.34187  #>"},{"path":"https://r-spatial.github.io/spdep/reference/knearneigh.html","id":null,"dir":"Reference","previous_headings":"","what":"K nearest neighbours for spatial weights — knearneigh","title":"K nearest neighbours for spatial weights — knearneigh","text":"function returns matrix indices points belonging set k nearest neighbours . longlat = TRUE, Great Circle distances used. warning given identical points found.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/knearneigh.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"K nearest neighbours for spatial weights — knearneigh","text":"","code":"knearneigh(x, k=1, longlat = NULL, use_kd_tree=TRUE)"},{"path":"https://r-spatial.github.io/spdep/reference/knearneigh.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"K nearest neighbours for spatial weights — knearneigh","text":"x matrix point coordinates, object inheriting SpatialPoints \"sf\" \"sfc\" object; \"sf\" \"sfc\" object geometries geographical coordinates (sf::st_is_longlat(x) == TRUE sf::sf_use_s2() == TRUE), s2 used find neighbours uses spatial indexing https://github.com/r-spatial/s2/issues/125 opposed legacy method uses brute-force k number nearest neighbours returned; identical points present, k least large largest count identical points (k smaller, error occur s2 used) longlat TRUE point coordinates longitude-latitude decimal degrees, case distances measured kilometers; x SpatialPoints object, value taken object ; longlat override kd_tree use_kd_tree logical value, dbscan package available, use finding k nearest neighbours longlat FALSE, identical points; https://github.com/r-spatial/spdep/issues/38, input data may two columns dbscan used","code":""},{"path":"https://r-spatial.github.io/spdep/reference/knearneigh.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"K nearest neighbours for spatial weights — knearneigh","text":"underlying legacy C code based knn function class package.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/knearneigh.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"K nearest neighbours for spatial weights — knearneigh","text":"list class knn nn integer matrix region number ids np number input points k input required k dimension number columns x x input coordinates","code":""},{"path":"https://r-spatial.github.io/spdep/reference/knearneigh.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"K nearest neighbours for spatial weights — knearneigh","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/knearneigh.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"K nearest neighbours for spatial weights — knearneigh","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) coords <- st_centroid(st_geometry(columbus), of_largest_polygon=TRUE) col.knn <- knearneigh(coords, k=4) plot(st_geometry(columbus), border=\"grey\") plot(knn2nb(col.knn), coords, add=TRUE) title(main=\"K nearest neighbours, k = 4\")  data(state) us48.fipsno <- read.geoda(system.file(\"etc/weights/us48.txt\",  package=\"spdep\")[1]) if (as.numeric(paste(version$major, version$minor, sep=\"\")) < 19) {  m50.48 <- match(us48.fipsno$\"State.name\", state.name) } else {  m50.48 <- match(us48.fipsno$\"State_name\", state.name) } xy <- as.matrix(as.data.frame(state.center))[m50.48,] llk4.nb <- knn2nb(knearneigh(xy, k=4, longlat=FALSE)) gck4.nb <- knn2nb(knearneigh(xy, k=4, longlat=TRUE)) plot(llk4.nb, xy) plot(diffnb(llk4.nb, gck4.nb), xy, add=TRUE, col=\"red\", lty=2) #> Warning: neighbour object has 22 sub-graphs title(main=\"Differences between Euclidean and Great Circle k=4 neighbours\")  summary(llk4.nb, xy, longlat=TRUE, scale=0.5) #> Neighbour list object: #> Number of regions: 48  #> Number of nonzero links: 192  #> Percentage nonzero weights: 8.333333  #> Average number of links: 4  #> Non-symmetric neighbours list #> Link number distribution: #>  #>  4  #> 48  #> 48 least connected regions: #> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 with 4 links #> 48 most connected regions: #> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 with 4 links summary(gck4.nb, xy, longlat=TRUE, scale=0.5) #> Neighbour list object: #> Number of regions: 48  #> Number of nonzero links: 192  #> Percentage nonzero weights: 8.333333  #> Average number of links: 4  #> Non-symmetric neighbours list #> Link number distribution: #>  #>  4  #> 48  #> 48 least connected regions: #> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 with 4 links #> 48 most connected regions: #> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 with 4 links  #xy1 <- SpatialPoints((as.data.frame(state.center))[m50.48,], #  proj4string=CRS(\"+proj=longlat +ellps=GRS80\")) #gck4a.nb <- knn2nb(knearneigh(xy1, k=4)) #summary(gck4a.nb, xy1, scale=0.5)  xy1 <- st_as_sf((as.data.frame(state.center))[m50.48,], coords=1:2,   crs=st_crs(\"OGC:CRS84\")) old_use_s2 <- sf_use_s2() sf_use_s2(TRUE) system.time(gck4a.nb <- knn2nb(knearneigh(xy1, k=4))) #>    user  system elapsed  #>   0.011   0.000   0.011  summary(gck4a.nb, xy1, scale=0.5) #> Neighbour list object: #> Number of regions: 48  #> Number of nonzero links: 192  #> Percentage nonzero weights: 8.333333  #> Average number of links: 4  #> Non-symmetric neighbours list #> Link number distribution: #>  #>  4  #> 48  #> 48 least connected regions: #> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 with 4 links #> 48 most connected regions: #> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 with 4 links sf_use_s2(FALSE) #> Spherical geometry (s2) switched off system.time(gck4a.nb <- knn2nb(knearneigh(xy1, k=4))) #>    user  system elapsed  #>   0.008   0.000   0.008  summary(gck4a.nb, xy1, scale=0.5) #> Neighbour list object: #> Number of regions: 48  #> Number of nonzero links: 192  #> Percentage nonzero weights: 8.333333  #> Average number of links: 4  #> Non-symmetric neighbours list #> Link number distribution: #>  #>  4  #> 48  #> 48 least connected regions: #> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 with 4 links #> 48 most connected regions: #> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 with 4 links sf_use_s2(old_use_s2) #> Spherical geometry (s2) switched on  # https://github.com/r-spatial/spdep/issues/38 if (require(\"dbscan\", quietly=TRUE)) {   set.seed(1)   x <- cbind(runif(50), runif(50), runif(50))   out <- knearneigh(x, k=5)   knn2nb(out)   try(out <- knearneigh(rbind(x, x[1:10,]), k=5)) } #> Warning: knearneigh: identical points found #> Warning: knearneigh: kd_tree not available for identical points #> Error in knearneigh(rbind(x, x[1:10, ]), k = 5) :  #>   kd_tree required for more than 2 dimensions"},{"path":"https://r-spatial.github.io/spdep/reference/knn2nb.html","id":null,"dir":"Reference","previous_headings":"","what":"Neighbours list from knn object — knn2nb","title":"Neighbours list from knn object — knn2nb","text":"function converts knn object returned knearneigh neighbours list class nb list integer vectors containing neighbour region number ids.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/knn2nb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Neighbours list from knn object — knn2nb","text":"","code":"knn2nb(knn, row.names = NULL, sym = FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/knn2nb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Neighbours list from knn object — knn2nb","text":"knn knn object returned knearneigh row.names character vector region ids added neighbours list attribute region.id, default seq(1, nrow(x)) sym force output neighbours list symmetry","code":""},{"path":"https://r-spatial.github.io/spdep/reference/knn2nb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Neighbours list from knn object — knn2nb","text":"function returns object class nb list integer vectors containing neighbour region number ids. See card details “nb” objects.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/knn2nb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Neighbours list from knn object — knn2nb","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/knn2nb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Neighbours list from knn object — knn2nb","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) coords <- st_coordinates(st_centroid(columbus)) #> Warning: st_centroid assumes attributes are constant over geometries col.knn <- knearneigh(coords, k=4) plot(st_geometry(columbus), border=\"grey\") plot(knn2nb(col.knn), coords, add=TRUE) title(main=\"K nearest neighbours, k = 4\")  # example of reading points with readr::read_csv() yielding a tibble load(system.file(\"etc/misc/coords.rda\", package=\"spdep\")) class(coords) #> [1] \"spec_tbl_df\" \"tbl_df\"      \"tbl\"         \"data.frame\"  knn2nb(knearneigh(coords, k=4)) #> Neighbour list object: #> Number of regions: 100  #> Number of nonzero links: 400  #> Percentage nonzero weights: 4  #> Average number of links: 4  #> Non-symmetric neighbours list"},{"path":"https://r-spatial.github.io/spdep/reference/lag.listw.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial lag of a numeric vector — lag.listw","title":"Spatial lag of a numeric vector — lag.listw","text":"Using listw sparse representation spatial weights matrix, compute lag vector \\(V x\\)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lag.listw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial lag of a numeric vector — lag.listw","text":"","code":"# S3 method for class 'listw' lag(x, var, zero.policy=attr(listw, \"zero.policy\"), NAOK=FALSE, ...)"},{"path":"https://r-spatial.github.io/spdep/reference/lag.listw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial lag of a numeric vector — lag.listw","text":"x listw object created example nb2listw var numeric vector length neighbours list listw zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA NAOK 'FALSE', presence 'NA' values regarded error; 'TRUE' 'NA' 'NaN' 'Inf' values var represented NA lagged value. ... additional arguments","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lag.listw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial lag of a numeric vector — lag.listw","text":"numeric vector length var","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lag.listw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial lag of a numeric vector — lag.listw","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/lag.listw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial lag of a numeric vector — lag.listw","text":"","code":"data(oldcol) Vx <- lag.listw(nb2listw(COL.nb, style=\"W\"), COL.OLD$CRIME) plot(Vx, COL.OLD$CRIME)  plot(ecdf(COL.OLD$CRIME)) plot(ecdf(Vx), add=TRUE, col.points=\"red\", col.hor=\"red\")  is.na(COL.OLD$CRIME[5]) <- TRUE VxNA <- lag.listw(nb2listw(COL.nb, style=\"W\"), COL.OLD$CRIME, NAOK=TRUE) #> Warning: NAs in lagged values"},{"path":"https://r-spatial.github.io/spdep/reference/lee.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Lee's statistic — lee","title":"Compute Lee's statistic — lee","text":"simple function compute Lee's L statistic bivariate spatial data;  $$L(x,y) = \\frac{n}{\\sum_{=1}^{n}(\\sum_{j=1}^{n}w_{ij})^2} \\frac{\\sum_{=1}^{n}(\\sum_{j=1}^{n}w_{ij}(x_i-\\bar{x})) ((\\sum_{j=1}^{n}w_{ij}(y_j-\\bar{y}))}{\\sqrt{\\sum_{=1}^{n}(x_i - \\bar{x})^2} \\sqrt{\\sum_{=1}^{n}(y_i - \\bar{y})^2}} $$","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lee.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Lee's statistic — lee","text":"","code":"lee(x, y, listw, n, S2, zero.policy=attr(listw, \"zero.policy\"), NAOK=FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/lee.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Lee's statistic — lee","text":"x numeric vector length neighbours list listw y numeric vector length neighbours list listw listw listw object created example nb2listw n number zones S2 Sum squared sum weights rows. zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA NAOK 'TRUE' 'NA' 'NaN' 'Inf' values x passed foreign function.  'FALSE', presence 'NA' 'NaN' 'Inf' values regarded error.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lee.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Lee's statistic — lee","text":"list L Lee's L statistic local L Lee's local L statistic","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lee.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute Lee's statistic — lee","text":"Lee (2001). Developing bivariate spatial association measure: integration Pearson's r Moran's . J Geograph Syst  3: 369-385","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lee.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute Lee's statistic — lee","text":"Roger Bivand Virgiio GÃ³mez-Rubio Virgilio.Gomez@uclm.es","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/lee.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Lee's statistic — lee","text":"","code":"data(boston, package=\"spData\") lw<-nb2listw(boston.soi)  x<-boston.c$CMEDV y<-boston.c$CRIM z<-boston.c$RAD  Lxy<-lee(x, y, lw, length(x), zero.policy=TRUE) Lxz<-lee(x, z, lw, length(x), zero.policy=TRUE)"},{"path":"https://r-spatial.github.io/spdep/reference/lee.mc.html","id":null,"dir":"Reference","previous_headings":"","what":"Permutation test for Lee's L statistic — lee.mc","title":"Permutation test for Lee's L statistic — lee.mc","text":"permutation test Lee's L  statistic calculated using nsim random permutations x y given spatial weighting scheme, establish rank observed statistic relation nsim simulated values.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lee.mc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permutation test for Lee's L statistic — lee.mc","text":"","code":"lee.mc(x, y, listw, nsim, zero.policy=attr(listw, \"zero.policy\"), alternative=\"greater\",  na.action=na.fail, spChk=NULL, return_boot=FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/lee.mc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permutation test for Lee's L statistic — lee.mc","text":"x numeric vector length neighbours list listw y numeric vector length neighbours list listw listw listw object created example nb2listw nsim number permutations zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA alternative character string specifying alternative hypothesis, must one \"greater\" (default), \"two.sided\", \"less\". na.action function (default na.fail), can also na.omit na.exclude - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. na.pass permitted meaningless permutation test. spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() return_boot return object class boot equivalent permutation bootstrap rather object class htest","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lee.mc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permutation test for Lee's L statistic — lee.mc","text":"list class htest mc.sim containing following components: statistic value observed Lee's L. parameter rank observed Lee's L. p.value pseudo p-value test. alternative character string describing alternative hypothesis. method character string giving method used. data.name character string giving name(s) data, number simulations. res nsim simulated values statistic, final value observed statistic","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lee.mc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Permutation test for Lee's L statistic — lee.mc","text":"Lee (2001). Developing bivariate spatial association measure: integration Pearson's r Moran's . J Geograph Syst  3: 369-385","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lee.mc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Permutation test for Lee's L statistic — lee.mc","text":"Roger Bivand, Virgilio GÃ³mez-Rubio Virgilio.Gomez@uclm.es","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/lee.mc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Permutation test for Lee's L statistic — lee.mc","text":"","code":"data(boston, package=\"spData\") lw<-nb2listw(boston.soi)  x<-boston.c$CMEDV y<-boston.c$CRIM  lee.mc(x, y, nsim=99, lw, zero.policy=TRUE, alternative=\"two.sided\") #>  #> \tMonte-Carlo simulation of Lee's L #>  #> data:  x ,  y  #> weights: lw   #> number of simulations + 1: 100  #>  #> statistic = -0.3263, observed rank = 1, p-value = 0.02 #> alternative hypothesis: two.sided #>   #Test with missing values x[1:5]<-NA y[3:7]<-NA  lee.mc(x, y, nsim=99, lw, zero.policy=TRUE, alternative=\"two.sided\",     na.action=na.omit) #>  #> \tMonte-Carlo simulation of Lee's L #>  #> data:  x ,  y  #> weights: lw  #> omitted: 1, 2, 3, 4, 5, 6, 7  #> number of simulations + 1: 100  #>  #> statistic = -0.32447, observed rank = 1, p-value = 0.02 #> alternative hypothesis: two.sided #>"},{"path":"https://r-spatial.github.io/spdep/reference/lee.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Lee's L test for spatial autocorrelation — lee.test","title":"Lee's L test for spatial autocorrelation — lee.test","text":"Lee's L test spatial autocorrelation using spatial weights matrix weights list form. assumptions underlying test sensitive form graph neighbour relationships factors, results may checked lee.mc permutations.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lee.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lee's L test for spatial autocorrelation — lee.test","text":"","code":"lee.test(x, y, listw, zero.policy=attr(listw, \"zero.policy\"),  alternative=\"greater\", na.action=na.fail, spChk=NULL)"},{"path":"https://r-spatial.github.io/spdep/reference/lee.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lee's L test for spatial autocorrelation — lee.test","text":"x numeric vector length neighbours list listw y numeric vector length neighbours list listw listw listw object created example nb2listw  zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA alternative character string specifying alternative hypothesis, must one greater (default), less two.sided.  na.action function (default na.fail), can also na.omit na.exclude - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. na.pass used, zero substituted NA values calculating spatial lag spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption()","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lee.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lee's L test for spatial autocorrelation — lee.test","text":"list class htest containing following components: statistic value standard deviate Lee's L. p.value p-value test. estimate value observed Lee's L, expectation variance method assumption. alternative character string describing alternative hypothesis. method character string giving assumption used calculating standard deviate. data.name character string giving name(s) data.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lee.test.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Lee's L test for spatial autocorrelation — lee.test","text":"See Lee (2004) details asymptotic expectation variance Lee's L computed. particular, check Lee (2004), table 1, page 1690. test may fail large datasets computation asymptotic expectation variance requires use dense matrices.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lee.test.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Lee's L test for spatial autocorrelation — lee.test","text":"Lee (2004). generalized significance testing method global measures spatial association: extension Mantel test.  Environment Planning 2004, volume 36, pages 1687 - 1703","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lee.test.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Lee's L test for spatial autocorrelation — lee.test","text":"Roger Bivand Virgilio GÃ³mez-Rubio Virgilio.Gomez@uclm.es","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/lee.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lee's L test for spatial autocorrelation — lee.test","text":"","code":"data(oldcol) col.W <- nb2listw(COL.nb, style=\"W\") crime <- COL.OLD$CRIME  lee.test(crime, crime, col.W, zero.policy=TRUE) #>  #> \tLee's L statistic randomisation #>  #> data:  crime ,  crime  #> weights: col.W   #>  #> Lee's L statistic standard deviate = 5.2343, p-value = 8.279e-08 #> alternative hypothesis: greater #> sample estimates: #> Lee's L statistic       Expectation          Variance  #>       0.547064219       0.239417989       0.003454459  #>   #Test with missing values x<-crime y<-crime x[1:5]<-NA y[3:7]<-NA  lee.test(x, y, col.W, zero.policy=TRUE, na.action=na.omit) #>  #> \tLee's L statistic randomisation #>  #> data:  x ,  y  #> weights: col.W  #> omitted: 1, 2, 3, 4, 5, 6, 7  #>  #> Lee's L statistic standard deviate = 6.6873, p-value = 1.137e-11 #> alternative hypothesis: greater #> sample estimates: #> Lee's L statistic       Expectation          Variance  #>       0.706469726       0.260143244       0.004454563  #>  #  lee.test(x, y, col.W, zero.policy=TRUE)#Stops with an error    data(boston, package=\"spData\") lw<-nb2listw(boston.soi)  x<-boston.c$CMEDV y<-boston.c$CRIM  lee.test(x, y, lw, zero.policy=TRUE, alternative=\"less\") #>  #> \tLee's L statistic randomisation #>  #> data:  x ,  y  #> weights: lw   #>  #> Lee's L statistic standard deviate = -11.54, p-value < 2.2e-16 #> alternative hypothesis: less #> sample estimates: #> Lee's L statistic       Expectation          Variance  #>      -0.326297206      -0.105040316       0.000367637  #>   #Test with missing values x[1:5]<-NA y[3:7]<-NA  lee.test(x, y, lw, zero.policy=TRUE, alternative=\"less\", na.action=na.omit) #>  #> \tLee's L statistic randomisation #>  #> data:  x ,  y  #> weights: lw  #> omitted: 1, 2, 3, 4, 5, 6, 7  #>  #> Lee's L statistic standard deviate = -11.284, p-value < 2.2e-16 #> alternative hypothesis: less #> sample estimates: #> Lee's L statistic       Expectation          Variance  #>     -0.3244748280     -0.1053154332      0.0003772109  #>"},{"path":"https://r-spatial.github.io/spdep/reference/licd_multi.html","id":null,"dir":"Reference","previous_headings":"","what":"Local Indicators for Categorical Data — licd_multi","title":"Local Indicators for Categorical Data — licd_multi","text":"Local indicators categorical data combine measure local composition window given per-observation set neighbouring observations, local multi-category joincount test simplified neighbours different categories compared focal observation","code":""},{"path":"https://r-spatial.github.io/spdep/reference/licd_multi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Local Indicators for Categorical Data — licd_multi","text":"","code":"licd_multi(fx, listw, zero.policy = attr(listw, \"zero.policy\"), adjust.n = TRUE,  nsim = 0L, iseed = NULL, no_repeat_in_row = FALSE, control = list())"},{"path":"https://r-spatial.github.io/spdep/reference/licd_multi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Local Indicators for Categorical Data — licd_multi","text":"fx factor two categories, length neighbours weights objects listw listw listw object created example nb2listw zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA adjust.n default TRUE, FALSE number observations adjusted -neighbour observations, TRUE, number observations adjusted nsim default 0, number conditonal permutation simulations iseed default NULL, used set seed; output reproducible count CPU cores across computation distributed no_repeat_in_row default FALSE, TRUE, sample conditionally row without replacements avoid duplicate values, https://github.com/r-spatial/spdep/issues/124 control comp_binary=TRUE, binomial_punif_alternative=\"greater\",         jcm_same_punif_alternative=\"less\", jcm_diff_punif_alternative=\"greater\"","code":""},{"path":"https://r-spatial.github.io/spdep/reference/licd_multi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Local Indicators for Categorical Data — licd_multi","text":"original code may found doi:10.5281/zenodo.4283766","code":""},{"path":"https://r-spatial.github.io/spdep/reference/licd_multi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Local Indicators for Categorical Data — licd_multi","text":"local_comp data.frame object LICD local composition columns: ID,     category_i, count_like_i, prop_i, count_nbs_i, pbinom_like_BW,     pbinom_unlike_BW, pbinom_unlike_BW_alt, chi_BW_i, chi_K_i, anscombe_BW local_config data.frame object LICD local configuration columns: ID, jcm_chi_obs, jcm_count_BB_obs, jcm_count_BW_obs, jcm_count_WW_obs, pval_jcm_obs_BB, pval_jcm_obs_WW, pval_jcm_obs_BW local_comp_sim data.frame object permutation-based LICD local composition columns: ID, pbinom_like_BW, pbinom_unlike_BW, pbinom_unlike_BW_alt, rank_sim_chi_BW, rank_sim_chi_K, rank_sim_anscombe local_config_sim data.frame object permutation-based LICD local configuration columns: ID, jcm_chi_sim_rank, pval_jcm_obs_BB_sim, pval_jcm_obs_BW_sim, pval_jcm_obs_WW_sim","code":""},{"path":"https://r-spatial.github.io/spdep/reference/licd_multi.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Local Indicators for Categorical Data — licd_multi","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, p. 20; Upton, G., Fingleton, B. 1985 Spatial data analysis example: point pattern qualitative data, Wiley, pp. 158–170; Boots, B., 2003. Developing local measures spatial association categorical data. Journal Geographical Systems 5, 139–160; Boots, B., 2006. Local configuration measures categorical spatial data: binary regular lattices. Journal Geographical Systems 8 (1), 1–24; Pietrzak, M.B., Wilk, J., Kossowski, T., Bivand, R.S., 2014. application local indicators categorical data (LICD) spatial analysis economic development. Comparative Economic Research 17 (4), 203–220 doi:10.2478/cer-2014-0041 ; Bivand, R.S., Wilk, J., Kossowski, T., 2017. Spatial association population pyramids across Europe: application symbolic data, cluster analysis join-count tests. Spatial Statistics 21 (B), 339–361 doi:10.1016/j.spasta.2017.03.003 ; Francesco Carrer, Tomasz M. Kossowski, Justyna Wilk, Michał B. Pietrzak, Roger S. Bivand, application Local Indicators Categorical Data (LICD) explore spatial dependence archaeological spaces, Journal Archaeological Science, 126, 2021, doi:10.1016/j.jas.2020.105306","code":""},{"path":"https://r-spatial.github.io/spdep/reference/licd_multi.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Local Indicators for Categorical Data — licd_multi","text":"Roger Bivand Roger.Bivand@nhh.based earlier code Tomasz M. Kossowski, Justyna Wilk Michał B. Pietrzak","code":""},{"path":"https://r-spatial.github.io/spdep/reference/licd_multi.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Local Indicators for Categorical Data — licd_multi","text":"order increase numbers neighbours using nblag nblag_cumul advisable; use binary weights advised case used composition measure","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/licd_multi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Local Indicators for Categorical Data — licd_multi","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) HICRIME <- cut(columbus$CRIME, breaks=c(0,35,80), labels=c(\"low\",\"high\")) (nb <- poly2nb(columbus)) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 236  #> Percentage nonzero weights: 9.829238  #> Average number of links: 4.816327  lw <- nb2listw(nblag_cumul(nblag(nb, 2)), style=\"B\") obj <- licd_multi(HICRIME, lw) str(obj) #> List of 4 #>  $ local_comp      :'data.frame':\t49 obs. of  11 variables: #>   ..$ ID                  : int [1:49] 1 2 3 4 5 6 7 8 9 10 ... #>   ..$ category_i          : num [1:49] 1 1 1 1 2 1 1 2 1 1 ... #>   ..$ count_like_i        : num [1:49] 4 4 6 7 12 7 2 8 10 8 ... #>   ..$ prop_i              : num [1:49] 0.51 0.51 0.51 0.51 0.49 ... #>   ..$ count_nbs_i         : num [1:49] 5 6 11 14 22 14 11 14 25 17 ... #>   ..$ pbinom_like_BW      : num [1:49] 0.965 0.881 0.702 0.575 0.769 ... #>   ..$ pbinom_unlike_BW    : num [1:49] 0.0346 0.1192 0.2979 0.4255 0.2313 ... #>   ..$ pbinom_unlike_BW_alt: num [1:49] 0.201 0.363 0.528 0.634 0.379 ... #>   ..$ chi_BW_i            : num [1:49] 1.68033 0.58778 0.0547 0.00583 0.27273 ... #>   ..$ chi_K_i             : num [1:49] 1.68033 0.58778 0.0547 0.00583 0.27273 ... #>   ..$ anscombe_BW         : num [1:49] 1.06 0.936 0.828 0.785 0.829 ... #>  $ local_config    :'data.frame':\t49 obs. of  8 variables: #>   ..$ ID              : int [1:49] 1 2 3 4 5 6 7 8 9 10 ... #>   ..$ jcm_chi_obs     : num [1:49] 0 0.0625 0.625 2.7468 14.1889 ... #>   ..$ jcm_count_BB_obs: num [1:49] 6 6 11 12 55 15 1 27 30 25 ... #>   ..$ jcm_count_BW_obs: num [1:49] 4 7 23 31 50 36 15 31 73 53 ... #>   ..$ jcm_count_WW_obs: num [1:49] 0 1 10 20 21 19 32 9 61 24 ... #>   ..$ pval_jcm_obs_BB : num [1:49] 1 0.207108 0.70232 0.820405 0.000214 ... #>   ..$ pval_jcm_obs_WW : num [1:49] 1 0.3946 0.0981 0.0243 0.7839 ... #>   ..$ pval_jcm_obs_BW : num [1:49] 1.00 1.75e-01 2.08e-01 5.10e-02 3.52e-06 ... #>  $ local_comp_sim  : NULL #>  $ local_config_sim: NULL #>  - attr(*, \"out\")= num [1:49, 1:29] 1 1 1 1 2 1 1 2 1 1 ... #>   ..- attr(*, \"ncpus\")= int 1 #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : NULL #>   .. ..$ : chr [1:29] \"category_i\" \"count_like_i\" \"prop_i\" \"count_nbs_i\" ... #>  - attr(*, \"ncpus\")= int 1 #>  - attr(*, \"nsim\")= int 0 #>  - attr(*, \"con\")=List of 4 #>   ..$ comp_binary               : logi TRUE #>   ..$ binomial_punif_alternative: chr \"greater\" #>   ..$ jcm_same_punif_alternative: chr \"less\" #>   ..$ jcm_diff_punif_alternative: chr \"greater\" #>  - attr(*, \"class\")= chr [1:2] \"licd\" \"list\" h_obj <- hotspot(obj) str(h_obj) #> List of 9 #>  $ ID              : int [1:49] 1 2 3 4 5 6 7 8 9 10 ... #>  $ local_comp      : Factor w/ 2 levels \"Cluster\",\"Dispersed\": 2 2 2 2 2 2 2 2 2 2 ... #>  $ local_comp_sim  : NULL #>  $ local_config    : Factor w/ 3 levels \"Cluster\",\"Dispersed\",..: 3 3 3 3 2 3 3 2 3 3 ... #>  $ local_config_sim: NULL #>  $ both            : Factor w/ 6 levels \"Cluster.Cluster\",..: 6 6 6 6 4 6 6 4 6 6 ... #>  $ both_sim        : NULL #>  $ both_recode     : Factor w/ 4 levels \"Clump\",\"Cluster\",..: 4 4 4 4 3 4 4 3 4 4 ... #>  $ both_recode_sim : NULL table(h_obj$both_recode) #>  #>      Clump    Cluster  Dispersed No cluster  #>          8          3         11         27  columbus$both <- h_obj$both_recode plot(columbus[, \"both\"])  GDAL37 <- as.numeric_version(unname(sf_extSoftVersion()[\"GDAL\"])) >= \"3.7.0\" file <- \"etc/shapes/GB_2024_southcoast_50m.gpkg.zip\" zipfile <- system.file(file, package=\"spdep\") if (GDAL37) {     sc50m <- st_read(zipfile) } else {     td <- tempdir()     bn <- sub(\".zip\", \"\", basename(file), fixed=TRUE)     target <- unzip(zipfile, files=bn, exdir=td)     sc50m <- st_read(target) } #> Reading layer `GB_2024_southcoast_50m' from data source  #>   `/tmp/RtmpqhccSk/temp_libpath108a2257736002/spdep/etc/shapes/GB_2024_southcoast_50m.gpkg.zip'  #>   using driver `GPKG' #> Simple feature collection with 119 features and 19 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 82643.12 ymin: 5342.9 xmax: 640301.6 ymax: 187226.2 #> Projected CRS: OSGB36 / British National Grid sc50m$Winner <- factor(sc50m$Winner, levels=c(\"Con\", \"Green\", \"Lab\", \"LD\")) plot(sc50m[,\"Winner\"], pal=c(\"#2297E6\", \"#61D04F\", \"#DF536B\", \"#F5C710\"))  nb_sc_50m <- poly2nb(sc50m, row.names=as.character(sc50m$Constituency)) #> Warning: neighbour object has 2 sub-graphs; #> if this sub-graph count seems unexpected, try increasing the snap argument. sub2 <- attr(nb_sc_50m, \"region.id\")[attr(nb_sc_50m, \"ncomp\")$comp.id == 2L] iowe <- match(sub2[1], attr(nb_sc_50m, \"region.id\")) diowe <- c(st_distance(sc50m[iowe,], sc50m)) meet_criterion <- sum(diowe <= units::set_units(5000, \"m\")) cands <- attr(nb_sc_50m, \"region.id\")[order(diowe)[1:meet_criterion]] nb_sc_50m_iowe <- addlinks1(nb_sc_50m, from = cands[1],  to = cands[3:meet_criterion]) ioww <- match(sub2[2], attr(nb_sc_50m, \"region.id\")) dioww <- c(st_distance(sc50m[ioww,], sc50m)) meet_criterion <- sum(dioww <= units::set_units(5000, \"m\")) cands <- attr(nb_sc_50m, \"region.id\")[order(dioww)[1:meet_criterion]] nb_sc_50m_iow <- addlinks1(nb_sc_50m_iowe, from = cands[2], to = cands[3:meet_criterion]) nb_sc_1_2 <- nblag_cumul(nblag(nb_sc_50m_iow, 2)) lw <- nb2listw(nb_sc_1_2, style=\"B\") licd_obj <- licd_multi(sc50m$Winner, lw) h_obj <- hotspot(licd_obj) sc50m$both <- h_obj$both_recode plot(sc50m[, \"both\"])  ljc <- local_joincount_uni(factor(sc50m$Winner == \"LD\"), chosen=\"TRUE\", lw) sc50m$LD_pv <- ljc[, 2] plot(sc50m[, \"LD_pv\"], breaks=c(0, 0.025, 0.05, 0.1, 0.5, 1))"},{"path":"https://r-spatial.github.io/spdep/reference/listw2sn.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial neighbour sparse representation — listw2sn","title":"Spatial neighbour sparse representation — listw2sn","text":"function makes \"spatial neighbour\" object representation (similar S-PLUS spatial statististics module representation \"listw\" spatial weights object. sn2listw() inverse function listw2sn(), creating \"listw\" object \"spatial neighbour\" object.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/listw2sn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial neighbour sparse representation — listw2sn","text":"","code":"listw2sn(listw) sn2listw(sn, style = NULL, zero.policy = NULL, from_mat2listw=FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/listw2sn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial neighbour sparse representation — listw2sn","text":"listw listw object example nb2listw sn spatial.neighbour object style default NULL, missing, set \"M\" warning given; \"M\", passed nb2listw re-build object zero.policy default NULL, use global option value; FALSE stop error empty neighbour sets, TRUE permit weights list formed zero-length weights vectors from_mat2listw default FALSE, set TRUE called mat2listw","code":""},{"path":"https://r-spatial.github.io/spdep/reference/listw2sn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial neighbour sparse representation — listw2sn","text":"listw2sn()returns data frame three columns, class spatial.neighbour: region number id start link (S-PLUS row.id) region number id end link (S-PLUS col.id) weights weight link","code":""},{"path":"https://r-spatial.github.io/spdep/reference/listw2sn.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial neighbour sparse representation — listw2sn","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/listw2sn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial neighbour sparse representation — listw2sn","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) col.listw <- nb2listw(col.gal.nb) col.listw$neighbours[[1]] #> [1] 2 3 col.listw$weights[[1]] #> [1] 0.5 0.5 col.sn <- listw2sn(col.listw) str(col.sn) #> Classes ‘spatial.neighbour’ and 'data.frame':\t230 obs. of  3 variables: #>  $ from   : int  1 1 2 2 2 3 3 3 3 4 ... #>  $ to     : int  2 3 1 3 4 1 2 4 5 2 ... #>  $ weights: num  0.5 0.5 0.333 0.333 0.333 ... #>  - attr(*, \"n\")= int 49 #>  - attr(*, \"region.id\")= chr [1:49] \"1\" \"2\" \"3\" \"4\" ... #>  - attr(*, \"neighbours.attrs\")= chr [1:7] \"class\" \"region.id\" \"GeoDa\" \"gal\" ... #>  - attr(*, \"weights.attrs\")= chr [1:3] \"mode\" \"W\" \"comp\" #>  - attr(*, \"GeoDa\")=List of 2 #>   ..$ shpfile: chr NA #>   ..$ ind    : chr NA #>  - attr(*, \"listw.call\")= language nb2listw(neighbours = col.gal.nb)"},{"path":"https://r-spatial.github.io/spdep/reference/lm.RStests.html","id":null,"dir":"Reference","previous_headings":"","what":"Rao's score (a.k.a Lagrange Multiplier) diagnostics for spatial dependence in linear models — lm.LMtests","title":"Rao's score (a.k.a Lagrange Multiplier) diagnostics for spatial dependence in linear models — lm.LMtests","text":"function reports estimates tests chosen among five statistics testing spatial dependence linear models. statistics simple RS test error dependence (“RSerr”), simple RS test missing spatially lagged dependent variable (“RSlag”), variants adjusted presence (“adjRSerr” tests error dependence possible presence missing lagged dependent variable, “adjRSlag” way round), portmanteau test (“SARMA”, fact “RSerr” + “adjRSlag”). Note: spdep 1.3-2, tests re-named “RS” - Rao's score tests, rather “LM” - Lagrange multiplier tests match naming tests family SDM.RStests.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.RStests.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rao's score (a.k.a Lagrange Multiplier) diagnostics for spatial dependence in linear models — lm.LMtests","text":"","code":"lm.RStests(model, listw, zero.policy=attr(listw, \"zero.policy\"), test=\"RSerr\",  spChk=NULL, naSubset=TRUE) lm.LMtests(model, listw, zero.policy=attr(listw, \"zero.policy\"), test=\"LMerr\",  spChk=NULL, naSubset=TRUE) # S3 method for class 'RStestlist' print(x, ...) # S3 method for class 'RStestlist' summary(object, p.adjust.method=\"none\", ...) # S3 method for class 'RStestlist.summary' print(x, digits=max(3, getOption(\"digits\") - 2), ...) <!-- %tracew(listw) -->"},{"path":"https://r-spatial.github.io/spdep/reference/lm.RStests.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rao's score (a.k.a Lagrange Multiplier) diagnostics for spatial dependence in linear models — lm.LMtests","text":"model object class lm returned lm, optionally vector externally calculated residuals (run though na.omit NAs present) use \"RSerr\" chosen; weights offsets used lm object listw listw object created example nb2listw, expected row-standardised (W-style) zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA test character vector tests requested chosen RSerr, RSlag, adjRSerr, adjRSlag, SARMA; test=\"\" computes tests. spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() naSubset default TRUE subset listw object omitted observations model object (change earlier behaviour, model$na.action component ignored, listw object subsetted hand) x, object object printed p.adjust.method character string specifying probability value adjustment (see p.adjust) multiple tests, default \"none\" digits minimum number significant digits used numbers ... printing arguments passed ","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.RStests.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rao's score (a.k.a Lagrange Multiplier) diagnostics for spatial dependence in linear models — lm.LMtests","text":"two types dependence spatial lag \\(\\rho\\) spatial error \\(\\lambda\\): $$ \\mathbf{y} = \\mathbf{X \\beta} + \\rho \\mathbf{W_{(1)} y} + \\mathbf{u}, $$ $$ \\mathbf{u} = \\lambda \\mathbf{W_{(2)} u} + \\mathbf{e} $$ \\(\\mathbf{e}\\) well-behaved, uncorrelated error term. Tests missing spatially lagged dependent variable test \\(\\rho = 0\\), tests spatial autocorrelation error \\(\\mathbf{u}\\) test whether \\(\\lambda = 0\\). \\(\\mathbf{W}\\) spatial weights matrix; tests used identical.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.RStests.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rao's score (a.k.a Lagrange Multiplier) diagnostics for spatial dependence in linear models — lm.LMtests","text":"list class RStestlist htest objects, : statistic value Rao's score (.k.Lagrange multiplier) test. parameter number degrees freedom p.value p-value test. method character string giving method used. data.name character string giving name(s) data.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.RStests.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Rao's score (a.k.a Lagrange Multiplier) diagnostics for spatial dependence in linear models — lm.LMtests","text":"Anselin, L. 1988 Spatial econometrics: methods models. (Dordrecht: Kluwer); Anselin, L., Bera, . K., Florax, R. Yoon, M. J. 1996 Simple diagnostic tests spatial dependence. Regional Science Urban Economics, 26, 77–104 doi:10.1016/0166-0462(95)02111-6 ; Malabika Koley (2024) Specification Testing General Nesting Spatial Model, https://sites.google.com/view/malabikakoley/research.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.RStests.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Rao's score (a.k.a Lagrange Multiplier) diagnostics for spatial dependence in linear models — lm.LMtests","text":"Roger Bivand Roger.Bivand@nhh.Andrew Bernat","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/lm.RStests.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rao's score (a.k.a Lagrange Multiplier) diagnostics for spatial dependence in linear models — lm.LMtests","text":"","code":"data(oldcol) oldcrime.lm <- lm(CRIME ~ HOVAL + INC, data = COL.OLD) summary(oldcrime.lm) #>  #> Call: #> lm(formula = CRIME ~ HOVAL + INC, data = COL.OLD) #>  #> Residuals: #>     Min      1Q  Median      3Q     Max  #> -34.418  -6.388  -1.580   9.052  28.649  #>  #> Coefficients: #>             Estimate Std. Error t value Pr(>|t|)     #> (Intercept)  68.6190     4.7355  14.490  < 2e-16 *** #> HOVAL        -0.2739     0.1032  -2.654   0.0109 *   #> INC          -1.5973     0.3341  -4.780 1.83e-05 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 #>  #> Residual standard error: 11.43 on 46 degrees of freedom #> Multiple R-squared:  0.5524,\tAdjusted R-squared:  0.5329  #> F-statistic: 28.39 on 2 and 46 DF,  p-value: 9.341e-09 #>  lw <- nb2listw(COL.nb) res <- lm.RStests(oldcrime.lm, listw=lw, test=\"all\") summary(res) #> \tRao's score (a.k.a Lagrange multiplier) diagnostics for spatial #> \tdependence #> data:   #> model: lm(formula = CRIME ~ HOVAL + INC, data = COL.OLD) #> test weights: lw #>   #>          statistic parameter  p.value    #> RSerr     5.723131         1 0.016743 *  #> RSlag     9.363684         1 0.002213 ** #> adjRSerr  0.079495         1 0.777983    #> adjRSlag  3.720048         1 0.053763 .  #> SARMA     9.443178         2 0.008901 ** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 if (require(\"spatialreg\", quietly=TRUE)) {   oldcrime.slx <- lmSLX(CRIME ~ HOVAL + INC, data = COL.OLD, listw=lw)   summary(lm.RStests(oldcrime.slx, listw=lw, test=c(\"adjRSerr\", \"adjRSlag\"))) } #> \tRao's score (a.k.a Lagrange multiplier) diagnostics for spatial #> \tdependence #> data:   #> model: lm(CRIME ~ HOVAL + INC + lag.HOVAL + lag.INC, data = COL.OLD, #> listw = lw) #> test weights: lw #>   #>              statistic parameter p.value #> GNM_adjRSerr   0.10933         1  0.7409 #> GNM_adjRSlag   0.61580         1  0.4326"},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.exact.html","id":null,"dir":"Reference","previous_headings":"","what":"Exact global Moran's I test — lm.morantest.exact","title":"Exact global Moran's I test — lm.morantest.exact","text":"function implements Tiefelsdorf's exact global Moran's test.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.exact.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exact global Moran's I test — lm.morantest.exact","text":"","code":"lm.morantest.exact(model, listw, zero.policy = attr(listw, \"zero.policy\"),  alternative = \"greater\", spChk = NULL, resfun = weighted.residuals,  zero.tol = 1e-07, Omega=NULL, save.M=NULL, save.U=NULL, useTP=FALSE,  truncErr=1e-6, zeroTreat=0.1) # S3 method for class 'moranex' print(x, ...)"},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.exact.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exact global Moran's I test — lm.morantest.exact","text":"model object class lm returned lm; weights may specified lm fit, offsets used listw listw object created example nb2listw zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA alternative character string specifying alternative hypothesis, must one greater (default), less two.sided. spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() resfun default: weighted.residuals; function used extract residuals lm object, may residuals, weighted.residuals, rstandard, rstudent zero.tol tolerance used find eigenvalues close absolute zero Omega SAR process matrix may passed test alternative hypothesis, example Omega <- invIrW(listw, rho=0.1); Omega <- tcrossprod(Omega), chol() taken internally save.M return full M matrix use spdep:::exactMoranAlt save.U return full U matrix use spdep:::exactMoranAlt useTP default FALSE, TRUE, use truncation point integration rather upper=Inf, see Tiefelsdorf (2000), eq. 6.7, p.69 truncErr useTP=TRUE, pass truncation error truncation point function zeroTreat useTP=TRUE, pass zero adjustment truncation point function x moranex object ... arguments passed ","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.exact.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exact global Moran's I test — lm.morantest.exact","text":"list class moranex following components: statistic value exact standard deviate global Moran's . p.value p-value test. estimate value observed global Moran's . method character string giving method used. alternative character string describing alternative hypothesis. gamma eigenvalues (excluding zero values) oType usually set \"E\" data.name character string giving name(s) data. df degrees freedom","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.exact.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Exact global Moran's I test — lm.morantest.exact","text":"Markus Reder Roger Bivand","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.exact.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Exact global Moran's I test — lm.morantest.exact","text":"Roger Bivand, Werner G. Müller Markus Reder (2009) \"Power calculations global local Moran's .\" Computational Statistics & Data Analysis 53, 2859-2872.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.exact.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exact global Moran's I test — lm.morantest.exact","text":"","code":"eire <- st_read(system.file(\"shapes/eire.gpkg\", package=\"spData\")[1]) #> Reading layer `eire' from data source  #>   `/home/rsb/lib/r_libs/spData/shapes/eire.gpkg' using driver `GPKG' #> Simple feature collection with 26 features and 10 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -4.12 ymin: 5768 xmax: 300.82 ymax: 6119.25 #> Projected CRS: Undefined Cartesian SRS with unknown unit row.names(eire) <- as.character(eire$names) eire.nb <- poly2nb(eire) e.lm <- lm(OWNCONS ~ ROADACC, data=eire) lm.morantest(e.lm, nb2listw(eire.nb)) #>  #> \tGlobal Moran I for regression residuals #>  #> data:   #> model: lm(formula = OWNCONS ~ ROADACC, data = eire) #> weights: nb2listw(eire.nb) #>  #> Moran I statistic standard deviate = 3.2575, p-value = 0.0005619 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I      Expectation         Variance  #>       0.33660565      -0.05877741       0.01473183  #>  lm.morantest.sad(e.lm, nb2listw(eire.nb)) #>  #> \tSaddlepoint approximation for global Moran's I (Barndorff-Nielsen #> \tformula) #>  #> data:   #> model:lm(formula = OWNCONS ~ ROADACC, data = eire) #> weights: nb2listw(eire.nb) #>  #> Saddlepoint approximation = 2.9395, p-value = 0.001644 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I  #>        0.3366057  #>  lm.morantest.exact(e.lm, nb2listw(eire.nb)) #>  #> \tGlobal Moran I statistic with exact p-value #>  #> data:   #> model:lm(formula = OWNCONS ~ ROADACC, data = eire) #> weights: nb2listw(eire.nb) #>  #> Exact standard deviate = 2.9316, p-value = 0.001686 #> alternative hypothesis: greater #> sample estimates: #> [1] 0.3366057 #>  lm.morantest.exact(e.lm, nb2listw(eire.nb), useTP=TRUE) #>  #> \tGlobal Moran I statistic with exact p-value #>  #> data:   #> model:lm(formula = OWNCONS ~ ROADACC, data = eire) #> weights: nb2listw(eire.nb) #>  #> Exact standard deviate = 2.9315, p-value = 0.001686 #> alternative hypothesis: greater #> sample estimates: #> [1] 0.3366057 #>"},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.html","id":null,"dir":"Reference","previous_headings":"","what":"Moran's I test for residual spatial autocorrelation — lm.morantest","title":"Moran's I test for residual spatial autocorrelation — lm.morantest","text":"Moran's test spatial autocorrelation residuals estimated linear model (lm()).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Moran's I test for residual spatial autocorrelation — lm.morantest","text":"","code":"lm.morantest(model, listw, zero.policy=attr(listw, \"zero.policy\"),  alternative = \"greater\", spChk=NULL, resfun=weighted.residuals, naSubset=TRUE)"},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Moran's I test for residual spatial autocorrelation — lm.morantest","text":"model object class lm returned lm; weights may specified lm fit, offsets used listw listw object created example nb2listw zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA alternative character string specifying alternative hypothesis, must one \"greater\" (default), \"less\" \"two.sided\". spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() resfun default: weighted.residuals; function used extract residuals lm object, may residuals, weighted.residuals, rstandard, rstudent naSubset default TRUE subset listw object omitted observations model object (change earlier behaviour, model$na.action component ignored, listw object subsetted hand)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Moran's I test for residual spatial autocorrelation — lm.morantest","text":"list class htest containing following components: statistic value standard deviate Moran's . p.value p-value test. estimate value observed Moran's , expectation variance method assumption. alternative character string describing alternative hypothesis. method character string giving method used. data.name character string giving name(s) data.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Moran's I test for residual spatial autocorrelation — lm.morantest","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, p. 203,","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Moran's I test for residual spatial autocorrelation — lm.morantest","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Moran's I test for residual spatial autocorrelation — lm.morantest","text":"","code":"data(oldcol) oldcrime1.lm <- lm(CRIME ~ 1, data = COL.OLD) oldcrime.lm <- lm(CRIME ~ HOVAL + INC, data = COL.OLD) lm.morantest(oldcrime.lm, nb2listw(COL.nb, style=\"W\")) #>  #> \tGlobal Moran I for regression residuals #>  #> data:   #> model: lm(formula = CRIME ~ HOVAL + INC, data = COL.OLD) #> weights: nb2listw(COL.nb, style = \"W\") #>  #> Moran I statistic standard deviate = 2.9539, p-value = 0.001569 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I      Expectation         Variance  #>      0.235638354     -0.033302866      0.008289408  #>  lm.LMtests(oldcrime.lm, nb2listw(COL.nb, style=\"W\")) #> Please update scripts to use lm.RStests in place of lm.LMtests #>  #> \tRao's score (a.k.a Lagrange multiplier) diagnostics for spatial #> \tdependence #>  #> data:   #> model: lm(formula = CRIME ~ HOVAL + INC, data = COL.OLD) #> test weights: listw #>  #> RSerr = 5.7231, df = 1, p-value = 0.01674 #>  lm.morantest(oldcrime.lm, nb2listw(COL.nb, style=\"S\")) #>  #> \tGlobal Moran I for regression residuals #>  #> data:   #> model: lm(formula = CRIME ~ HOVAL + INC, data = COL.OLD) #> weights: nb2listw(COL.nb, style = \"S\") #>  #> Moran I statistic standard deviate = 3.1745, p-value = 0.0007504 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I      Expectation         Variance  #>      0.239317561     -0.033431740      0.007381982  #>  lm.morantest(oldcrime1.lm, nb2listw(COL.nb, style=\"W\")) #>  #> \tGlobal Moran I for regression residuals #>  #> data:   #> model: lm(formula = CRIME ~ 1, data = COL.OLD) #> weights: nb2listw(COL.nb, style = \"W\") #>  #> Moran I statistic standard deviate = 5.6754, p-value = 6.92e-09 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I      Expectation         Variance  #>      0.510951264     -0.020833333      0.008779831  #>  moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style=\"W\"),  randomisation=FALSE) #>  #> \tMoran I test under normality #>  #> data:  COL.OLD$CRIME   #> weights: nb2listw(COL.nb, style = \"W\")     #>  #> Moran I statistic standard deviate = 5.6754, p-value = 6.92e-09 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.510951264      -0.020833333       0.008779831  #>  oldcrime.wlm <- lm(CRIME ~ HOVAL + INC, data = COL.OLD,  weights = I(1/AREA_PL)) lm.morantest(oldcrime.wlm, nb2listw(COL.nb, style=\"W\"),  resfun=weighted.residuals) #>  #> \tGlobal Moran I for regression residuals #>  #> data:   #> model: lm(formula = CRIME ~ HOVAL + INC, data = COL.OLD, weights = #> I(1/AREA_PL)) #> weights: nb2listw(COL.nb, style = \"W\") #>  #> Moran I statistic standard deviate = 3.0141, p-value = 0.001289 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I      Expectation         Variance  #>      0.241298974     -0.032224366      0.008235091  #>  lm.morantest(oldcrime.wlm, nb2listw(COL.nb, style=\"W\"),  resfun=rstudent) #>  #> \tGlobal Moran I for regression residuals #>  #> data:   #> model: lm(formula = CRIME ~ HOVAL + INC, data = COL.OLD, weights = #> I(1/AREA_PL)) #> weights: nb2listw(COL.nb, style = \"W\") #>  #> Moran I statistic standard deviate = 2.822, p-value = 0.002387 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I      Expectation         Variance  #>      0.223860298     -0.032224366      0.008235091  #>"},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.sad.html","id":null,"dir":"Reference","previous_headings":"","what":"Saddlepoint approximation of global Moran's I test — lm.morantest.sad","title":"Saddlepoint approximation of global Moran's I test — lm.morantest.sad","text":"function implements Tiefelsdorf's application Saddlepoint approximation global Moran's 's reference distribution.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.sad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Saddlepoint approximation of global Moran's I test — lm.morantest.sad","text":"","code":"lm.morantest.sad(model, listw, zero.policy=attr(listw, \"zero.policy\"),   alternative=\"greater\", spChk=NULL, resfun=weighted.residuals,   tol=.Machine$double.eps^0.5, maxiter=1000, tol.bounds=0.0001,   zero.tol = 1e-07, Omega=NULL, save.M=NULL, save.U=NULL) # S3 method for class 'moransad' print(x, ...) # S3 method for class 'moransad' summary(object, ...) # S3 method for class 'summary.moransad' print(x, ...)"},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.sad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Saddlepoint approximation of global Moran's I test — lm.morantest.sad","text":"model object class lm returned lm; weights may specified lm fit, offsets used listw listw object created example nb2listw zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA alternative character string specifying alternative hypothesis, must one greater (default), less two.sided. spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() resfun default: weighted.residuals; function used extract residuals lm object, may residuals, weighted.residuals, rstandard, rstudent tol desired accuracy (convergence tolerance) uniroot maxiter maximum number iterations uniroot tol.bounds offset bounds uniroot zero.tol tolerance used find eigenvalues close absolute zero Omega SAR process matrix may passed test alternative hypothesis, example Omega <- invIrW(listw, rho=0.1); Omega <- tcrossprod(Omega), chol() taken internally save.M return full M matrix use spdep:::exactMoranAlt save.U return full U matrix use spdep:::exactMoranAlt x object printed object object summarised ... arguments passed ","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.sad.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Saddlepoint approximation of global Moran's I test — lm.morantest.sad","text":"function involves finding eigenvalues n n matrix, numerically finding root Saddlepoint approximation, therefore used care n large.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.sad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Saddlepoint approximation of global Moran's I test — lm.morantest.sad","text":"list class moransad following components: statistic value saddlepoint approximation  standard deviate global Moran's . p.value p-value test. estimate value observed global Moran's . alternative character string describing alternative hypothesis. method character string giving method used. data.name character string giving name(s) data. internal1 Saddlepoint omega, r u internal2 f.root, iter estim.prec uniroot df degrees freedom tau eigenvalues (excluding zero values)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.sad.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Saddlepoint approximation of global Moran's I test — lm.morantest.sad","text":"Tiefelsdorf, M. 2002 Saddlepoint approximation Moran's local Moran's Ii reference distributions numerical evaluation. Geographical Analysis, 34, pp. 187–206; Bivand RS, Wong DWS 2018 Comparing implementations global local indicators spatial association. TEST, 27(3), 716–748 doi:10.1007/s11749-018-0599-x","code":""},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.sad.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Saddlepoint approximation of global Moran's I test — lm.morantest.sad","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/lm.morantest.sad.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Saddlepoint approximation of global Moran's I test — lm.morantest.sad","text":"","code":"eire <- st_read(system.file(\"shapes/eire.gpkg\", package=\"spData\")[1]) #> Reading layer `eire' from data source  #>   `/home/rsb/lib/r_libs/spData/shapes/eire.gpkg' using driver `GPKG' #> Simple feature collection with 26 features and 10 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -4.12 ymin: 5768 xmax: 300.82 ymax: 6119.25 #> Projected CRS: Undefined Cartesian SRS with unknown unit row.names(eire) <- as.character(eire$names) eire.nb <- poly2nb(eire) e.lm <- lm(OWNCONS ~ ROADACC, data=eire) lm.morantest(e.lm, nb2listw(eire.nb)) #>  #> \tGlobal Moran I for regression residuals #>  #> data:   #> model: lm(formula = OWNCONS ~ ROADACC, data = eire) #> weights: nb2listw(eire.nb) #>  #> Moran I statistic standard deviate = 3.2575, p-value = 0.0005619 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I      Expectation         Variance  #>       0.33660565      -0.05877741       0.01473183  #>  lm.morantest.sad(e.lm, nb2listw(eire.nb)) #>  #> \tSaddlepoint approximation for global Moran's I (Barndorff-Nielsen #> \tformula) #>  #> data:   #> model:lm(formula = OWNCONS ~ ROADACC, data = eire) #> weights: nb2listw(eire.nb) #>  #> Saddlepoint approximation = 2.9395, p-value = 0.001644 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I  #>        0.3366057  #>  summary(lm.morantest.sad(e.lm, nb2listw(eire.nb))) #>  #> \tSaddlepoint approximation for global Moran's I (Barndorff-Nielsen #> \tformula) #>  #> data:   #> model:lm(formula = OWNCONS ~ ROADACC, data = eire) #> weights: nb2listw(eire.nb) #>  #> Saddlepoint approximation = 2.9395, p-value = 0.001644 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I  #>        0.3366057  #>  #>  Expectation     Variance Std. deviate     Skewness     Kurtosis      Minimum  #>  -0.05877741   0.01473183   3.25753938   0.31336881   3.05047361  -0.67545810  #>      Maximum        omega        sad.r        sad.u  #>   0.89091555   0.76549075   2.77616585   4.36854629  #>      f.root        iter  estim.prec  #> 7.01314e-14 1.10000e+01          NA  e.wlm <- lm(OWNCONS ~ ROADACC, data=eire, weights=RETSALE) lm.morantest(e.wlm, nb2listw(eire.nb), resfun=rstudent) #>  #> \tGlobal Moran I for regression residuals #>  #> data:   #> model: lm(formula = OWNCONS ~ ROADACC, data = eire, weights = RETSALE) #> weights: nb2listw(eire.nb) #>  #> Moran I statistic standard deviate = 3.1385, p-value = 0.0008491 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I      Expectation         Variance  #>       0.34500329      -0.04049313       0.01508687  #>  lm.morantest.sad(e.wlm, nb2listw(eire.nb), resfun=rstudent) #>  #> \tSaddlepoint approximation for global Moran's I (Barndorff-Nielsen #> \tformula) #>  #> data:   #> model:lm(formula = OWNCONS ~ ROADACC, data = eire, weights = RETSALE) #> weights: nb2listw(eire.nb) #>  #> Saddlepoint approximation = 2.8708, p-value = 0.002047 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I  #>        0.3450033  #>"},{"path":"https://r-spatial.github.io/spdep/reference/localC.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Local Geary statistic — localC","title":"Compute Local Geary statistic — localC","text":"Local Geary local adaptation Geary's C statistic spatial autocorrelation. Local Geary uses squared differences measure dissimilarity unlike Local Moran. Low values Local Geary indicate positive spatial autocorrelation large refers negative spatial autocorrelation. Inference Local Geary based permutation approach compares observed value reference distribution spatial randomness. localC_perm() returns pseudo p-value. analytical p-value based number permutations used care.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Local Geary statistic — localC","text":"","code":"localC(x, ..., zero.policy=NULL)  # Default S3 method localC(x, listw, ..., zero.policy=attr(listw, \"zero.policy\"))  # S3 method for class 'formula' localC(formula, data, listw, ..., zero.policy=attr(listw, \"zero.policy\"))  # S3 method for class 'list' localC(x, listw, ..., zero.policy=attr(listw, \"zero.policy\"))  # S3 method for class 'matrix' localC(x, listw, ..., zero.policy=attr(listw, \"zero.policy\"))  # S3 method for class 'data.frame' localC(x, listw, ..., zero.policy=attr(listw, \"zero.policy\"))  localC_perm(x, ..., zero.policy=NULL, iseed=NULL, no_repeat_in_row=FALSE)  # Default S3 method localC_perm(x, listw, nsim = 499, alternative = \"two.sided\", ...,  zero.policy=attr(listw, \"zero.policy\"), iseed=NULL, no_repeat_in_row=FALSE)  # S3 method for class 'formula' localC_perm(formula, data, listw, nsim = 499,  alternative = \"two.sided\", ..., zero.policy=attr(listw, \"zero.policy\"), iseed=NULL,  no_repeat_in_row=FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/localC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Local Geary statistic — localC","text":"x numeric vector, numeric matrix, list. See details . formula one-sided formula determining variables used. listw listw object created example nb2listw. data Used formula provided. matrix data frame containing variables formula formula. nsim number simulations used permutation test. alternative character defining alternative hypothesis. Must one \"two.sided\", \"less\" \"greater\". ... arguments passed methods. zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA. iseed default NULL, used set seed;output reproducible count CPU cores across computation distributed no_repeat_in_row default FALSE, TRUE, sample conditionally row without replacements avoid duplicate values, https://github.com/r-spatial/spdep/issues/124","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Local Geary statistic — localC","text":"Local Geary can extended multivariate context. x numeric vector, univariate Local Geary calculated. calculate multivariate Local Moran provide either list matrix. x list, element must numeric vector length length neighbours listw. case x matrix number rows must length neighbours listw. required univariate context, standardized Local Geary calculated. multivariate Local Geary always standardized. univariate Local Geary calculated \\(c_i = \\sum_j w_{ij}(x_i - x_j)^2\\) multivariate Local Geary calculated \\(c_{k,} = \\sum_{v=1}^{k} c_{v,}\\) described Anselin (2019).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Local Geary statistic — localC","text":"numeric vector containing Local Geary statistic attribute pseudo-p localC_perm() used. pseudo-p 8 column matrix containing  E.Ci expectation Local Geary statistic based permutation sample Var.Ci variance Local Geary based permutation sample Z.Ci standard deviate Local Geary based permutation sample Pr() p-value Local Geary statistic using pnorm() using standard deviates based permutation sample means standard deviations Pr() Sim rank() punif() observed statistic rank [0, 1] p-values using alternative= Pr(folded) Sim simulation folded [0, 0.5] range ranked p-value (based https://github.com/pysal/esda/blob/4a63e0b5df1e754b17b5f1205b8cadcbecc5e061/esda/crand.py#L211-L213) Skewness output e1071::skewness() permutation samples underlying standard deviates Kurtosis output e1071::kurtosis() permutation samples underlying standard deviates","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localC.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute Local Geary statistic — localC","text":"Anselin, L. (1995), Local Indicators Spatial Association—LISA. Geographical Analysis, 27: 93-115. doi:10.1111/j.1538-4632.1995.tb00338.x Anselin, L. (2019), Local Indicator Multivariate Spatial Association: Extending Gearys c. Geogr Anal, 51: 133-150. doi:10.1111/gean.12164","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localC.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute Local Geary statistic — localC","text":"Josiah Parry josiah.parry@gmail.com Roger Bivand","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Local Geary statistic — localC","text":"","code":"orig <- spData::africa.rook.nb listw <- nb2listw(orig) x <- spData::afcon$totcon  (A <- localC(x, listw)) #>  [1] 0.39025457 0.50460439 0.15303047 2.90814878 3.40006901 0.17103368 #>  [7] 0.29947832 0.72444806 2.30617282 5.70252541 2.23161263 0.17833029 #> [13] 0.18420002 0.18680408 0.37851643 0.11056720 0.14814835 0.17257920 #> [19] 0.03254150 0.18992772 0.08749322 3.71970760 0.09566918 0.26112918 #> [25] 0.09505331 2.99934478 1.17465032 1.64868780 0.87901004 0.05909537 #> [31] 2.54591475 3.85570655 2.99413462 0.96084992 0.80678832 1.56869350 #> [37] 0.86422915 0.38817470 0.23425755 1.26191610 1.34455327 1.80707481 listw1 <- nb2listw(droplinks(sym.attr.nb(orig), 3, sym=TRUE), zero.policy=TRUE) #> Warning: some observations have no neighbours #> Warning: neighbour object has 2 sub-graphs (A1 <- localC(x, listw1, zero.policy=FALSE)) #>  [1] 0.39025457 0.57491918         NA 2.90814878 3.40006901 0.17103368 #>  [7] 0.29947832 0.72444806 2.30617282 5.70252541 2.23161263 0.17833029 #> [13] 0.18420002 0.18680408 0.37851643 0.11056720 0.14814835 0.17257920 #> [19] 0.03254150 0.18992772 0.08749322 3.71970760 0.09566918 0.26112918 #> [25] 0.09505331 2.99934478 1.17465032 1.64868780 0.87901004 0.05909537 #> [31] 2.54591475 3.85570655 2.99413462 0.96084992 0.80678832 1.56869350 #> [37] 0.86422915 0.38817470 0.23425755 1.26191610 1.34455327 1.80707481 (A2 <- localC(x, listw1, zero.policy=TRUE)) #>  [1] 0.39025457 0.57491918 0.00000000 2.90814878 3.40006901 0.17103368 #>  [7] 0.29947832 0.72444806 2.30617282 5.70252541 2.23161263 0.17833029 #> [13] 0.18420002 0.18680408 0.37851643 0.11056720 0.14814835 0.17257920 #> [19] 0.03254150 0.18992772 0.08749322 3.71970760 0.09566918 0.26112918 #> [25] 0.09505331 2.99934478 1.17465032 1.64868780 0.87901004 0.05909537 #> [31] 2.54591475 3.85570655 2.99413462 0.96084992 0.80678832 1.56869350 #> [37] 0.86422915 0.38817470 0.23425755 1.26191610 1.34455327 1.80707481 run <- FALSE if (require(rgeoda, quietly=TRUE)) run <- TRUE #>  #> Attaching package: ‘rgeoda’ #> The following object is masked from ‘package:spdep’: #>  #>     skater if (run) {   W <- create_weights(as.numeric(length(x)))   for (i in 1:length(listw$neighbours)) {     set_neighbors_with_weights(W, i, listw$neighbours[[i]], listw$weights[[i]])     update_weights(W)   }   set.seed(1)   B <- local_geary(W, data.frame(x))   all.equal(A, lisa_values(B)) } #> [1] TRUE if (run) {   set.seed(1)   C <- localC_perm(x, listw, nsim = 499, conditional=TRUE,     alternative=\"two.sided\")   cor(ifelse(lisa_pvalues(B) < 0.5, lisa_pvalues(B), 1-lisa_pvalues(B)),     attr(C, \"pseudo-p\")[,6]) } #> [1] 0.985611 # pseudo-p values probably wrongly folded https://github.com/GeoDaCenter/rgeoda/issues/28 # \\donttest{ tmap_ok <- FALSE if (require(tmap, quietly=TRUE)) tmap_ok <- TRUE #> Breaking News: tmap 3.x is retiring. Please test v4, e.g. with #> remotes::install_github('r-tmap/tmap') if (run) {   # doi: 10.1111/gean.12164   guerry_path <- system.file(\"extdata\", \"Guerry.shp\", package = \"rgeoda\")   g <- st_read(guerry_path)[, 7:12]   cor(st_drop_geometry(g)) #(Tab. 1)   lw <- nb2listw(poly2nb(g))   moran(g$Crm_prs, lw, n=nrow(g), S0=Szero(lw))$I   moran(g$Crm_prp, lw, n=nrow(g), S0=Szero(lw))$I   moran(g$Litercy, lw, n=nrow(g), S0=Szero(lw))$I   moran(g$Donatns, lw, n=nrow(g), S0=Szero(lw))$I   moran(g$Infants, lw, n=nrow(g), S0=Szero(lw))$I   moran(g$Suicids, lw, n=nrow(g), S0=Szero(lw))$I } #> Reading layer `Guerry' from data source  #>   `/home/rsb/lib/r_libs/rgeoda/extdata/Guerry.shp' using driver `ESRI Shapefile' #> Simple feature collection with 85 features and 29 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 47680 ymin: 1703258 xmax: 1031401 ymax: 2677441 #> Projected CRS: NTF (Paris) / Lambert zone II #> [1] 0.4016812 if (run) {   o <- prcomp(st_drop_geometry(g), scale.=TRUE)   cor(st_drop_geometry(g), o$x[,1:2])^2 #(Tab. 2) } #>                 PC1         PC2 #> Crm_prs 0.009286863 0.418851254 #> Crm_prp 0.561825664 0.009377232 #> Litercy 0.560570048 0.020095011 #> Donatns 0.024138865 0.586720363 #> Infants 0.436025658 0.012817054 #> Suicids 0.548623327 0.152958961 if (run) {   g$PC1 <- o$x[, \"PC1\"]   brks <- c(min(g$PC1), natural_breaks(k=6, g[\"PC1\"]), max(g$PC1))   if (tmap_ok) {     tmap4 <- packageVersion(\"tmap\") >= \"3.99\"     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"PC1\",          fill.scale=tm_scale(values=\"brewer.rd_yl_gn\", breaks=brks,         midpoint=0), fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),         frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"PC1\", breaks=brks, midpoint=0) +        tm_borders() # Fig. 1     }   } else {     pplot(g[\"PC1\"], breaks=brks)   } }  if (run) {   g$PC2 <- -1*o$x[, \"PC2\"] # eigenvalue sign arbitrary   brks <- c(min(g$PC2), natural_breaks(k=6, g[\"PC2\"]), max(g$PC2))   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"PC2\",          fill.scale=tm_scale(values=\"brewer.rd_yl_gn\", breaks=brks,         midpoint=0), fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),         frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"PC2\", breaks=brks, midpoint=0) +        tm_borders() # Fig. 2     }   } else {     plot(g[\"PC2\"], breaks=brks)   } }  if (run) {   w <- queen_weights(g)   lm_PC1 <- local_moran(w, g[\"PC1\"], significance_cutoff=0.01,     permutations=99999)   g$lm_PC1 <- factor(lisa_clusters(lm_PC1), levels=0:4,     labels=lisa_labels(lm_PC1)[1:5])   is.na(g$lm_PC1) <- g$lm_PC1 == \"Not significant\"   g$lm_PC1 <- droplevels(g$lm_PC1)   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"lm_PC1\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"lm_PC1\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # Fig. 3     }   } else {     plot(g[\"lm_PC1\"])   } }  if (run) {   set.seed(1)   lm_PC1_spdep <- localmoran_perm(g$PC1, lw, nsim=9999)   q <- attr(lm_PC1_spdep, \"quadr\")$pysal   g$lm_PC1_spdep <- q   is.na(g$lm_PC1_spdep) <- lm_PC1_spdep[,6] > 0.02 # note folded p-values   g$lm_PC1_spdep <- droplevels(g$lm_PC1_spdep)   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"lm_PC1_spdep\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"lm_PC1_spdep\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # rep. Fig. 3     }   } else {     plot(g[\"lm_PC1_spdep\"])   } }  if (run) {   lg_PC1 <- local_g(w, g[\"PC1\"], significance_cutoff=0.01,     permutations=99999)   g$lg_PC1 <- factor(lisa_clusters(lg_PC1), levels=0:2,     labels=lisa_labels(lg_PC1)[0:3])   is.na(g$lg_PC1) <- g$lg_PC1 == \"Not significant\"   g$lg_PC1 <- droplevels(g$lg_PC1)   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"lg_PC1\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"lg_PC1\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # Fig. 4 (wrong)     }   } else {     plot(g[\"lg_PC1\"])   }   g$lg_PC1a <- cut(g$PC1, c(-Inf, mean(g$PC1), Inf), labels=c(\"Low\", \"High\"))   is.na(g$lg_PC1a) <- lisa_pvalues(lg_PC1) >= 0.01   g$lg_PC1a <- droplevels(g$lg_PC1a)   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"lg_PC1a\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"lg_PC1a\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # Fig. 4 (guess)     }   } else {     plot(g[\"lg_PC1\"])   } }  if (run) {   lc_PC1 <- local_geary(w, g[\"PC1\"], significance_cutoff=0.01,     permutations=99999)   g$lc_PC1 <- factor(lisa_clusters(lc_PC1), levels=0:4,     labels=lisa_labels(lc_PC1)[1:5])   is.na(g$lc_PC1) <- g$lc_PC1 == \"Not significant\"   g$lc_PC1 <- droplevels(g$lc_PC1)   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"lc_PC1\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"lc_PC1\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # Fig. 5     }   } else {     plot(g[\"lc_PC1\"])   } }  if (run) {   set.seed(1)   system.time(lc_PC1_spdep <- localC_perm(g$PC1, lw, nsim=9999,     alternative=\"two.sided\")) } #>    user  system elapsed  #>   0.340   0.001   0.343  if (run) {   if (require(parallel, quietly=TRUE)) {     ncpus <- max(2L, detectCores(logical=FALSE), na.rm = TRUE)-1L # test with single core     if (ncpus > 1L) ncpus <- 1L     cores <- get.coresOption()     set.coresOption(ncpus)     system.time(lmc_PC1_spdep1 <- localC_perm(g$PC1, lw, nsim=9999,       alternative=\"two.sided\", iseed=1))     set.coresOption(cores)   } } #> [1] 1 if (run) {   g$lc_PC1_spdep <- attr(lc_PC1_spdep, \"cluster\")   is.na(g$lc_PC1_spdep) <- attr(lc_PC1_spdep, \"pseudo-p\")[,6] > 0.01   g$lc_PC1_spdep <- droplevels(g$lc_PC1_spdep)   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"lc_PC1_spdep\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"lc_PC1_spdep\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # rep. Fig. 5     }   } else {     plot(g[\"lc_PC1_spdep\"])   } }  if (run) {   g$both_PC1 <- interaction(g$lc_PC1, g$lm_PC1)   g$both_PC1 <- droplevels(g$both_PC1)   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"both_PC1\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"both_PC1\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # Fig. 6     }   } else {     plot(g[\"both_PC1\"])   } }  if (run) {   lc005_PC1 <- local_geary(w, g[\"PC1\"], significance_cutoff=0.005,     permutations=99999)   g$lc005_PC1 <- factor(lisa_clusters(lc005_PC1), levels=0:4,     labels=lisa_labels(lc005_PC1)[1:5])   is.na(g$lc005_PC1) <- g$lc005_PC1 == \"Not significant\"   g$lc005_PC1 <- droplevels(g$lc005_PC1)   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"lc005_PC1\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"lc005_PC1\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # Fig. 7     }   } else {     plot(g[\"lc005_PC1\"]) } if (run) {   g$lc005_PC1_spdep <- attr(lc_PC1_spdep, \"cluster\")   is.na(g$lc005_PC1_spdep) <- attr(lc_PC1_spdep, \"pseudo-p\")[,6] > 0.005   g$lc005_PC1_spdep <- droplevels(g$lc005_PC1_spdep)   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"lc005_PC1_spdep\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"lc005_PC1_spdep\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # rep. Fig. 7     }   } else {     plot(g[\"lc005_PC1_spdep\"])   } } if (run) {   lc001_PC1 <- local_geary(w, g[\"PC1\"], significance_cutoff=0.001,     permutations=99999)   g$lc001_PC1 <- factor(lisa_clusters(lc001_PC1), levels=0:4,     labels=lisa_labels(lc001_PC1)[1:5])   is.na(g$lc001_PC1) <- g$lc001_PC1 == \"Not significant\"   g$lc001_PC1 <- droplevels(g$lc001_PC1)   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"lc005_PC1\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"lc001_PC1\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # Fig. 8     }   } else {     plot(g[\"lc001_PC1\"])   } } if (run) {   g$lc001_PC1_spdep <- attr(lc_PC1_spdep, \"cluster\")   is.na(g$lc001_PC1_spdep) <- attr(lc_PC1_spdep, \"pseudo-p\")[,6] > 0.001   g$lc001_PC1_spdep <- droplevels(g$lc001_PC1_spdep)   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"lc005_PC1_spdep\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"lc001_PC1_spdep\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # rep. Fig. 8     }   } else {     plot(g[\"lc001_PC1_spdep\"])   } } }  if (run) {   lc_PC2 <- local_geary(w, g[\"PC2\"], significance_cutoff=0.01,     permutations=99999)   g$lc_PC2 <- factor(lisa_clusters(lc_PC2), levels=0:4,     labels=lisa_labels(lc_PC2)[1:5])   is.na(g$lc_PC2) <- g$lc_PC2 == \"Not significant\"   g$lc_PC2 <- droplevels(g$lc_PC2)   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"lc_PC2\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"lc_PC2\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # Fig. 9     }   } else {     plot(g[\"lc_PC2\"])   } }  if (run) {   lmc_PC <- local_multigeary(w, g[c(\"PC1\",\"PC2\")], significance_cutoff=0.00247,     permutations=99999)   g$lmc_PC <- factor(lisa_clusters(lmc_PC), levels=0:1,     labels=lisa_labels(lmc_PC)[1:2])   is.na(g$lmc_PC) <- g$lmc_PC == \"Not significant\"   g$lmc_PC <- droplevels(g$lmc_PC)   table(interaction((p.adjust(lisa_pvalues(lmc_PC), \"fdr\") < 0.01), g$lmc_PC)) } #>  #> FALSE.Positive  TRUE.Positive  #>              0             21  if (run) {   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"lmc_PC\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"lmc_PC\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # Fig. 10     }   } else {     plot(g[\"lmc_PC\"])   } }  if (run) {   set.seed(1)   lmc_PC_spdep <- localC_perm(g[c(\"PC1\",\"PC2\")], lw, nsim=9999, alternative=\"two.sided\")   all.equal(lisa_values(lmc_PC), c(lmc_PC_spdep)) } #> [1] TRUE if (run) {   cor(attr(lmc_PC_spdep, \"pseudo-p\")[,6], lisa_pvalues(lmc_PC)) } #> [1] 0.9905202 if (run) {   g$lmc_PC_spdep <- attr(lmc_PC_spdep, \"cluster\")   is.na(g$lmc_PC_spdep) <- p.adjust(attr(lmc_PC_spdep, \"pseudo-p\")[,6], \"fdr\") > 0.01   g$lmc_PC_spdep <- droplevels(g$lmc_PC_spdep)   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"lmc_PC_spdep\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"lmc_PC_spdep\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # rep. Fig. 10     }   } else {     plot(g[\"lmc_PC_spdep\"])   } }  if (run) {   lmc_vars <- local_multigeary(w, st_drop_geometry(g)[, 1:6],     significance_cutoff=0.00247, permutations=99999)   g$lmc_vars <- factor(lisa_clusters(lmc_vars), levels=0:1,     labels=lisa_labels(lmc_vars)[1:2])   is.na(g$lmc_vars) <- g$lmc_vars == \"Not significant\"   g$lmc_vars <- droplevels(g$lmc_vars)   table(interaction((p.adjust(lisa_pvalues(lmc_vars), \"fdr\") < 0.01),     g$lmc_vars)) } #>  #> FALSE.Positive  TRUE.Positive  #>              0             21  if (run) {   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"lmc_vars\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"lmc_vars\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # Fig. 11     }   } else {     plot(g[\"lmc_vars\"])   } }  if (run) {   set.seed(1)   system.time(lmc_vars_spdep <- localC_perm(st_drop_geometry(g)[, 1:6], lw,     nsim=9999, alternative=\"two.sided\")) } #>    user  system elapsed  #>   0.559   0.014   0.575  if (run) {   all.equal(lisa_values(lmc_vars), c(lmc_vars_spdep)) } #> [1] TRUE if (run) {   cor(attr(lmc_vars_spdep, \"pseudo-p\")[,6], lisa_pvalues(lmc_vars)) } #> [1] 0.9938141 if (run) {   if (require(parallel, quietly=TRUE)) {     ncpus <- max(2L, detectCores(logical=FALSE), na.rm = TRUE)-1L # test with single core     if (ncpus > 1L) ncpus <- 1L     cores <- get.coresOption()     set.coresOption(ncpus)     system.time(lmc_vars_spdep1 <- localC_perm(st_drop_geometry(g)[, 1:6], lw,       nsim=9999, alternative=\"two.sided\", iseed=1))     set.coresOption(cores)   } } #> [1] 1 if (run) {   all.equal(lisa_values(lmc_vars), c(lmc_vars_spdep1)) } #> [1] TRUE if (run) {   cor(attr(lmc_vars_spdep1, \"pseudo-p\")[,6], lisa_pvalues(lmc_vars)) } #> [1] 0.9938141 if (run) {   g$lmc_vars_spdep <- attr(lmc_vars_spdep1, \"cluster\")   is.na(g$lmc_vars_spdep) <- p.adjust(attr(lmc_vars_spdep1, \"pseudo-p\")[,6], \"fdr\") > 0.01   g$lmc_vars_spdep <- droplevels(g$lmc_vars_spdep)   if (tmap_ok) {     if (tmap4) {       tm_shape(g) + tm_polygons(fill=\"lmc_vars_spdep\",         fill.scale=tm_scale(values=\"brewer.set3\", value.na=\"gray95\",           label.na=\"Insignificant\"),         fill.legend=tm_legend(position=tm_pos_in(\"left\", \"bottom\"),           frame=FALSE, item.r=0))     } else {       tm_shape(g) + tm_fill(\"lmc_vars_spdep\", textNA=\"Insignificant\",         colorNA=\"gray95\") + tm_borders() # rep. Fig. 11     }   } else {     plot(g[\"lmc_vars_spdep\"])   } }   # } # \\dontrun{ library(reticulate) use_python(\"/usr/bin/python\", required = TRUE) gp <- import(\"geopandas\") #> Error in py_module_import(module, convert = convert): ModuleNotFoundError: No module named 'geopandas' #> Run `reticulate::py_last_error()` for details. ps <- import(\"libpysal\") #> Error in py_module_import(module, convert = convert): ModuleNotFoundError: No module named 'libpysal' #> Run `reticulate::py_last_error()` for details. W <- listw2mat(listw) w <- ps$weights$full2W(W, rownames(W)) #> Error: object 'ps' not found w$transform <- \"R\" #> Error in envRefSetField(x, what, refObjectClass(x), selfEnv, value): ‘transform’ is not a field in class “Weight” esda <- import(\"esda\") #> Error in py_module_import(module, convert = convert): ModuleNotFoundError: No module named 'esda' #> Run `reticulate::py_last_error()` for details. lM <- esda$Moran_Local(x, w) #> Error: object 'esda' not found all.equal(unname(localmoran(x, listw, mlvar=FALSE)[,1]), c(lM$Is)) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'current' in selecting a method for function 'all.equal': object 'lM' not found # confirm x and w the same lC <- esda$Geary_Local(connectivity=w)$fit(scale(x)) #> Error: object 'esda' not found # np$std missing ddof=1 n <- length(x) D0 <- spdep:::geary.intern((x - mean(x)) / sqrt(var(x)*(n-1)/n), listw, n=n) # lC components probably wrongly ordered https://github.com/pysal/esda/issues/192 o <- match(round(D0, 6), round(lC$localG, 6)) #> Error: object 'lC' not found all.equal(c(lC$localG)[o], D0) #> Error in h(simpleError(msg, call)): error in evaluating the argument 'target' in selecting a method for function 'all.equal': object 'lC' not found # simulation order not retained lC$p_sim[o] #> Error: object 'lC' not found attr(C, \"pseudo-p\")[,6] #>  [1] 0.408 0.374 0.144 0.056 0.010 0.284 0.032 0.264 0.186 0.004 0.150 0.224 #> [13] 0.022 0.150 0.438 0.084 0.126 0.184 0.002 0.238 0.126 0.100 0.068 0.372 #> [25] 0.124 0.234 0.230 0.016 0.318 0.176 0.272 0.164 0.164 0.206 0.402 0.250 #> [37] 0.410 0.402 0.328 0.294 0.438 0.248 # }"},{"path":"https://r-spatial.github.io/spdep/reference/localG.html","id":null,"dir":"Reference","previous_headings":"","what":"G and Gstar local spatial statistics — localG","title":"G and Gstar local spatial statistics — localG","text":"local spatial statistic G calculated zone based spatial weights object used. value returned Z-value, may used diagnostic tool. High positive values indicate posibility local cluster high values variable analysed, low relative values similar cluster low values. inference, Bonferroni-type test suggested references, tables critical values may found (see also details ).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"G and Gstar local spatial statistics — localG","text":"","code":"localG(x, listw, zero.policy=attr(listw, \"zero.policy\"), spChk=NULL, GeoDa=FALSE,  alternative = \"two.sided\", return_internals=TRUE) localG_perm(x, listw, nsim=499, zero.policy=attr(listw, \"zero.policy\"), spChk=NULL,  alternative = \"two.sided\", iseed=NULL, fix_i_in_Gstar_permutations=TRUE,  no_repeat_in_row=FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/localG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"G and Gstar local spatial statistics — localG","text":"x numeric vector length neighbours list listw listw listw object created example nb2listw zero.policy default NULL, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() GeoDa default FALSE, TRUE, drop x values -neighbour self-neighbour observations summations nsim default 499, number conditonal permutation simulations alternative character string specifying alternative hypothesis, must one \"two.sided\" (default), \"greater\" \"less\". return_internals default TRUE, unused iseed default NULL, used set seed; output reproducible count CPU cores across computation distributed fix_i_in_Gstar_permutations default TRUE (fix x self permutations local G-star), set FALSE use pre-1.2-8 behaviour no_repeat_in_row default FALSE, TRUE, sample conditionally row without replacements avoid duplicate values, https://github.com/r-spatial/spdep/issues/124","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localG.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"G and Gstar local spatial statistics — localG","text":"neighbours member listw \"self.included\" attribute set TRUE, Gstar variant, including self-weight \\(w_{ii} > 0\\), calculated returned.  returned vector \"gstari\" attribute set TRUE.  Self-weights must included using include.self function converting neighbour list spatial weights list nb2listw shown example. critical values statistic assumptions given references 95th percentile n=1: 1.645, n=50: 3.083, n=100: 3.289, n=1000: 3.886.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"G and Gstar local spatial statistics — localG","text":"vector G Gstar standard deviate values, attributes \"gstari\" set TRUE FALSE, \"call\" set function call, class \"localG\". conditional permutation, returned value localG(), simulated standard deviate returned column \"StdDev.Gi\" attr(., \"internals\").","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localG.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"G and Gstar local spatial statistics — localG","text":"Conditional permutations added comparative purposes; permutations whole data vector omitting observation , 1.2-8 fixing observation neighbour local G-star.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localG.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"G and Gstar local spatial statistics — localG","text":"Ord, J. K. Getis, . 1995 Local spatial autocorrelation statistics: distributional issues application. Geographical Analysis, 27, 286–306; Getis, . Ord, J. K. 1996 Local spatial statistics: overview. P. Longley M. Batty (eds) Spatial analysis: modelling GIS environment (Cambridge: Geoinformation International), 261–277; Bivand RS, Wong DWS 2018 Comparing implementations global local indicators spatial association. TEST, 27(3), 716–748 doi:10.1007/s11749-018-0599-x","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localG.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"G and Gstar local spatial statistics — localG","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"G and Gstar local spatial statistics — localG","text":"","code":"data(getisord, package=\"spData\") # spData 0.3.2 changes x, y, xyz object names to go_x, go_y, go_xyz to # avoid putting these objects into the global environment via lazy loading if (exists(\"go_xyz\") && packageVersion(\"spData\") >= \"0.3.2\") {   xyz <- go_xyz   x <- go_x   y <- go_y } xycoords <- cbind(xyz$x, xyz$y) nb30 <- dnearneigh(xycoords, 0, 30) G30 <- localG(xyz$val, nb2listw(nb30, style=\"B\")) G30[length(xyz$val)-136] #> [1] 1.221979 set.seed(1) G30_sim <- localG_perm(xyz$val, nb2listw(nb30, style=\"B\")) G30_sim[length(xyz$val)-136] #> [1] 1.221979 nb60 <- dnearneigh(xycoords, 0, 60) G60 <- localG(xyz$val, nb2listw(nb60, style=\"B\")) G60[length(xyz$val)-136] #> [1] 1.748098 nb90 <- dnearneigh(xycoords, 0, 90) G90 <- localG(xyz$val, nb2listw(nb90, style=\"B\")) G90[length(xyz$val)-136] #> [1] 1.986135 nb120 <- dnearneigh(xycoords, 0, 120) G120 <- localG(xyz$val, nb2listw(nb120, style=\"B\")) G120[length(xyz$val)-136] #> [1] 1.893374 nb150 <- dnearneigh(xycoords, 0, 150) G150 <- localG(xyz$val, nb2listw(nb150, style=\"B\")) G150[length(xyz$val)-136] #> [1] 1.237454 brks <- seq(-5,5,1) cm.col <- cm.colors(length(brks)-1) image(x, y, t(matrix(G30, nrow=16, ncol=16, byrow=TRUE)),   breaks=brks, col=cm.col, asp=1) text(xyz$x, xyz$y, round(G30, digits=1), cex=0.7) polygon(c(195,225,225,195), c(195,195,225,225), lwd=2) title(main=expression(paste(\"Values of the \", G[i], \" statistic\")))  G30s <- localG(xyz$val, nb2listw(include.self(nb30),  style=\"B\")) cat(\"value according to Getis and Ord's eq. 14.2, p. 263 (1996)\\n\") #> value according to Getis and Ord's eq. 14.2, p. 263 (1996) G30s[length(xyz$val)-136] #> [1] 1.45078 cat(paste(\"value given by Getis and Ord (1996), p. 267\",   \"(division by n-1 rather than n \\n in variance)\\n\")) #> value given by Getis and Ord (1996), p. 267 (division by n-1 rather than n  #>  in variance) G30s[length(xyz$val)-136] *   (sqrt(sum(scale(xyz$val, scale=FALSE)^2)/length(xyz$val)) /   sqrt(var(xyz$val))) #> [1] 1.447943 image(x, y, t(matrix(G30s, nrow=16, ncol=16, byrow=TRUE)),   breaks=brks, col=cm.col, asp=1) text(xyz$x, xyz$y, round(G30s, digits=1), cex=0.7) polygon(c(195,225,225,195), c(195,195,225,225), lwd=2) title(main=expression(paste(\"Values of the \", G[i]^\"*\", \" statistic\")))"},{"path":"https://r-spatial.github.io/spdep/reference/localGS.html","id":null,"dir":"Reference","previous_headings":"","what":"A local hotspot statistic for analysing multiscale datasets — localGS","title":"A local hotspot statistic for analysing multiscale datasets — localGS","text":"function implements \\(GS_i\\) test statistic local hotspots specific pairwise evaluated distance bands, proposed Westerholt et al. (2015).  Like hotspot estimator \\(G_i^*\\), \\(GS_i\\) statistic given z-scores can evaluated accordingly. idea method identify hotspots datasets comprise several, difficult--separate processes operating different scales. often case complex user-generated datasets Twitter feeds. example, football match reflected tweets pubs, homes, stadium vicinity. exemplified phenomena represent different processes may detected different geometric scales. \\(GS_i\\) method enables identification specifying geometric scale band strictly calculating statistical quantities mean variance solely respective relevant observations interact range adjusted scale band. addition, neighbourhood relationships respective central unit, scale-relevant relationships considered. way, hotspots can detected specific scale ranges independently scales. statistic given : $$GS_i = \\frac{\\displaystyle\\sum_{j; k < j}{w_{ij}w_{ik}\\phi_{jk}a_{jk}} - \\frac{W_i}{\\Phi} \\displaystyle\\sum_{j; k < j}{\\phi_{jk}a_{jk}}}{\\sqrt{\\frac{W_i}{\\Phi}\\displaystyle\\sum_{j; k < j}{\\phi_{jk}a_{jk}^2} + \\frac{W_i\\left(W_i-1\\right)}{\\Phi\\left(\\Phi-1\\right)}\\left(\\Gamma^2 -\\!\\! \\displaystyle\\sum_{j; k < j}{\\left(\\phi_{jk}a_{jk}\\right)^2}\\right) - \\left(\\frac{W_i}{\\Phi}\\displaystyle\\sum_{j; k < j}{\\phi_{jk}a_{jk}}\\right)^2}}$$ $$a_{jk} = x_j + x_k,\\;\\;\\; W_i = \\displaystyle\\sum_{j; k < j}{w_{ij}w_{ik}\\phi_{jk}},\\;\\;\\; \\Phi = \\displaystyle\\sum_{j; k < j}{\\phi_{jk}},\\;\\;\\; \\textrm{} \\;\\;\\; \\Gamma = \\displaystyle\\sum_{j; k < j}{\\phi_{jk}a_{jk}}.$$","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localGS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A local hotspot statistic for analysing multiscale datasets — localGS","text":"","code":"localGS(x, listw, dmin, dmax, attr, longlat = NULL)"},{"path":"https://r-spatial.github.io/spdep/reference/localGS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A local hotspot statistic for analysing multiscale datasets — localGS","text":"x sf sp object listw listw object dmin lower distance bound (greater equal) dmax upper distance bound (less equal) attr name attribute interest longlat default NULL; TRUE point coordinates longitude-latitude decimal degrees, case distances measured kilometres; x SpatialPoints object, value taken object , overrides argument NULL; distances measured map units FALSE NULL","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localGS.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A local hotspot statistic for analysing multiscale datasets — localGS","text":"pairs observations shared distance (map units) interval [dmin, dmax] within maximum radius dmax around corresponding output observation considered. Thereby, also mean values variance terms estimated within measure adjusted scale range consideration. application examples method see Westerholt et al. (2015) (applied tweets) Sonea & Westerholt (2021) (applied access banking scenario).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localGS.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A local hotspot statistic for analysing multiscale datasets — localGS","text":"vector \\(GS_i\\) values given z-scores.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localGS.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"A local hotspot statistic for analysing multiscale datasets — localGS","text":"Westerholt, R., Resch, B. & Zipf, . 2015. local scale-sensitive indicator spatial autocorrelation assessing high-low-value clusters multiscale datasets. International Journal Geographical Information Science, 29(5), 868–887, doi:10.1080/13658816.2014.1002499 . Sonea, . Westerholt, R. (2021): Geographic temporal access basic banking services Wales. Applied Spatial Analysis Policy, 14 (4), 879–905, doi:10.1007/s12061-021-09386-3 .","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localGS.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"A local hotspot statistic for analysing multiscale datasets — localGS","text":"René Westerholt rene.westerholt@tu-dortmund.de","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/localGS.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"A local hotspot statistic for analysing multiscale datasets — localGS","text":"","code":"# \\donttest{ boston.tr <- sf::st_read(system.file(\"shapes/boston_tracts.gpkg\", package=\"spData\")[1]) #> Reading layer `boston_tracts' from data source  #>   `/home/rsb/lib/r_libs/spData/shapes/boston_tracts.gpkg' using driver `GPKG' #> Simple feature collection with 506 features and 36 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -71.52311 ymin: 42.00305 xmax: -70.63823 ymax: 42.67307 #> Geodetic CRS:  NAD27 boston.tr_utm <- st_transform(boston.tr, 32619) #26786  boston_listw1 <- nb2listwdist(dnearneigh(st_centroid(boston.tr_utm), 1, 2000),     boston.tr_utm, type = \"dpd\", alpha = 2, zero.policy = TRUE, dmax = 9500) #> Warning: st_centroid assumes attributes are constant over geometries #> Warning: neighbour object has 120 sub-graphs  boston_listw2 <- nb2listwdist(dnearneigh(st_centroid(boston.tr_utm), 5000, 9500),      boston.tr_utm, type = \"dpd\", alpha = 2, zero.policy = TRUE, dmax = 9500) #> Warning: st_centroid assumes attributes are constant over geometries  boston_RM_gsi_1 <- localGS(boston.tr_utm, boston_listw1, 1, 2000, \"RM\", FALSE) boston_RM_gsi_2 <- localGS(boston.tr_utm, boston_listw2, 2000, 9500, \"RM\", FALSE) # }"},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_bv.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the local bivariate join count — local_joincount_bv","title":"Calculate the local bivariate join count — local_joincount_bv","text":"bivariate join count (BJC) evaluates event occurrences predefined regions tests co-occurrence events deviates complete spatial randomness.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_bv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the local bivariate join count — local_joincount_bv","text":"","code":"local_joincount_bv(   x,   z,   listw,   nsim = 199,   alternative = \"two.sided\" )"},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_bv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the local bivariate join count — local_joincount_bv","text":"x binary variable either numeric logical z binary variable either numeric logical length x listw listw object containing binary weights created, example, nb2listw(nb, style = \"B\") nsim number conditional permutation simulations alternative default \"greater\". One \"less\" \"greater\".","code":""},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_bv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the local bivariate join count — local_joincount_bv","text":"two cases evaluated bivariate join count. first -situ colocation (CLC) xi = 1 zi = 1. second general form bivariate join count (BJC) used -situ colocation. BJC case \"useful x z occur location, x z correspond two different values single categorical variable\" \"x z can co-locate, \" (Anselin Li, 2019). Whereas CLC case useful evaluating simultaneous occurrences events. local bivariate join count statistic requires binary weights list can generated nb2listw(nb, style = \"B\"). P-values reported regions match CLC BJC criteria. Others associated p-value. P-values estimated using conditional permutation approach. creates reference distribution observed statistic compared.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_bv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the local bivariate join count — local_joincount_bv","text":"data.frame two columns join_count p_sim number rows equal length arguments x.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_bv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate the local bivariate join count — local_joincount_bv","text":"Anselin, L., & Li, X. (2019). Operational Local Join Count Statistics Cluster Detection. Journal geographical systems, 21(2), 189–210. doi:10.1007/s10109-019-00299-x","code":""},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_bv.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate the local bivariate join count — local_joincount_bv","text":"Josiah Parry josiah.parry@gmail.com","code":""},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_bv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the local bivariate join count — local_joincount_bv","text":"","code":"data(\"oldcol\") listw <- nb2listw(COL.nb, style = \"B\") # Colocation case x <- COL.OLD[[\"CP\"]] z <- COL.OLD[[\"EW\"]] set.seed(1) res <- local_joincount_bv(x, z, listw) na.omit(res) #>    join_count p_sim #> 9           2 0.480 #> 19          3 0.180 #> 20          4 0.020 #> 21          3 0.040 #> 22          3 0.060 #> 23          4 0.070 #> 24          5 0.005 #> 27          2 0.300 #> 28          3 0.050 #> 29          5 0.010 #> 30          5 0.010 #> 31          9 0.005 #> 32          4 0.090 #> 33          4 0.055 # no colocation case z <- 1 - x set.seed(1) res <- local_joincount_bv(x, z, listw) na.omit(res) #>    join_count p_sim #> 9           2 0.065 #> 19          3 0.300 #> 20          1 0.015 #> 21          1 0.040 #> 22          1 0.045 #> 23          3 0.165 #> 24          1 0.000 #> 27          2 0.230 #> 28          1 0.050 #> 29          1 0.000 #> 36          1 0.000 #> 37          2 0.005 #> 38          2 0.185 #> 39          2 0.265 #> 40          1 0.005 #> 43          1 0.070"},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_uni.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the local univariate join count — local_joincount_uni","title":"Calculate the local univariate join count — local_joincount_uni","text":"univariate local join count statistic used identify clusters rarely occurring binary variables. binary variable interest occur less half time.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_uni.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the local univariate join count — local_joincount_uni","text":"","code":"local_joincount_uni(   fx,   chosen,   listw,   alternative = \"two.sided\",   nsim = 199,   iseed = NULL,   no_repeat_in_row=FALSE )"},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_uni.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the local univariate join count — local_joincount_uni","text":"fx binary variable either numeric logical chosen scalar character containing level fx considered observed value (1). listw listw object containing binary weights created, example, nbwlistw(nb, style = \"B\") alternative default \"greater\". One \"less\" \"greater\". nsim number conditional permutation simulations iseed default NULL, used set seed; output reproducible count CPU cores across computation distributed no_repeat_in_row default FALSE, TRUE, sample conditionally row without replacements avoid duplicate values, https://github.com/r-spatial/spdep/issues/124","code":""},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_uni.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate the local univariate join count — local_joincount_uni","text":"data.frame two columns BB Pr() number rows equal length x.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_uni.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate the local univariate join count — local_joincount_uni","text":"local join count statistic requires binary weights list can generated nb2listw(nb, style = \"B\"). Additionally, ensure binary variable interest rarely occurring half observations. P-values estimated using conditional permutation approach. creates reference distribution observed statistic compared. see Geoda Glossary.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_uni.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate the local univariate join count — local_joincount_uni","text":"Anselin, L., & Li, X. (2019). Operational Local Join Count Statistics Cluster Detection. Journal geographical systems, 21(2), 189–210. doi:10.1007/s10109-019-00299-x","code":""},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_uni.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate the local univariate join count — local_joincount_uni","text":"Josiah Parry josiah.parry@gmail.com","code":""},{"path":"https://r-spatial.github.io/spdep/reference/local_joincount_uni.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the local univariate join count — local_joincount_uni","text":"","code":"data(oldcol) fx <- as.factor(ifelse(COL.OLD$CRIME < 35, \"low-crime\", \"high-crime\")) listw <- nb2listw(COL.nb, style = \"B\") set.seed(1) (res <- local_joincount_uni(fx, chosen = \"high-crime\", listw)) #>    BB Pr(z != E(BBi)) #> 1   0              NA #> 2   0              NA #> 3   4            0.50 #> 4   0              NA #> 5   0              NA #> 6   0              NA #> 7   4            0.89 #> 8   0              NA #> 9   5            0.11 #> 10  0              NA #> 11  0              NA #> 12  0              NA #> 13  0              NA #> 14  0              NA #> 15  0              NA #> 16  0              NA #> 17  0              NA #> 18  0              NA #> 19  0              NA #> 20  3            0.55 #> 21  2            0.84 #> 22  3            0.30 #> 23  4            0.61 #> 24  5            0.12 #> 25  0              NA #> 26  0              NA #> 27  0              NA #> 28  0              NA #> 29  3            0.98 #> 30  5            0.09 #> 31  8            0.01 #> 32  7            0.02 #> 33  6            0.02 #> 34  5            0.04 #> 35  7            0.03 #> 36  8            0.02 #> 37  6            0.05 #> 38  5            0.04 #> 39  3            0.44 #> 40  5            0.14 #> 41  3            0.13 #> 42  5            0.05 #> 43  2            0.63 #> 44  0              NA #> 45  0              NA #> 46  0              NA #> 47  0              NA #> 48  0              NA #> 49  0              NA"},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.exact.html","id":null,"dir":"Reference","previous_headings":"","what":"Exact local Moran's Ii tests — localmoran.exact","title":"Exact local Moran's Ii tests — localmoran.exact","text":"localmoran.exact provides exact local Moran's Ii tests null hypothesis, localmoran.exact.alt provides exact local Moran's Ii tests alternative hypothesis. case, model may fitted model derived model fitted spatialreg::errorsarlm, covariance matrix can passed Omega= argument.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.exact.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exact local Moran's Ii tests — localmoran.exact","text":"","code":"localmoran.exact(model, select, nb, glist = NULL, style = \"W\",   zero.policy = NULL, alternative = \"two.sided\", spChk = NULL,   resfun = weighted.residuals, save.Vi = FALSE, useTP=FALSE, truncErr=1e-6,   zeroTreat=0.1) localmoran.exact.alt(model, select, nb, glist = NULL, style = \"W\",  zero.policy = NULL, alternative = \"two.sided\", spChk = NULL,  resfun = weighted.residuals, Omega = NULL, save.Vi = FALSE,  save.M = FALSE, useTP=FALSE, truncErr=1e-6, zeroTreat=0.1) # S3 method for class 'localmoranex' print(x, ...) # S3 method for class 'localmoranex' as.data.frame(x, row.names=NULL, optional=FALSE, ...)"},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.exact.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exact local Moran's Ii tests — localmoran.exact","text":"model object class lm returned lm (assuming global spatial autocorrelation), object class sarlm returned spatial simultaneous autoregressive model fit (assuming global spatial autocorrelation represented model spatial coefficient); weights may specified lm fit, offsets used select integer vector id. numbers zones tested; missing, zones nb list neighbours class nb glist list general weights corresponding neighbours style can take values W, B, C, S zero.policy default NULL, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA alternative character string specifying alternative hypothesis, must one greater (default), less two.sided. spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() resfun default: weighted.residuals; function used extract residuals lm object, may residuals, weighted.residuals, rstandard, rstudent Omega SAR process matrix may passed test alternative hypothesis, example Omega <- invIrW(listw, rho=0.1); Omega <- tcrossprod(Omega), chol() taken internally save.Vi TRUE, return star-shaped weights lists zone tested save.M TRUE, save list left right M products useTP default FALSE, TRUE, use truncation point integration rather upper=Inf, see Tiefelsdorf (2000), eq. 6.7, p.69 truncErr useTP=TRUE, pass truncation error truncation point function zeroTreat useTP=TRUE, pass zero adjustment truncation point function x object printed row.names ignored argument .data.frame.localmoranex; row names assigned localmoranex object optional ignored argument .data.frame.localmoranex; row names assigned localmoranex object ... arguments passed ","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.exact.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exact local Moran's Ii tests — localmoran.exact","text":"list class localmoranex containing \"select\" lists,  class moranex following components: statistic value exact standard deviate global Moran's . p.value p-value test. estimate value observed local Moran's Ii. method character string giving method used. alternative character string describing alternative hypothesis. gamma eigenvalues (two extreme values null, vector alternative) oType usually set \"E\", set \"N\" integration leads domain value qnorm, Normal assumption substituted. occurs output p-value close zero data.name character string giving name(s) data. df degrees freedom zone tested Vi zone tested alternative tested, list left right M products attribute M.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.exact.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Exact local Moran's Ii tests — localmoran.exact","text":"Bivand RS, Müller W, Reder M (2009) Power calculations global local Moran’s . Comput Stat Data Anal 53:2859–2872; Bivand RS, Wong DWS 2018 Comparing implementations global local indicators spatial association. TEST, 27(3), 716–748 doi:10.1007/s11749-018-0599-x","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.exact.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Exact local Moran's Ii tests — localmoran.exact","text":"Markus Reder Roger Bivand","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.exact.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exact local Moran's Ii tests — localmoran.exact","text":"","code":"eire <- st_read(system.file(\"shapes/eire.gpkg\", package=\"spData\")[1]) #> Reading layer `eire' from data source  #>   `/home/rsb/lib/r_libs/spData/shapes/eire.gpkg' using driver `GPKG' #> Simple feature collection with 26 features and 10 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -4.12 ymin: 5768 xmax: 300.82 ymax: 6119.25 #> Projected CRS: Undefined Cartesian SRS with unknown unit row.names(eire) <- as.character(eire$names) eire.nb <- poly2nb(eire) e.lm <- lm(OWNCONS ~ ROADACC, data=eire) localmoran.sad(e.lm, nb=eire.nb) #>              Local Morans I Saddlepoint    Pr. (Sad) #> 1 Carlow         0.21699668  0.95074844 3.417321e-01 #> 2 Cavan         -0.37257361 -1.00603119 3.144006e-01 #> 3 Clare          0.23197510  0.67166518 5.017969e-01 #> 4 Cork           0.78193548  1.74761575 8.053059e-02 #> 5 Donegal       -1.69064059 -1.72031078 8.537596e-02 #> 6 Dublin        -0.16069692 -0.35212627 7.247436e-01 #> 7 Galway         1.31371473  2.66849536 7.619183e-03 #> 8 Kerry          0.36534866  0.78073279 4.349597e-01 #> 9 Kildare       -0.02557544  0.04167665 9.667565e-01 #> 10 Kilkenny      0.57684331  1.70897697 8.745521e-02 #> 11 Laoghis      -0.05951798 -0.12155465 9.032517e-01 #> 12 Leitrim       0.38484587  1.47227033 1.409479e-01 #> 13 Limerick      0.11817987  0.45727712 6.474719e-01 #> 14 Longford      1.41643200  2.51113769 1.203427e-02 #> 15 Louth         0.56242920  1.07441571 2.826364e-01 #> 16 Mayo          0.87572704  2.05251226 4.011990e-02 #> 17 Meath         0.00367856  0.12813539 8.980418e-01 #> 18 Monaghan      0.55098311  1.23999193 2.149784e-01 #> 19 Offaly        0.15155556  0.80786519 4.191682e-01 #> 20 Roscommon     2.04368839  4.53187292 5.846302e-06 #> 21 Sligo        -0.47579871 -0.94578114 3.442602e-01 #> 22 Tipperary    -0.03454106 -0.06919691 9.448329e-01 #> 23 Waterford     0.85723423  1.91385108 5.563919e-02 #> 24 Westmeath     0.45138572  1.36017204 1.737755e-01 #> 25 Wexford       0.64371834  1.63188492 1.027037e-01 #> 26 Wicklow       0.02441950  0.21197000 8.321304e-01 localmoran.exact(e.lm, nb=eire.nb) #>              Local Morans I    Exact SD  Pr. (exact) #> 1 Carlow         0.21699668  1.02706083 3.043918e-01 #> 2 Cavan         -0.37257361 -1.04864802 2.943401e-01 #> 3 Clare          0.23197510  0.76362894 4.450884e-01 #> 4 Cork           0.78193548  1.77727656 7.552275e-02 #> 5 Donegal       -1.69064059 -1.74428756 8.110896e-02 #> 6 Dublin        -0.16069692 -0.44236119 6.582279e-01 #> 7 Galway         1.31371473  2.69199974 7.102500e-03 #> 8 Kerry          0.36534866  0.85742696 3.912090e-01 #> 9 Kildare       -0.02557544 -0.03475476 9.722753e-01 #> 10 Kilkenny      0.57684331  1.74146177 8.160267e-02 #> 11 Laoghis      -0.05951798 -0.21824035 8.272419e-01 #> 12 Leitrim       0.38484587  1.51434641 1.299380e-01 #> 13 Limerick      0.11817987  0.56922630 5.692026e-01 #> 14 Longford      1.41643200  2.53491837 1.124735e-02 #> 15 Louth         0.56242920  1.12775107 2.594251e-01 #> 16 Mayo          0.87572704  2.08125803 3.741029e-02 #> 17 Meath         0.00367856  0.16372685 8.699462e-01 #> 18 Monaghan      0.55098311  1.28435459 1.990179e-01 #> 19 Offaly        0.15155556  0.89537870 3.705847e-01 #> 20 Roscommon     2.04368839  4.55244870 5.302509e-06 #> 21 Sligo        -0.47579871 -0.98101752 3.265841e-01 #> 22 Tipperary    -0.03454106 -0.16132608 8.718366e-01 #> 23 Waterford     0.85723423  1.94188723 5.215075e-02 #> 24 Westmeath     0.45138572  1.40091422 1.612397e-01 #> 25 Wexford       0.64371834  1.66488051 9.593660e-02 #> 26 Wicklow       0.02441950  0.29717701 7.663314e-01 localmoran.exact(e.lm, nb=eire.nb, useTP=TRUE) #>              Local Morans I    Exact SD  Pr. (exact) #> 1 Carlow         0.21699668  1.02706127 3.043916e-01 #> 2 Cavan         -0.37257361 -1.04864834 2.943400e-01 #> 3 Clare          0.23197510  0.76362936 4.450881e-01 #> 4 Cork           0.78193548  1.77727666 7.552273e-02 #> 5 Donegal       -1.69064059 -1.74428741 8.110899e-02 #> 6 Dublin        -0.16069692 -0.44236158 6.582276e-01 #> 7 Galway         1.31371473  2.69199162 7.102673e-03 #> 8 Kerry          0.36534866  0.85742736 3.912087e-01 #> 9 Kildare       -0.02557544 -0.03540278 9.717586e-01 #> 10 Kilkenny      0.57684331  1.74146192 8.160264e-02 #> 11 Laoghis      -0.05951798 -0.21823772 8.272439e-01 #> 12 Leitrim       0.38484587  1.51434680 1.299379e-01 #> 13 Limerick      0.11817987  0.56922674 5.692023e-01 #> 14 Longford      1.41643200  2.53491383 1.124750e-02 #> 15 Louth         0.56242920  1.12775145 2.594249e-01 #> 16 Mayo          0.87572704  2.08125778 3.741032e-02 #> 17 Meath         0.00367856  0.15714487 8.751307e-01 #> 18 Monaghan      0.55098311  1.28435495 1.990178e-01 #> 19 Offaly        0.15155556  0.89537914 3.705844e-01 #> 20 Roscommon     2.04368839  4.53362873 5.797890e-06 #> 21 Sligo        -0.47579871 -0.98101780 3.265840e-01 #> 22 Tipperary    -0.03454106 -0.16116590 8.719627e-01 #> 23 Waterford     0.85723423  1.94188711 5.215077e-02 #> 24 Westmeath     0.45138572  1.40091457 1.612396e-01 #> 25 Wexford       0.64371834  1.66488069 9.593656e-02 #> 26 Wicklow       0.02441950  0.29790569 7.657751e-01 run <- FALSE if (requireNamespace(\"spatialreg\", quietly=TRUE)) run <- TRUE if (run) { e.errorsar <- spatialreg::errorsarlm(OWNCONS ~ ROADACC, data=eire,  listw=nb2listw(eire.nb)) lm.target <- lm(e.errorsar$tary ~ e.errorsar$tarX - 1) localmoran.exact.alt(lm.target, nb=eire.nb) } #>              Local Morans I    Exact SD Pr. (exact) #> 1 Carlow         0.17958462  0.83313548 0.404768327 #> 2 Cavan         -0.24752628 -0.82861508 0.407322251 #> 3 Clare         -0.27901334 -0.72313220 0.469598670 #> 4 Cork           0.37808655  1.15083938 0.249798320 #> 5 Donegal       -1.01894688 -1.50937607 0.131202704 #> 6 Dublin        -0.18171297 -0.50995181 0.610085224 #> 7 Galway         1.02193390  2.27605549 0.022842689 #> 8 Kerry         -0.94967914 -1.46954733 0.141684395 #> 9 Kildare        0.07005053  0.56174770 0.574287931 #> 10 Kilkenny      0.43022231  1.39078833 0.164289622 #> 11 Laoghis      -0.12239133 -0.45750046 0.647311369 #> 12 Leitrim      -0.24203970 -0.84925558 0.395739092 #> 13 Limerick     -0.03214546 -0.13098232 0.895789292 #> 14 Longford      0.38307454  1.17909760 0.238359315 #> 15 Louth         0.21301552  0.62068302 0.534808204 #> 16 Mayo          0.93971200  1.94079901 0.052282661 #> 17 Meath         0.12484415  0.78747315 0.431004937 #> 18 Monaghan     -0.16109919 -0.48277561 0.629255068 #> 19 Offaly       -0.00632492  0.03008421 0.975999892 #> 20 Roscommon     1.02089429  2.64333471 0.008209384 #> 21 Sligo        -2.01629233 -2.54211789 0.011018300 #> 22 Tipperary    -0.10810709 -0.51063241 0.609608478 #> 23 Waterford     0.44099279  1.28152280 0.200010096 #> 24 Westmeath    -0.06329661 -0.26575204 0.790430182 #> 25 Wexford       0.30764883  1.02115599 0.307180540 #> 26 Wicklow      -0.01696406 -0.04109885 0.967217095 if (run) { Omega <- spatialreg::invIrW(nb2listw(eire.nb), rho=e.errorsar$lambda) Omega1 <- tcrossprod(Omega) localmoran.exact.alt(lm.target, nb=eire.nb, Omega=Omega1) } #>              Local Morans I     Exact SD  Pr. (exact) #> 1 Carlow         0.17958462  0.009413917 0.9924888919 #> 2 Cavan         -0.24752628 -1.416786314 0.1565454123 #> 3 Clare         -0.27901334 -1.512813055 0.1303271517 #> 4 Cork           0.37808655  0.078686494 0.9372819884 #> 5 Donegal       -1.01894688 -1.935314161 0.0529517556 #> 6 Dublin        -0.18171297 -1.226543250 0.2199943101 #> 7 Galway         1.02193390  1.477322295 0.1395892645 #> 8 Kerry         -0.94967914 -2.427948363 0.0151845050 #> 9 Kildare        0.07005053 -0.042522018 0.9660825597 #> 10 Kilkenny      0.43022231  0.488471215 0.6252161096 #> 11 Laoghis      -0.12239133 -1.091910863 0.2748722827 #> 12 Leitrim      -0.24203970 -1.631825829 0.1027161824 #> 13 Limerick     -0.03214546 -0.921751557 0.3566581813 #> 14 Longford      0.38307454  0.183273193 0.8545836671 #> 15 Louth         0.21301552 -0.184065307 0.8539622227 #> 16 Mayo          0.93971200  1.182398031 0.2370478040 #> 17 Meath         0.12484415 -0.060499926 0.9517574750 #> 18 Monaghan     -0.16109919 -1.342787509 0.1793407892 #> 19 Offaly       -0.00632492 -0.409598788 0.6821002863 #> 20 Roscommon     1.02089429  1.238387417 0.2155724441 #> 21 Sligo        -2.01629233 -3.623597237 0.0002905339 #> 22 Tipperary    -0.10810709 -1.227333133 0.2196974073 #> 23 Waterford     0.44099279  0.433358039 0.6647546796 #> 24 Westmeath    -0.06329661 -0.956519228 0.3388099748 #> 25 Wexford       0.30764883  0.141381248 0.8875687671 #> 26 Wicklow      -0.01696406 -0.783977878 0.4330530911 if (run) { localmoran.exact.alt(lm.target, nb=eire.nb, Omega=Omega1, useTP=TRUE) } #>              Local Morans I     Exact SD  Pr. (exact) #> 1 Carlow         0.17958462  0.009414171 0.9924886892 #> 2 Cavan         -0.24752628 -1.416786809 0.1565452674 #> 3 Clare         -0.27901334 -1.512813519 0.1303270338 #> 4 Cork           0.37808655  0.078686628 0.9372818822 #> 5 Donegal       -1.01894688 -1.935314436 0.0529517219 #> 6 Dublin        -0.18171297 -1.226543734 0.2199941280 #> 7 Galway         1.02193390  1.477322399 0.1395892367 #> 8 Kerry         -0.94967914 -2.427949220 0.0151844691 #> 9 Kildare        0.07005053 -0.042526751 0.9660787872 #> 10 Kilkenny      0.43022231  0.488471349 0.6252160152 #> 11 Laoghis      -0.12239133 -1.091912026 0.2748717711 #> 12 Leitrim      -0.24203970 -1.631826543 0.1027160320 #> 13 Limerick     -0.03214546 -0.921785589 0.3566404259 #> 14 Longford      0.38307454  0.183273325 0.8545835636 #> 15 Louth         0.21301552 -0.184065128 0.8539623631 #> 16 Mayo          0.93971200  1.182398127 0.2370477661 #> 17 Meath         0.12484415 -0.060499243 0.9517580190 #> 18 Monaghan     -0.16109919 -1.342788191 0.1793405681 #> 19 Offaly       -0.00632492 -0.407816672 0.6834082724 #> 20 Roscommon     1.02089429  1.238387488 0.2155724178 #> 21 Sligo        -2.01629233 -3.623590126 0.0002905419 #> 22 Tipperary    -0.10810709 -1.227335007 0.2196967033 #> 23 Waterford     0.44099279  0.433358168 0.6647545858 #> 24 Westmeath    -0.06329661 -0.956505669 0.3388168214 #> 25 Wexford       0.30764883  0.141381402 0.8875686460 #> 26 Wicklow      -0.01696406 -0.784451761 0.4327750768"},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.html","id":null,"dir":"Reference","previous_headings":"","what":"Local Moran's I statistic — localmoran","title":"Local Moran's I statistic — localmoran","text":"local spatial statistic Moran's calculated zone based spatial weights object used. values returned include Z-value, may used diagnostic tool. statistic : $$I_i = \\frac{(x_i-\\bar{x})}{{\\sum_{k=1}^{n}(x_k-\\bar{x})^2}/(n-1)}{\\sum_{j=1}^{n}w_{ij}(x_j-\\bar{x})}$$, expectation variance given Anselin (1995), Sokal et al. (1998) implemented .","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Local Moran's I statistic — localmoran","text":"","code":"localmoran(x, listw, zero.policy=attr(listw, \"zero.policy\"), na.action=na.fail,         conditional=TRUE, alternative = \"two.sided\", mlvar=TRUE,         spChk=NULL, adjust.x=FALSE) localmoran_perm(x, listw, nsim=499, zero.policy=attr(listw, \"zero.policy\"),          na.action=na.fail, alternative = \"two.sided\", mlvar=TRUE,         spChk=NULL, adjust.x=FALSE, sample_Ei=TRUE, iseed=NULL,         no_repeat_in_row=FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Local Moran's I statistic — localmoran","text":"x numeric vector length neighbours list listw listw listw object created example nb2listw zero.policy default default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA na.action function (default na.fail), can also na.omit na.exclude - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. na.pass used, zero substituted NA values calculating spatial lag. (Note na.exclude work properly starting R 1.9.0, na.omit na.exclude assign wrong classes 1.8.*) conditional default TRUE: expectation variance calculated using conditional randomization null (Sokal 1998 Eqs. A7 & A8). Elaboration changes available Sauer et al. (2021). FALSE: expectation variance calculated using total randomization null (Sokal 1998 Eqs. A3 & A4). alternative character string specifying alternative hypothesis, must one greater, less two.sided (default). mlvar default TRUE: values local Moran's reported using variance variable interest (sum squared deviances n), can reported sample variance, dividing (n-1) instead; used implementations. spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() adjust.x default FALSE, TRUE, x values observations neighbours omitted mean x nsim default 499, number conditonal permutation simulations sample_Ei default TRUE; conditional permutation, use sample $E_i$ values, analytical values, leaving variances calculated simulation. iseed default NULL, used set seed; output reproducible count CPU cores across computation distributed no_repeat_in_row default FALSE, TRUE, sample conditionally row without replacements avoid duplicate values, https://github.com/r-spatial/spdep/issues/124","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Local Moran's I statistic — localmoran","text":"values local Moran's divided variance (sample variance) variable interest accord Table 1, p. 103, formula (12), p. 99, Anselin (1995), rather formula (7), p. 98. variance local Moran statistic taken Sokal et al. (1998) p. 334, equations 4 & 5 equations 7 & 8 located depending user specification. default, implementation divides n, (n-1) calculating variance higher moments. Conditional code contributed Jeff Sauer Levi Wolf.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Local Moran's I statistic — localmoran","text":"Ii local moran statistic E.Ii expectation local moran statistic; localmoran_permthe permutation sample means Var.Ii variance local moran statistic; localmoran_permthe permutation sample standard deviations Z.Ii standard deviate local moran statistic; localmoran_perm based permutation sample means standard deviations Pr() p-value local moran statistic using pnorm(); localmoran_perm using standard deviatse based permutation sample means standard deviations Pr() Sim localmoran_perm, rank() punif() observed statistic rank [0, 1] p-values using alternative= Pr(folded) Sim simulation folded [0, 0.5] range ranked p-value (based https://github.com/pysal/esda/blob/4a63e0b5df1e754b17b5f1205b8cadcbecc5e061/esda/crand.py#L211-L213) Skewness localmoran_perm, output e1071::skewness() permutation samples underlying standard deviates Kurtosis localmoran_perm, output e1071::kurtosis() permutation samples underlying standard deviates addition, attribute data frame \"quadr\" mean median quadrant columns, column splitting demeaned variable lagged demeaned variable zero.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Local Moran's I statistic — localmoran","text":"Conditional permutations added comparative purposes; permutations whole data vector omitting observation . p-value adjustment, use p.adjust() p.adjustSP() output vector.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Local Moran's I statistic — localmoran","text":"Anselin, L. 1995. Local indicators spatial association, Geographical Analysis, 27, 93–115; Getis, . Ord, J. K. 1996 Local spatial statistics: overview. P. Longley M. Batty (eds) Spatial analysis: modelling GIS environment (Cambridge: Geoinformation International), 261–277; Sokal, R. R, Oden, N. L. Thomson, B. . 1998. Local Spatial Autocorrelation Biological Model. Geographical Analysis, 30. 331–354; Bivand RS, Wong DWS 2018 Comparing implementations global local indicators spatial association. TEST, 27(3), 716–748 doi:10.1007/s11749-018-0599-x ; Sauer, J., Oshan, T. M., Rey, S., & Wolf, L. J. 2021. Importance Null Hypotheses: Understanding Differences Local Moran’s Heteroskedasticity. Geographical Analysis. doi:10.1111/gean.12304 Bivand, R. (2022), R Packages Analyzing Spatial Data: Comparative Case Study Areal Data. Geographical Analysis, 54(3), 488-518. doi:10.1111/gean.12319","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Local Moran's I statistic — localmoran","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Local Moran's I statistic — localmoran","text":"","code":"data(afcon, package=\"spData\") oid <- order(afcon$id) resI <- localmoran(afcon$totcon, nb2listw(paper.nb)) printCoefmat(data.frame(resI[oid,], row.names=afcon$name[oid]),  check.names=FALSE) #>                                   Ii        E.Ii      Var.Ii        Z.Ii #> THE GAMBIA                3.7523e-01 -2.4317e-02  9.9646e-01  4.0025e-01 #> MALI                      4.6363e-01 -2.1841e-02  1.0896e-01  1.4708e+00 #> SENEGAL                   2.5670e-01 -3.4444e-03  3.3339e-02  1.4248e+00 #> BENIN                     1.9412e-01 -2.4556e-03  2.3792e-02  1.2744e+00 #> MAURITANIA                9.7053e-02 -5.7508e-03  5.5533e-02  4.3625e-01 #> NIGER                     2.3071e-01 -1.9459e-02  9.7310e-02  8.0198e-01 #> IVORY COAST               2.9004e-01 -6.9359e-03  5.2072e-02  1.3014e+00 #> GUINEA                    1.8263e-01 -2.2246e-03  1.6780e-02  1.4270e+00 #> BURKINA FASO              5.0828e-01 -1.9893e-02  1.1942e-01  1.5284e+00 #> LIBERIA                   1.8565e-01 -2.7127e-03  3.5982e-02  9.9300e-01 #> SIERRA LEONE              2.6523e-01 -1.6994e-02  3.4204e-01  4.8257e-01 #> GHANA                     1.4764e-01 -1.3414e-03  1.7817e-02  1.1161e+00 #> TOGO                      2.1934e-01 -4.9892e-03  6.6025e-02  8.7305e-01 #> CAMEROON                  2.5925e-01 -1.1009e-02  8.2313e-02  9.4198e-01 #> NIGERIA                   1.1377e-01 -9.6126e-04  9.3272e-03  1.1880e+00 #> GABON                     2.0366e-01 -5.4771e-03  1.1153e-01  6.2625e-01 #> CENTRAL AFRICAN REPUBLIC -4.4206e-01 -1.0600e-02  7.9287e-02 -1.5323e+00 #> CHAD                     -1.0528e-01 -4.0998e-03  2.5008e-02 -6.3985e-01 #> CONGO                     1.1380e-02 -8.5953e-04  8.3410e-03  1.3402e-01 #> ZAIRE                     7.0978e-01 -5.9545e-02  2.0906e-01  1.6826e+00 #> ANGOLA                    1.1797e-01 -6.2140e-04  8.2594e-03  1.3050e+00 #> UGANDA                    1.9425e+00 -6.2812e-02  4.4503e-01  3.0060e+00 #> KENYA                     1.1969e+00 -1.6803e-02  1.2489e-01  3.4344e+00 #> TANZANIA                  2.7185e-01 -4.6254e-02  1.9107e-01  7.2774e-01 #> BURUNDI                  -4.8428e-01 -1.1009e-02  1.4481e-01 -1.2437e+00 #> RWANDA                   -7.5236e-01 -1.4730e-02  1.4096e-01 -1.9647e+00 #> SOMALIA                   4.5277e-01 -1.1751e-02  2.3778e-01  9.5260e-01 #> ETHIOPIA                  7.2512e-01 -5.4929e-03  7.2655e-02  2.7106e+00 #> ZAMBIA                    4.2160e-02 -8.1691e-04  3.5354e-03  7.2280e-01 #> ZIMBABWE                 -9.5068e-03 -6.0969e-03  5.8855e-02 -1.4056e-02 #> MALAWI                   -2.2888e-01 -1.0284e-02  1.3537e-01 -5.9413e-01 #> MOZAMBIQUE                1.6790e-02 -6.1629e-03  3.7515e-02  1.1850e-01 #> SOUTH AFRICA             -1.8254e-01 -5.4306e-03  2.7546e-02 -1.0671e+00 #> LESOTHO                  -4.1935e-01 -1.9263e-02  7.9348e-01 -4.4914e-01 #> BOTSWANA                 -3.9316e-03 -1.4141e-04  1.8805e-03 -8.7403e-02 #> SWAZILAND                 1.6684e-02 -2.8611e-02  5.6905e-01  6.0045e-02 #> MOROCCO                  -9.6961e-02 -5.1445e-03  1.0479e-01 -2.8363e-01 #> ALGERIA                  -1.0037e-02 -9.7828e-05  5.9914e-04 -4.0605e-01 #> TUNISIA                   5.3873e-03 -3.0273e-06  6.1985e-05  6.8466e-01 #> LIBYA                     8.0382e-01 -1.9923e-02  1.1960e-01  2.3820e+00 #> SUDAN                     2.9878e+00 -2.2835e-01  7.6320e-01  3.6814e+00 #> EGYPT                     6.9467e+00 -2.9968e-01  4.2971e+00  3.4957e+00 #>                          Pr.z....E.Ii.. #> THE GAMBIA                       0.6890 #> MALI                             0.1414 #> SENEGAL                          0.1542 #> BENIN                            0.2025 #> MAURITANIA                       0.6627 #> NIGER                            0.4226 #> IVORY COAST                      0.1931 #> GUINEA                           0.1536 #> BURKINA FASO                     0.1264 #> LIBERIA                          0.3207 #> SIERRA LEONE                     0.6294 #> GHANA                            0.2644 #> TOGO                             0.3826 #> CAMEROON                         0.3462 #> NIGERIA                          0.2348 #> GABON                            0.5312 #> CENTRAL AFRICAN REPUBLIC         0.1255 #> CHAD                             0.5223 #> CONGO                            0.8934 #> ZAIRE                            0.0925 #> ANGOLA                           0.1919 #> UGANDA                           0.0026 #> KENYA                            0.0006 #> TANZANIA                         0.4668 #> BURUNDI                          0.2136 #> RWANDA                           0.0494 #> SOMALIA                          0.3408 #> ETHIOPIA                         0.0067 #> ZAMBIA                           0.4698 #> ZIMBABWE                         0.9888 #> MALAWI                           0.5524 #> MOZAMBIQUE                       0.9057 #> SOUTH AFRICA                     0.2859 #> LESOTHO                          0.6533 #> BOTSWANA                         0.9304 #> SWAZILAND                        0.9521 #> MOROCCO                          0.7767 #> ALGERIA                          0.6847 #> TUNISIA                          0.4936 #> LIBYA                            0.0172 #> SUDAN                            0.0002 #> EGYPT                            0.0005 hist(resI[,5])  mean(resI[,1]) #> [1] 0.4167956 sum(resI[,1])/Szero(nb2listw(paper.nb)) #> [1] 0.4167956 moran.test(afcon$totcon, nb2listw(paper.nb)) #>  #> \tMoran I test under randomisation #>  #> data:  afcon$totcon   #> weights: nb2listw(paper.nb)     #>  #> Moran I statistic standard deviate = 4.3485, p-value = 6.854e-06 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>        0.41679563       -0.02439024        0.01029358  #>  # note equality for mean() only when the sum of weights equals # the number of observations (thanks to Juergen Symanzik) resI <- localmoran(afcon$totcon, nb2listw(paper.nb)) printCoefmat(data.frame(resI[oid,], row.names=afcon$name[oid]),  check.names=FALSE) #>                                   Ii        E.Ii      Var.Ii        Z.Ii #> THE GAMBIA                3.7523e-01 -2.4317e-02  9.9646e-01  4.0025e-01 #> MALI                      4.6363e-01 -2.1841e-02  1.0896e-01  1.4708e+00 #> SENEGAL                   2.5670e-01 -3.4444e-03  3.3339e-02  1.4248e+00 #> BENIN                     1.9412e-01 -2.4556e-03  2.3792e-02  1.2744e+00 #> MAURITANIA                9.7053e-02 -5.7508e-03  5.5533e-02  4.3625e-01 #> NIGER                     2.3071e-01 -1.9459e-02  9.7310e-02  8.0198e-01 #> IVORY COAST               2.9004e-01 -6.9359e-03  5.2072e-02  1.3014e+00 #> GUINEA                    1.8263e-01 -2.2246e-03  1.6780e-02  1.4270e+00 #> BURKINA FASO              5.0828e-01 -1.9893e-02  1.1942e-01  1.5284e+00 #> LIBERIA                   1.8565e-01 -2.7127e-03  3.5982e-02  9.9300e-01 #> SIERRA LEONE              2.6523e-01 -1.6994e-02  3.4204e-01  4.8257e-01 #> GHANA                     1.4764e-01 -1.3414e-03  1.7817e-02  1.1161e+00 #> TOGO                      2.1934e-01 -4.9892e-03  6.6025e-02  8.7305e-01 #> CAMEROON                  2.5925e-01 -1.1009e-02  8.2313e-02  9.4198e-01 #> NIGERIA                   1.1377e-01 -9.6126e-04  9.3272e-03  1.1880e+00 #> GABON                     2.0366e-01 -5.4771e-03  1.1153e-01  6.2625e-01 #> CENTRAL AFRICAN REPUBLIC -4.4206e-01 -1.0600e-02  7.9287e-02 -1.5323e+00 #> CHAD                     -1.0528e-01 -4.0998e-03  2.5008e-02 -6.3985e-01 #> CONGO                     1.1380e-02 -8.5953e-04  8.3410e-03  1.3402e-01 #> ZAIRE                     7.0978e-01 -5.9545e-02  2.0906e-01  1.6826e+00 #> ANGOLA                    1.1797e-01 -6.2140e-04  8.2594e-03  1.3050e+00 #> UGANDA                    1.9425e+00 -6.2812e-02  4.4503e-01  3.0060e+00 #> KENYA                     1.1969e+00 -1.6803e-02  1.2489e-01  3.4344e+00 #> TANZANIA                  2.7185e-01 -4.6254e-02  1.9107e-01  7.2774e-01 #> BURUNDI                  -4.8428e-01 -1.1009e-02  1.4481e-01 -1.2437e+00 #> RWANDA                   -7.5236e-01 -1.4730e-02  1.4096e-01 -1.9647e+00 #> SOMALIA                   4.5277e-01 -1.1751e-02  2.3778e-01  9.5260e-01 #> ETHIOPIA                  7.2512e-01 -5.4929e-03  7.2655e-02  2.7106e+00 #> ZAMBIA                    4.2160e-02 -8.1691e-04  3.5354e-03  7.2280e-01 #> ZIMBABWE                 -9.5068e-03 -6.0969e-03  5.8855e-02 -1.4056e-02 #> MALAWI                   -2.2888e-01 -1.0284e-02  1.3537e-01 -5.9413e-01 #> MOZAMBIQUE                1.6790e-02 -6.1629e-03  3.7515e-02  1.1850e-01 #> SOUTH AFRICA             -1.8254e-01 -5.4306e-03  2.7546e-02 -1.0671e+00 #> LESOTHO                  -4.1935e-01 -1.9263e-02  7.9348e-01 -4.4914e-01 #> BOTSWANA                 -3.9316e-03 -1.4141e-04  1.8805e-03 -8.7403e-02 #> SWAZILAND                 1.6684e-02 -2.8611e-02  5.6905e-01  6.0045e-02 #> MOROCCO                  -9.6961e-02 -5.1445e-03  1.0479e-01 -2.8363e-01 #> ALGERIA                  -1.0037e-02 -9.7828e-05  5.9914e-04 -4.0605e-01 #> TUNISIA                   5.3873e-03 -3.0273e-06  6.1985e-05  6.8466e-01 #> LIBYA                     8.0382e-01 -1.9923e-02  1.1960e-01  2.3820e+00 #> SUDAN                     2.9878e+00 -2.2835e-01  7.6320e-01  3.6814e+00 #> EGYPT                     6.9467e+00 -2.9968e-01  4.2971e+00  3.4957e+00 #>                          Pr.z....E.Ii.. #> THE GAMBIA                       0.6890 #> MALI                             0.1414 #> SENEGAL                          0.1542 #> BENIN                            0.2025 #> MAURITANIA                       0.6627 #> NIGER                            0.4226 #> IVORY COAST                      0.1931 #> GUINEA                           0.1536 #> BURKINA FASO                     0.1264 #> LIBERIA                          0.3207 #> SIERRA LEONE                     0.6294 #> GHANA                            0.2644 #> TOGO                             0.3826 #> CAMEROON                         0.3462 #> NIGERIA                          0.2348 #> GABON                            0.5312 #> CENTRAL AFRICAN REPUBLIC         0.1255 #> CHAD                             0.5223 #> CONGO                            0.8934 #> ZAIRE                            0.0925 #> ANGOLA                           0.1919 #> UGANDA                           0.0026 #> KENYA                            0.0006 #> TANZANIA                         0.4668 #> BURUNDI                          0.2136 #> RWANDA                           0.0494 #> SOMALIA                          0.3408 #> ETHIOPIA                         0.0067 #> ZAMBIA                           0.4698 #> ZIMBABWE                         0.9888 #> MALAWI                           0.5524 #> MOZAMBIQUE                       0.9057 #> SOUTH AFRICA                     0.2859 #> LESOTHO                          0.6533 #> BOTSWANA                         0.9304 #> SWAZILAND                        0.9521 #> MOROCCO                          0.7767 #> ALGERIA                          0.6847 #> TUNISIA                          0.4936 #> LIBYA                            0.0172 #> SUDAN                            0.0002 #> EGYPT                            0.0005 hist(p.adjust(resI[,5], method=\"bonferroni\"))  totcon <-afcon$totcon is.na(totcon) <- sample(1:length(totcon), 5) totcon #>  [1] 1363 1421 1861 2355 5246  811  299  358  895   NA   NA  933  347 1130  241 #> [16]  604 1015  998 2122 1090   NA   NA  758  423   NA 3087 2273 3134 1142  824 #> [31] 2881  487  604 1528 1554  629  792  795 1266 1875  147  363 resI.na <- localmoran(totcon, nb2listw(paper.nb), na.action=na.exclude,  zero.policy=TRUE) if (class(attr(resI.na, \"na.action\")) == \"exclude\") {  print(data.frame(resI.na[oid,], row.names=afcon$name[oid]), digits=2) } else print(resI.na, digits=2) #>                               Ii     E.Ii  Var.Ii  Z.Ii Pr.z....E.Ii.. #> THE GAMBIA                0.3528 -2.9e-02 1.03887  0.37          0.708 #> MALI                      0.4524 -2.6e-02 0.11007  1.44          0.149 #> SENEGAL                   0.2347 -3.3e-03 0.02800  1.42          0.155 #> BENIN                     0.1862 -2.2e-03 0.02572  1.17          0.240 #> MAURITANIA                0.0722 -6.0e-03 0.05043  0.35          0.728 #> NIGER                     0.1981 -2.3e-02 0.09763  0.71          0.480 #> IVORY COAST               0.3020 -7.4e-03 0.06218  1.24          0.215 #> GUINEA                    0.1774 -2.0e-03 0.01658  1.39          0.164 #> BURKINA FASO              0.5248 -2.3e-02 0.14950  1.42          0.156 #> LIBERIA                       NA       NA      NA    NA             NA #> SIERRA LEONE              0.2241 -2.0e-02 0.71575  0.29          0.773 #> GHANA                     0.1382 -1.0e-03 0.01854  1.02          0.307 #> TOGO                          NA       NA      NA    NA             NA #> CAMEROON                  0.1884 -1.2e-02 0.10306  0.63          0.532 #> NIGERIA                   0.0861 -6.6e-04 0.00556  1.16          0.245 #> GABON                     0.1828 -5.7e-03 0.10144  0.59          0.554 #> CENTRAL AFRICAN REPUBLIC      NA       NA      NA    NA             NA #> CHAD                      0.0657 -4.1e-03 0.03430  0.38          0.706 #> CONGO                    -0.0301 -5.6e-04 0.00652 -0.37          0.715 #> ZAIRE                     0.5651 -8.5e-02 0.34207  1.11          0.266 #> ANGOLA                    0.2017 -1.5e-03 0.01766  1.53          0.126 #> UGANDA                    1.5678 -9.0e-02 0.69207  1.99          0.046 #> KENYA                     1.3328 -2.6e-02 0.29012  2.52          0.012 #> TANZANIA                  0.4269 -6.7e-02 0.23117  1.03          0.304 #> BURUNDI                  -0.5611 -1.2e-02 0.14171 -1.46          0.145 #> RWANDA                   -0.8661 -1.7e-02 0.14069 -2.26          0.024 #> SOMALIA                   0.7805 -1.8e-02 0.66673  0.98          0.328 #> ETHIOPIA                      NA       NA      NA    NA             NA #> ZAMBIA                    0.0806 -1.9e-03 0.00690  0.99          0.321 #> ZIMBABWE                 -0.0393 -6.4e-03 0.05385 -0.14          0.887 #> MALAWI                   -0.2844 -1.1e-02 0.13166 -0.75          0.452 #> MOZAMBIQUE               -0.0121 -6.5e-03 0.03407 -0.03          0.976 #> SOUTH AFRICA             -0.2047 -9.1e-03 0.03947 -0.98          0.325 #> LESOTHO                  -0.5158 -2.3e-02 0.81614 -0.55          0.585 #> BOTSWANA                 -0.0025 -1.3e-05 0.00015 -0.20          0.838 #> SWAZILAND                -0.0494 -3.4e-02 0.59593 -0.02          0.984 #> MOROCCO                  -0.0936 -8.7e-03 0.15440 -0.22          0.829 #> ALGERIA                  -0.0143 -4.7e-04 0.00247 -0.28          0.780 #> TUNISIA                   0.0428 -1.5e-04 0.00268  0.83          0.406 #> LIBYA                     0.5764 -3.0e-02 0.19100  1.39          0.165 #> SUDAN                         NA       NA      NA    NA             NA #> EGYPT                     4.0118 -4.1e-01 8.97211  1.48          0.140 resG <- localG(afcon$totcon, nb2listw(include.self(paper.nb))) print(data.frame(resG[oid], row.names=afcon$name[oid]), digits=2) #>                          resG.oid. #> THE GAMBIA                  -0.984 #> MALI                        -1.699 #> SENEGAL                     -1.463 #> BENIN                       -1.301 #> MAURITANIA                  -0.605 #> NIGER                       -1.049 #> IVORY COAST                 -1.417 #> GUINEA                      -1.449 #> BURKINA FASO                -1.751 #> LIBERIA                     -1.041 #> SIERRA LEONE                -0.870 #> GHANA                       -1.103 #> TOGO                        -0.991 #> CAMEROON                    -1.133 #> NIGERIA                     -1.173 #> GABON                       -0.789 #> CENTRAL AFRICAN REPUBLIC     1.173 #> CHAD                         0.463 #> CONGO                       -0.203 #> ZAIRE                        2.023 #> ANGOLA                       1.235 #> UGANDA                       3.336 #> KENYA                        3.503 #> TANZANIA                     1.098 #> BURUNDI                      0.774 #> RWANDA                       1.457 #> SOMALIA                      1.183 #> ETHIOPIA                     2.627 #> ZAMBIA                       0.753 #> ZIMBABWE                    -0.200 #> MALAWI                       0.212 #> MOZAMBIQUE                  -0.288 #> SOUTH AFRICA                -0.868 #> LESOTHO                     -0.298 #> BOTSWANA                     0.041 #> SWAZILAND                   -0.659 #> MOROCCO                      0.022 #> ALGERIA                     -0.363 #> TUNISIA                      0.579 #> LIBYA                        2.553 #> SUDAN                        4.039 #> EGYPT                        4.421 set.seed(1) resI_p <- localmoran_perm(afcon$totcon, nb2listw(paper.nb)) printCoefmat(data.frame(resI_p[oid,], row.names=afcon$name[oid]),  check.names=FALSE) #>                                   Ii        E.Ii      Var.Ii        Z.Ii #> THE GAMBIA                3.7523e-01 -3.0853e-02  9.0476e-01  4.2692e-01 #> MALI                      4.6363e-01 -2.1690e-02  1.2192e-01  1.3899e+00 #> SENEGAL                   2.5670e-01 -1.1288e-02  3.2719e-02  1.4816e+00 #> BENIN                     1.9412e-01 -6.5012e-03  2.6046e-02  1.2431e+00 #> MAURITANIA                9.7053e-02 -2.0574e-03  5.7209e-02  4.1437e-01 #> NIGER                     2.3071e-01 -2.8428e-02  1.1981e-01  7.4867e-01 #> IVORY COAST               2.9004e-01 -8.1011e-03  5.5564e-02  1.2648e+00 #> GUINEA                    1.8263e-01  5.3454e-04  1.8397e-02  1.3425e+00 #> BURKINA FASO              5.0828e-01 -2.9727e-02  1.4019e-01  1.4369e+00 #> LIBERIA                   1.8565e-01 -1.9247e-03  3.6524e-02  9.8147e-01 #> SIERRA LEONE              2.6523e-01  1.0225e-02  3.1505e-01  4.5432e-01 #> GHANA                     1.4764e-01 -6.7639e-03  1.8646e-02  1.1307e+00 #> TOGO                      2.1934e-01 -1.8012e-03  6.5187e-02  8.6616e-01 #> CAMEROON                  2.5925e-01 -1.0726e-02  9.4789e-02  8.7688e-01 #> NIGERIA                   1.1377e-01 -2.5672e-03  8.7720e-03  1.2421e+00 #> GABON                     2.0366e-01 -3.5024e-03  1.0958e-01  6.2584e-01 #> CENTRAL AFRICAN REPUBLIC -4.4206e-01  2.3901e-02  8.1700e-02 -1.6302e+00 #> CHAD                     -1.0528e-01  5.9042e-03  3.0168e-02 -6.4016e-01 #> CONGO                     1.1380e-02  7.0349e-03  8.9435e-03  4.5949e-02 #> ZAIRE                     7.0978e-01 -2.9589e-02  2.9068e-01  1.3714e+00 #> ANGOLA                    1.1797e-01 -3.0421e-04  8.6526e-03  1.2716e+00 #> UGANDA                    1.9425e+00 -7.0491e-02  5.2046e-01  2.7903e+00 #> KENYA                     1.1969e+00 -1.6362e-02  1.3644e-01  3.2847e+00 #> TANZANIA                  2.7185e-01 -7.3309e-02  2.3454e-01  7.1272e-01 #> BURUNDI                  -4.8428e-01  9.5351e-03  1.4866e-01 -1.2807e+00 #> RWANDA                   -7.5236e-01 -4.0426e-02  1.7628e-01 -1.6956e+00 #> SOMALIA                   4.5277e-01 -1.1165e-02  2.6266e-01  9.0523e-01 #> ETHIOPIA                  7.2512e-01  8.3618e-04  7.8477e-02  2.5855e+00 #> ZAMBIA                    4.2160e-02 -5.1840e-03  3.6852e-03  7.7989e-01 #> ZIMBABWE                 -9.5068e-03 -6.5338e-03  6.5357e-02 -1.1629e-02 #> MALAWI                   -2.2888e-01  3.6276e-03  1.3417e-01 -6.3477e-01 #> MOZAMBIQUE                1.6790e-02 -2.0694e-03  4.5436e-02  8.8476e-02 #> SOUTH AFRICA             -1.8254e-01 -1.1611e-02  3.0240e-02 -9.8293e-01 #> LESOTHO                  -4.1935e-01 -6.6258e-02  8.7314e-01 -3.7787e-01 #> BOTSWANA                 -3.9316e-03 -4.7713e-03  2.2167e-03  1.7833e-02 #> SWAZILAND                 1.6684e-02 -8.4486e-02  6.4807e-01  1.2567e-01 #> MOROCCO                  -9.6961e-02 -2.1623e-03  1.1253e-01 -2.8260e-01 #> ALGERIA                  -1.0037e-02 -3.4326e-04  6.3541e-04 -3.8456e-01 #> TUNISIA                   5.3873e-03 -1.6456e-04  6.4187e-05  6.9298e-01 #> LIBYA                     8.0382e-01 -2.9038e-02  1.3319e-01  2.2821e+00 #> SUDAN                     2.9878e+00 -2.5952e-01  8.2522e-01  3.5747e+00 #> EGYPT                     6.9467e+00 -3.7869e-01  4.1318e+00  3.6038e+00 #>                          Pr.z....E.Ii.. Pr.z....E.Ii...Sim Pr.folded..Sim #> THE GAMBIA                   6.6944e-01         8.3200e-01     4.2800e-01 #> MALI                         1.6455e-01         8.8000e-02     4.4000e-02 #> SENEGAL                      1.3846e-01         6.4000e-02     3.2000e-02 #> BENIN                        2.1384e-01         1.3200e-01     6.6000e-02 #> MAURITANIA                   6.7860e-01         7.5600e-01     3.7800e-01 #> NIGER                        4.5406e-01         5.0000e-01     2.5000e-01 #> IVORY COAST                  2.0595e-01         1.1600e-01     5.8000e-02 #> GUINEA                       1.7943e-01         7.2000e-02     3.6000e-02 #> BURKINA FASO                 1.5075e-01         9.2000e-02     4.6000e-02 #> LIBERIA                      3.2636e-01         3.0400e-01     1.5200e-01 #> SIERRA LEONE                 6.4960e-01         8.2400e-01     4.1200e-01 #> GHANA                        2.5816e-01         1.8400e-01     9.2000e-02 #> TOGO                         3.8640e-01         3.6800e-01     1.8400e-01 #> CAMEROON                     3.8055e-01         4.3200e-01     2.1600e-01 #> NIGERIA                      2.1418e-01         1.4400e-01     7.2000e-02 #> GABON                        5.3142e-01         5.8400e-01     2.9600e-01 #> CENTRAL AFRICAN REPUBLIC     1.0306e-01         1.8400e-01     9.2000e-02 #> CHAD                         5.2207e-01         4.5200e-01     2.2600e-01 #> CONGO                        9.6335e-01         8.5600e-01     4.2800e-01 #> ZAIRE                        1.7026e-01         2.0000e-01     1.0000e-01 #> ANGOLA                       2.0353e-01         2.3600e-01     1.1800e-01 #> UGANDA                       5.2662e-03         4.0000e-02     2.0000e-02 #> KENYA                        1.0210e-03         8.0000e-03     4.0000e-03 #> TANZANIA                     4.7602e-01         4.2400e-01     2.1200e-01 #> BURUNDI                      2.0029e-01         2.6800e-01     1.3400e-01 #> RWANDA                       8.9953e-02         1.4000e-01     7.0000e-02 #> SOMALIA                      3.6535e-01         2.8800e-01     1.4600e-01 #> ETHIOPIA                     9.7244e-03         3.6000e-02     1.8000e-02 #> ZAMBIA                       4.3546e-01         4.1200e-01     2.0600e-01 #> ZIMBABWE                     9.9072e-01         8.6800e-01     4.3400e-01 #> MALAWI                       5.2558e-01         4.5600e-01     2.2800e-01 #> MOZAMBIQUE                   9.2950e-01         9.4400e-01     4.7200e-01 #> SOUTH AFRICA                 3.2564e-01         3.5200e-01     1.7600e-01 #> LESOTHO                      7.0553e-01         4.6800e-01     2.2400e-01 #> BOTSWANA                     9.8577e-01         8.4400e-01     4.2200e-01 #> SWAZILAND                    8.9999e-01         8.8400e-01     4.4200e-01 #> MOROCCO                      7.7749e-01         9.7600e-01     4.8800e-01 #> ALGERIA                      7.0057e-01         8.0400e-01     4.0200e-01 #> TUNISIA                      4.8832e-01         4.2800e-01     2.1600e-01 #> LIBYA                        2.2482e-02         4.8000e-02     2.4000e-02 #> SUDAN                        3.5067e-04         8.0000e-03     4.0000e-03 #> EGYPT                        3.1358e-04         1.6000e-02     8.0000e-03 #>                             Skewness Kurtosis #> THE GAMBIA               -1.7643e+00   3.3422 #> MALI                     -8.2875e-01   0.8397 #> SENEGAL                  -7.1779e-01   0.3689 #> BENIN                    -8.5318e-01   0.5520 #> MAURITANIA               -9.6301e-01   1.3949 #> NIGER                    -6.3767e-01   0.2577 #> IVORY COAST              -8.3750e-01   0.6786 #> GUINEA                   -8.8298e-01   0.7691 #> BURKINA FASO             -7.7665e-01   0.5911 #> LIBERIA                  -9.7191e-01   1.2327 #> SIERRA LEONE             -1.0737e+00   0.6367 #> GHANA                    -9.6554e-01   0.8587 #> TOGO                     -1.0772e+00   1.2283 #> CAMEROON                 -8.1844e-01   1.1746 #> NIGERIA                  -6.3061e-01   0.1168 #> GABON                    -1.1947e+00   1.1977 #> CENTRAL AFRICAN REPUBLIC -6.7964e-01  -0.1428 #> CHAD                     -9.5123e-01   0.8025 #> CONGO                    -9.5359e-01   0.9288 #> ZAIRE                     6.6929e-01   0.5829 #> ANGOLA                    1.0230e+00   1.0841 #> UGANDA                    9.6607e-01   1.3331 #> KENYA                     8.5205e-01   0.5240 #> TANZANIA                  8.5767e-01   1.2127 #> BURUNDI                  -1.0634e+00   0.9779 #> RWANDA                   -9.5905e-01   0.8365 #> SOMALIA                   1.5185e+00   2.7876 #> ETHIOPIA                  9.9587e-01   0.7374 #> ZAMBIA                    4.9495e-01   0.1900 #> ZIMBABWE                 -8.0240e-01   0.4192 #> MALAWI                   -1.1246e+00   1.7228 #> MOZAMBIQUE               -7.6989e-01   0.5793 #> SOUTH AFRICA              5.6394e-01   0.1988 #> LESOTHO                  -1.7905e+00   2.9865 #> BOTSWANA                 -9.4637e-01   0.5722 #> SWAZILAND                -1.3081e+00   1.7612 #> MOROCCO                   1.2705e+00   1.5574 #> ALGERIA                   6.3958e-01   0.2677 #> TUNISIA                   1.2498e+00   1.2249 #> LIBYA                     7.3453e-01   0.5219 #> SUDAN                     4.3993e-01  -0.1019 #> EGYPT                     1.1875e+00   1.6480"},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.sad.html","id":null,"dir":"Reference","previous_headings":"","what":"Saddlepoint approximation of local Moran's Ii tests — localmoran.sad","title":"Saddlepoint approximation of local Moran's Ii tests — localmoran.sad","text":"function implements Tiefelsdorf's application Saddlepoint approximation local Moran's Ii's reference distribution. model object class \"lm\", global independence assumed; class \"sarlm\", global dependence assumed represented spatial parameter model. Tests reported separately zone selected, may summarised using summary.localmoransad. Values local Moran's Ii agree localmoran(), function, standard deviate - Saddlepoint approximation - based randomisation assumption.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.sad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Saddlepoint approximation of local Moran's Ii tests — localmoran.sad","text":"","code":"localmoran.sad(model, select, nb, glist=NULL, style=\"W\",  zero.policy=NULL, alternative=\"two.sided\", spChk=NULL,  resfun=weighted.residuals, save.Vi=FALSE,  tol = .Machine$double.eps^0.5, maxiter = 1000, tol.bounds=0.0001,  save.M=FALSE, Omega = NULL) <!-- %as.data.frame.localmoransad(x, row.names=NULL, optional=FALSE)  --> # S3 method for class 'localmoransad' print(x, ...) # S3 method for class 'localmoransad' summary(object, ...) # S3 method for class 'summary.localmoransad' print(x, ...) listw2star(listw, ireg, style, n, D, a, zero.policy=attr(listw, \"zero.policy\"))"},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.sad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Saddlepoint approximation of local Moran's Ii tests — localmoran.sad","text":"model object class lm returned lm (assuming global spatial autocorrelation), object class sarlm returned spatial simultaneous autoregressive model fit (assuming global spatial autocorrelation represented model spatial coefficient); weights may specified lm fit, offsets used select integer vector id. numbers zones tested; missing, zones nb list neighbours class nb glist list general weights corresponding neighbours style can take values W, B, C, S zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA alternative character string specifying alternative hypothesis, must one greater (default), less two.sided. spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() resfun default: weighted.residuals; function used extract residuals lm object, may residuals, weighted.residuals, rstandard, rstudent save.Vi TRUE, return star-shaped weights lists zone tested tol desired accuracy (convergence tolerance) uniroot maxiter maximum number iterations uniroot tol.bounds offset bounds uniroot save.M TRUE, save list left right M products list conditional tests, list regression model matrix components Omega SAR process matrix may passed test alternative hypothesis, example Omega <- invIrW(listw, rho=0.1); Omega <- tcrossprod(Omega), chol() taken internally x object printed  object object summarised ... arguments passed listw listw object created example nb2listw ireg zone number n internal value depending listw style D internal value depending listw style internal value depending listw style","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.sad.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Saddlepoint approximation of local Moran's Ii tests — localmoran.sad","text":"function implements analytical eigenvalue calculation together trace shortcuts given suggested Tiefelsdorf (2002), partly following remarks J. Keith Ord, uses Saddlepoint analytical solution Tiefelsdorf's SPSS code. histogram probability values saddlepoint estimate assumption global independence approximately flat, assumption probably unjustified, re-estimation global dependence recommended. n n matrices needed point test assuming global dependence, star-shaped weights matrices handled listw lists. test made residuals spatial regression, taking global process account. n n matrices necessary, memory constraints may reached large lattices.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.sad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Saddlepoint approximation of local Moran's Ii tests — localmoran.sad","text":"list class localmoransad containing \"select\" lists,  class moransad following components: statistic value saddlepoint approximation  standard deviate local Moran's Ii. p.value p-value test. estimate value observed local Moran's Ii. alternative character string describing alternative hypothesis. method character string giving method used. data.name character string giving name(s) data. internal1 Saddlepoint omega, r u df degrees freedom tau maximum minimum analytical eigenvalues zone tested","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.sad.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Saddlepoint approximation of local Moran's Ii tests — localmoran.sad","text":"Tiefelsdorf, M. 2002 Saddlepoint approximation Moran's local Moran's Ii reference distributions numerical evaluation. Geographical Analysis, 34, pp. 187–206.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.sad.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Saddlepoint approximation of local Moran's Ii tests — localmoran.sad","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/localmoran.sad.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Saddlepoint approximation of local Moran's Ii tests — localmoran.sad","text":"","code":"eire <- st_read(system.file(\"shapes/eire.gpkg\", package=\"spData\")[1]) #> Reading layer `eire' from data source  #>   `/home/rsb/lib/r_libs/spData/shapes/eire.gpkg' using driver `GPKG' #> Simple feature collection with 26 features and 10 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -4.12 ymin: 5768 xmax: 300.82 ymax: 6119.25 #> Projected CRS: Undefined Cartesian SRS with unknown unit row.names(eire) <- as.character(eire$names) eire.nb <- poly2nb(eire) lw <- nb2listw(eire.nb) e.lm <- lm(OWNCONS ~ ROADACC, data=eire) e.locmor <- summary(localmoran.sad(e.lm, nb=eire.nb)) e.locmor #>              Local Morans I Stand. dev. (N)      Pr. (N) Saddlepoint #> 1 Carlow         0.21699668      0.74177148 4.582258e-01  0.95074844 #> 2 Cavan         -0.37257361     -0.81297374 1.583767e+00 -1.00603119 #> 3 Clare          0.23197510      0.49502499 6.205825e-01  0.67166518 #> 4 Cork           0.78193548      1.75999915 7.840795e-02  1.74761575 #> 5 Donegal       -1.69064059     -1.98244914 1.952571e+00 -1.72031078 #> 6 Dublin        -0.16069692     -0.15041940 1.119566e+00 -0.35212627 #> 7 Galway         1.31371473      3.34305297 8.286208e-04  2.66849536 #> 8 Kerry          0.36534866      0.58147812 5.609183e-01  0.78073279 #> 9 Kildare       -0.02557544      0.15146558 8.796085e-01  0.04167665 #> 10 Kilkenny      0.57684331      1.62868431 1.033799e-01  1.70897697 #> 11 Laoghis      -0.05951798      0.01724651 9.862400e-01 -0.12155465 #> 12 Leitrim       0.38484587      1.27548777 2.021367e-01  1.47227033 #> 13 Limerick      0.11817987      0.34038037 7.335701e-01  0.45727712 #> 14 Longford      1.41643200      3.10732224 1.887905e-03  2.51113769 #> 15 Louth         0.56242920      0.87665682 3.806731e-01  1.07441571 #> 16 Mayo          0.87572704      2.02375701 4.299516e-02  2.05251226 #> 17 Meath         0.00367856      0.16081712 8.722374e-01  0.12813539 #> 18 Monaghan      0.55098311      1.06684464 2.860420e-01  1.23999193 #> 19 Offaly        0.15155556      0.61933942 5.356928e-01  0.80786519 #> 20 Roscommon     2.04368839      6.66107106 2.718381e-11  4.53187292 #> 21 Sligo        -0.47579871     -0.73430274 1.537236e+00 -0.94578114 #> 22 Tipperary    -0.03454106      0.04843351 9.613708e-01 -0.06919691 #> 23 Waterford     0.85723423      1.98516133 4.712653e-02  1.91385108 #> 24 Westmeath     0.45138572      1.20305006 2.289569e-01  1.36017204 #> 25 Wexford       0.64371834      1.55468550 1.200210e-01  1.63188492 #> 26 Wicklow       0.02441950      0.21823347 8.272472e-01  0.21197000 #>                 Pr. (Sad) Expectation   Variance   Skewness Kurtosis    Minimum #> 1 Carlow     3.417321e-01 -0.06471134 0.14423085 -0.7895263 7.059116  -5.461326 #> 2 Cavan      3.144006e-01 -0.04030838 0.16703857 -0.4622793 6.813004  -5.567356 #> 3 Clare      5.017969e-01 -0.04219377 0.30674823 -0.3579185 6.761932  -7.406885 #> 4 Cork       8.053059e-02 -0.04363826 0.22003250 -0.4363325 6.799081  -6.360927 #> 5 Donegal    8.537596e-02 -0.11935726 0.62821008 -0.7004303 6.979051 -11.236382 #> 6 Dublin     7.247436e-01 -0.08240217 0.27093033 -0.7352902 7.009201  -7.420687 #> 7 Galway     7.619183e-03 -0.04389010 0.16491503 -0.5059997 6.838308  -5.573707 #> 8 Kerry      4.349597e-01 -0.03212369 0.46724761 -0.2212594 6.714810  -8.915104 #> 9 Kildare    9.667565e-01 -0.07623733 0.11187546 -1.0416026 7.339962  -4.999621 #> 10 Kilkenny  8.745521e-02 -0.05911601 0.15247016 -0.7040737 6.982131  -5.538889 #> 11 Laoghis   9.032517e-01 -0.06620117 0.15016408 -0.7915137 7.061015  -5.574277 #> 12 Leitrim   1.409479e-01 -0.06828680 0.12621127 -0.8864130 7.157471  -5.186756 #> 13 Limerick  6.474719e-01 -0.04172917 0.22070746 -0.4167943 6.789132  -6.348870 #> 14 Longford  1.203427e-02 -0.04055162 0.21985521 -0.4059156 6.783792  -6.324457 #> 15 Louth     2.826364e-01 -0.04386717 0.47831137 -0.2983105 6.738631  -9.149779 #> 16 Mayo      4.011990e-02 -0.10340651 0.23408152 -0.9804377 7.264328  -7.165847 #> 17 Meath     8.980418e-01 -0.04799533 0.10324707 -0.6949022 6.974408  -4.551176 #> 18 Monaghan  2.149784e-01 -0.04136950 0.30828917 -0.3501006 6.758633  -7.415047 #> 19 Offaly    4.191682e-01 -0.04662212 0.10238870 -0.6782821 6.960676  -4.519986 #> 20 Roscommon 5.846302e-06 -0.04435301 0.09826301 -0.6591526 6.945294  -4.414164 #> 21 Sligo     3.442602e-01 -0.11041170 0.24760301 -1.0156782 7.307311  -7.409091 #> 22 Tipperary 9.448329e-01 -0.04872132 0.08571886 -0.7716947 7.042300  -4.198353 #> 23 Waterford 5.563919e-02 -0.05435079 0.21086415 -0.5533724 6.868342  -6.353514 #> 24 Westmeath 1.737755e-01 -0.04181671 0.16806722 -0.4779156 6.821788  -5.599610 #> 25 Wexford   1.027037e-01 -0.05432673 0.20159596 -0.5654870 6.876461  -6.225016 #> 26 Wicklow   8.321304e-01 -0.07022471 0.18808122 -0.7515626 7.023792  -6.198974 #>               Maximum        omega       sad.r       sad.u #> 1 Carlow     3.908254  0.071122863  0.71853146  0.84900467 #> 2 Cavan      4.599954 -0.051532330 -0.69003582 -0.85816092 #> 3 Clare      6.394234  0.031939551  0.46982957  0.51656357 #> 4 Cork       5.313609  0.083281515  1.43928884  2.24323856 #> 5 Donegal    8.371808 -0.039371561 -1.39288713 -2.19776923 #> 6 Dublin     5.443035 -0.010354512 -0.14127218 -0.14554367 #> 7 Galway     4.520344  0.134873939  2.39189491  4.63522665 #> 8 Kerry      8.144135  0.028431952  0.54051534  0.61545648 #> 9 Kildare    3.169925  0.018723213  0.14926096  0.14688325 #> 10 Kilkenny  4.120105  0.105365819  1.40668493  2.15214600 #> 11 Laoghis   3.985449  0.001724096  0.01660985  0.01657177 #> 12 Leitrim   3.547872  0.109608339  1.18229964  1.66578026 #> 13 Limerick  5.347370  0.027585567  0.32820959  0.34241163 #> 14 Longford  5.351218  0.108368224  2.22687206  4.19385821 #> 15 Louth     8.096967  0.037745731  0.78968254  0.98878788 #> 16 Mayo      4.684091  0.105317102  1.75922892  2.94711915 #> 17 Meath     3.399289  0.020074178  0.15693992  0.15623206 #> 18 Monaghan  6.422179  0.053418031  0.94193428  1.24723730 #> 19 Offaly    3.401055  0.071432961  0.59871278  0.67858124 #> 20 Roscommon 3.349691  0.357114199  4.33885200 10.02517077 #> 21 Sligo     4.759210 -0.036185300 -0.60775394 -0.74635955 #> 22 Tipperary 3.029041  0.006482570  0.04683010  0.04657633 #> 23 Waterford 5.049095  0.093409563  1.61022194  2.62552879 #> 24 Westmeath 4.596009  0.080097979  1.05978192  1.45704611 #> 25 Wexford   4.921174  0.085478829  1.32647942  1.98902088 #> 26 Wicklow   4.513581  0.020437514  0.21417067  0.21406975 mean(e.locmor[,1]) #> [1] 0.3366057 sum(e.locmor[,1])/Szero(lw) #> [1] 0.3366057 lm.morantest(e.lm, lw) #>  #> \tGlobal Moran I for regression residuals #>  #> data:   #> model: lm(formula = OWNCONS ~ ROADACC, data = eire) #> weights: lw #>  #> Moran I statistic standard deviate = 3.2575, p-value = 0.0005619 #> alternative hypothesis: greater #> sample estimates: #> Observed Moran I      Expectation         Variance  #>       0.33660565      -0.05877741       0.01473183  #>  # note equality for mean() only when the sum of weights equals # the number of observations (thanks to Juergen Symanzik) hist(e.locmor[,\"Pr. (Sad)\"])  e.wlm <- lm(OWNCONS ~ ROADACC, data=eire, weights=RETSALE) e.locmorw1 <- summary(localmoran.sad(e.wlm, nb=eire.nb, resfun=weighted.residuals)) e.locmorw1 #>              Local Morans I Stand. dev. (N)      Pr. (N) Saddlepoint #> 1 Carlow        0.160490657      0.41009538 6.817360e-01  0.57729730 #> 2 Cavan        -0.144663771     -0.27825575 1.219184e+00 -0.45305168 #> 3 Clare         0.301676582      0.59021701 5.550452e-01  0.78987327 #> 4 Cork          1.520488153      3.49016956 4.827142e-04  2.83665634 #> 5 Donegal      -0.435899664     -0.44665946 1.344879e+00 -0.67136090 #> 6 Dublin       -0.340222996     -0.60886675 1.457387e+00 -0.85658016 #> 7 Galway        1.469009037      3.64546192 2.669119e-04  2.82274510 #> 8 Kerry         0.268957279      0.49517211 6.204786e-01  0.66861012 #> 9 Kildare       0.002996577      0.12659200 8.992633e-01  0.09978249 #> 10 Kilkenny     0.497968801      1.20610829 2.277757e-01  1.34091379 #> 11 Laoghis     -0.026328708     -0.01713904 1.013674e+00 -0.06511750 #> 12 Leitrim      0.277306386      0.80644537 4.199861e-01  1.01176491 #> 13 Limerick     0.263122939      0.67591893 4.990921e-01  0.87759628 #> 14 Longford     0.605211711      1.23874274 2.154408e-01  1.35375850 #> 15 Louth        0.359469683      0.53572990 5.921452e-01  0.73280188 #> 16 Mayo         1.742480472      3.68118786 2.321499e-04  3.01500163 #> 17 Meath       -0.112171618     -0.26680698 1.210382e+00 -0.45470531 #> 18 Monaghan     0.241044892      0.46013751 6.454175e-01  0.64094159 #> 19 Offaly       0.129191178      0.40988983 6.818868e-01  0.57205532 #> 20 Roscommon    1.469671750      4.39927211 1.086146e-05  3.13215267 #> 21 Sligo        0.095559559      0.31036587 7.562827e-01  0.38503064 #> 22 Tipperary    0.088352646      0.39958273 6.894639e-01  0.52592105 #> 23 Waterford    1.212658861      2.69846035 6.966104e-03  2.29292584 #> 24 Westmeath    0.256165310      0.61222265 5.403905e-01  0.81620859 #> 25 Wexford      0.619197906      1.31967483 1.869436e-01  1.42553832 #> 26 Wicklow      0.006531073      0.13142161 8.954418e-01  0.10986725 #>                Pr. (Sad) Expectation   Variance   Skewness Kurtosis    Minimum #> 1 Carlow     0.563738639 -0.01840558 0.19029731 -0.1986977 6.709176  -5.665283 #> 2 Cavan      0.650511526 -0.02184465 0.19482455 -0.2329761 6.717975  -5.769371 #> 3 Clare      0.429601786 -0.02782578 0.31166901 -0.2346279 6.718435  -7.299407 #> 4 Cork       0.004558865 -0.07147410 0.20805228 -0.7280203 7.002789  -6.495227 #> 5 Donegal    0.501990650 -0.07638800 0.64784767 -0.4450323 6.803659 -10.931345 #> 6 Dublin     0.391676955 -0.11187469 0.14065367 -1.3324828 7.767845  -5.846924 #> 7 Galway     0.004761441 -0.04407925 0.17227545 -0.4973247 6.833103  -5.688263 #> 8 Kerry      0.503744214 -0.05644300 0.43184063 -0.4031537 6.782459  -8.859407 #> 9 Kildare    0.920517009 -0.04145378 0.12329287 -0.5519841 6.867423  -4.857131 #> 10 Kilkenny  0.179948446 -0.02321457 0.18672759 -0.2528322 6.723714  -5.669156 #> 11 Laoghis   0.948080445 -0.01882531 0.19166504 -0.2024943 6.710081  -5.689691 #> 12 Leitrim   0.311650473 -0.03314655 0.14819776 -0.4041387 6.782933  -5.190860 #> 13 Limerick  0.380162847 -0.04800976 0.21188592 -0.4885390 6.827925  -6.298874 #> 14 Longford  0.175813436 -0.01321709 0.24923967 -0.1247567 6.694960  -6.392250 #> 15 Louth     0.463679274 -0.02272663 0.50895713 -0.1500895 6.699098  -9.179410 #> 16 Mayo      0.002569779 -0.09458039 0.24904116 -0.8745463 7.144787  -7.272523 #> 17 Meath     0.649321260 -0.02548973 0.10555100 -0.3685280 6.766525  -4.353122 #> 18 Monaghan  0.521560632 -0.02333303 0.33012248 -0.1912612 6.707452  -7.451275 #> 19 Offaly    0.567284497 -0.01927989 0.13120470 -0.2505068 6.723017  -4.750083 #> 20 Roscommon 0.001735296 -0.02385522 0.11525625 -0.3302939 6.750604  -4.517676 #> 21 Sligo     0.700214717 -0.06927688 0.28207107 -0.6087587 6.906925  -7.416881 #> 22 Tipperary 0.598943063 -0.03719246 0.09871568 -0.5534442 6.868390  -4.347214 #> 23 Waterford 0.021852275 -0.04027429 0.21558757 -0.4070996 6.784366  -6.264083 #> 24 Westmeath 0.414380842 -0.01522814 0.19650786 -0.1618342 6.701275  -5.716689 #> 25 Wexford   0.154001651 -0.02786850 0.24041626 -0.2674357 6.728234  -6.450174 #> 26 Wicklow   0.912514660 -0.04751424 0.16911517 -0.5404006 6.859847  -5.677417 #>               Maximum        omega       sad.r       sad.u #> 1 Carlow     5.223549  0.033637462  0.38794383  0.41751442 #> 2 Cavan      5.245099 -0.022294725 -0.26091513 -0.27432856 #> 3 Clare      6.631589  0.035302524  0.54866959  0.62630505 #> 4 Cork       4.779848  0.134384022  2.56890121  5.11058941 #> 5 Donegal    9.098033 -0.017507303 -0.40402088 -0.45010348 #> 6 Dublin     3.161931 -0.040828131 -0.50710580 -0.60543071 #> 7 Galway     4.630361  0.138454493  2.55314856  5.08170760 #> 8 Kerry      7.504775  0.027195108  0.47167584  0.51758880 #> 9 Kildare    3.862240  0.014230854  0.12280697  0.12246022 #> 10 Kilkenny  5.112007  0.071351828  1.03314661  1.41988761 #> 11 Laoghis   5.237883 -0.001502568 -0.01645549 -0.01646868 #> 12 Leitrim   4.395343  0.066207108  0.74158109  0.90609823 #> 13 Limerick  5.146640  0.050265468  0.63703133  0.74253221 #> 14 Longford  6.075040  0.060534639  1.04112815  1.44165700 #> 15 Louth     8.633971  0.025231866  0.49793592  0.55971045 #> 16 Mayo      5.002594  0.135902733  2.75603129  5.62669411 #> 17 Meath     3.741368 -0.028724497 -0.24912602 -0.26221742 #> 18 Monaghan  6.891283  0.028042744  0.43280552  0.47360371 #> 19 Offaly    4.287365  0.040883462  0.38909358  0.41780262 #> 20 Roscommon 3.945151  0.180270100  2.87643937  6.00202551 #> 21 Sligo     5.754236  0.023145822  0.30299868  0.31062426 #> 22 Tipperary 3.454595  0.048932861  0.38768333  0.40902706 #> 23 Waterford 5.297500  0.101874758  1.99944904  3.59542986 #> 24 Westmeath 5.351214  0.044919886  0.56403221  0.65024353 #> 25 Wexford   5.781330  0.066083430  1.11524637  1.57637406 #> 26 Wicklow   4.537075  0.012609906  0.12748740  0.12720134 e.locmorw2 <- summary(localmoran.sad(e.wlm, nb=eire.nb, resfun=rstudent)) e.locmorw2 #>              Local Morans I Stand. dev. (N)      Pr. (N) Saddlepoint #> 1 Carlow        0.121997164      0.32185426 0.7475631028  0.45871930 #> 2 Cavan        -0.110588620     -0.20105599 1.1593452023 -0.34808741 #> 3 Clare         0.308759283      0.60290381 0.5465726820  0.80379674 #> 4 Cork          1.404203115      3.23522979 0.0012154487  2.69598105 #> 5 Donegal      -0.421182109     -0.42837428 1.3316213558 -0.65187732 #> 6 Dublin       -0.443534307     -0.88433550 1.6234848706 -1.05167518 #> 7 Galway        1.376190254      3.42183495 0.0006220006  2.70663064 #> 8 Kerry         0.241623387      0.45357724 0.6501331373  0.61515126 #> 9 Kildare       0.008842913      0.14324202 0.8860990418  0.12690939 #> 10 Kilkenny     0.382893124      0.93980330 0.3473184643  1.12810394 #> 11 Laoghis     -0.019904450     -0.00246494 1.0019667357 -0.04176107 #> 12 Leitrim      0.200483743      0.60688769 0.5439254449  0.80241456 #> 13 Limerick     0.238810092      0.62310059 0.5332184222  0.81824678 #> 14 Longford     0.466942853      0.96178354 0.3361583457  1.14088225 #> 15 Louth        0.271710988      0.41271732 0.6798137369  0.58520655 #> 16 Mayo         1.705850161      3.60778634 0.0003088206  2.97346461 #> 17 Meath       -0.160603054     -0.41587901 1.3225014587 -0.63254531 #> 18 Monaghan     0.181378604      0.35629110 0.7216225742  0.50697175 #> 19 Offaly       0.107919508      0.35116431 0.7254650854  0.49312417 #> 20 Roscommon    1.249826037      3.75170355 0.0001756371  2.81402777 #> 21 Sligo        0.079431883      0.27999953 0.7794778655  0.33741411 #> 22 Tipperary    0.085153638      0.38940098 0.6969795442  0.51126046 #> 23 Waterford    1.022922345      2.28982205 0.0220316342  2.06385578 #> 24 Westmeath    0.201539331      0.48899468 0.6248454598  0.67791734 #> 25 Wexford      0.481114325      1.03805702 0.2992435100  1.21094348 #> 26 Wicklow     -0.011694661      0.08710223 0.9305902563  0.03786608 #>                Pr. (Sad) Expectation   Variance   Skewness Kurtosis    Minimum #> 1 Carlow     0.646435751 -0.01840558 0.19029731 -0.1986977 6.709176  -5.665283 #> 2 Cavan      0.727774542 -0.02184465 0.19482455 -0.2329761 6.717975  -5.769371 #> 3 Clare      0.421514374 -0.02782578 0.31166901 -0.2346279 6.718435  -7.299407 #> 4 Cork       0.007018166 -0.07147410 0.20805228 -0.7280203 7.002789  -6.495227 #> 5 Donegal    0.514480318 -0.07638800 0.64784767 -0.4450323 6.803659 -10.931345 #> 6 Dublin     0.292948602 -0.11187469 0.14065367 -1.3324828 7.767845  -5.846924 #> 7 Galway     0.006796983 -0.04407925 0.17227545 -0.4973247 6.833103  -5.688263 #> 8 Kerry      0.538454834 -0.05644300 0.43184063 -0.4031537 6.782459  -8.859407 #> 9 Kildare    0.899012117 -0.04145378 0.12329287 -0.5519841 6.867423  -4.857131 #> 10 Kilkenny  0.259276027 -0.02321457 0.18672759 -0.2528322 6.723714  -5.669156 #> 11 Laoghis   0.966689166 -0.01882531 0.19166504 -0.2024943 6.710081  -5.689691 #> 12 Leitrim   0.422313193 -0.03314655 0.14819776 -0.4041387 6.782933  -5.190860 #> 13 Limerick  0.413216288 -0.04800976 0.21188592 -0.4885390 6.827925  -6.298874 #> 14 Longford  0.253918927 -0.01321709 0.24923967 -0.1247567 6.694960  -6.392250 #> 15 Louth     0.558408841 -0.02272663 0.50895713 -0.1500895 6.699098  -9.179410 #> 16 Mayo      0.002944584 -0.09458039 0.24904116 -0.8745463 7.144787  -7.272523 #> 17 Meath     0.527030613 -0.02548973 0.10555100 -0.3685280 6.766525  -4.353122 #> 18 Monaghan  0.612174643 -0.02333303 0.33012248 -0.1912612 6.707452  -7.451275 #> 19 Offaly    0.621924855 -0.01927989 0.13120470 -0.2505068 6.723017  -4.750083 #> 20 Roscommon 0.004892500 -0.02385522 0.11525625 -0.3302939 6.750604  -4.517676 #> 21 Sligo     0.735804747 -0.06927688 0.28207107 -0.6087587 6.906925  -7.416881 #> 22 Tipperary 0.609168686 -0.03719246 0.09871568 -0.5534442 6.868390  -4.347214 #> 23 Waterford 0.039031392 -0.04027429 0.21558757 -0.4070996 6.784366  -6.264083 #> 24 Westmeath 0.497824103 -0.01522814 0.19650786 -0.1618342 6.701275  -5.716689 #> 25 Wexford   0.225917068 -0.02786850 0.24041626 -0.2674357 6.728234  -6.450174 #> 26 Wicklow   0.969794461 -0.04751424 0.16911517 -0.5404006 6.859847  -5.677417 #>               Maximum         omega        sad.r        sad.u #> 1 Carlow     5.223549  0.0272472954  0.306852385  0.321490350 #> 2 Cavan      5.245099 -0.0166242430 -0.190223798 -0.196022741 #> 3 Clare      6.631589  0.0358559846  0.559584155  0.641527095 #> 4 Cork       4.779848  0.1283688794  2.421993662  4.702934834 #> 5 Donegal    9.098033 -0.0169574018 -0.388662370 -0.430528174 #> 6 Dublin     3.161931 -0.0507848831 -0.696824139 -0.892299501 #> 7 Galway     4.630361  0.1333224875  2.431707338  4.745166958 #> 8 Kerry      7.504775  0.0252982005  0.433626352  0.469138111 #> 9 Kildare    3.862240  0.0161278548  0.139072871  0.138837812 #> 10 Kilkenny  5.112007  0.0622219791  0.835166590  1.066654825 #> 11 Laoghis   5.237883 -0.0002164925 -0.002368023 -0.002368244 #> 12 Leitrim   4.395343  0.0543844388  0.571625643  0.652237768 #> 13 Limerick  5.146640  0.0473787285  0.590605630  0.675595582 #> 14 Longford  6.075040  0.0528365356  0.840671447  1.082014178 #> 15 Louth     8.633971  0.0204960239  0.389078238  0.419930705 #> 16 Mayo      5.002594  0.1340509166  2.712635049  5.503894365 #> 17 Meath     3.741368 -0.0415411327 -0.379736494 -0.417998694 #> 18 Monaghan  6.891283  0.0226076552  0.338579266  0.358443998 #> 19 Offaly    4.287365  0.0357600182  0.335019324  0.353243066 #> 20 Roscommon 3.945151  0.1623235556  2.543240406  5.063795948 #> 21 Sligo     5.754236  0.0209568244  0.273376649  0.278204612 #> 22 Tipperary 3.454595  0.0478130890  0.377982061  0.397511387 #> 23 Waterford 5.297500  0.0941811771  1.762051071  2.998984773 #> 24 Westmeath 5.351214  0.0379323563  0.457473561  0.506014991 #> 25 Wexford   5.781330  0.0582538352  0.911459483  1.197527949 #> 26 Wicklow   4.537075  0.0083101099  0.084281843  0.083952776 run <- FALSE if (requireNamespace(\"spatialreg\", quietly=TRUE)) run <- TRUE if (run) { e.errorsar <- spatialreg::errorsarlm(OWNCONS ~ ROADACC, data=eire,   listw=lw) if (packageVersion(\"spatialreg\") < \"1.1.7\")   spatialreg::print.sarlm(e.errorsar) else   print(e.errorsar) } #>  #> Call: #> spatialreg::errorsarlm(formula = OWNCONS ~ ROADACC, data = eire,  #>     listw = lw) #> Type: error  #>  #> Coefficients: #>      lambda (Intercept)     ROADACC  #> 0.783970989 2.892719569 0.002800913  #>  #> Log likelihood: -64.12465  if (run) { lm.target <- lm(e.errorsar$tary ~ e.errorsar$tarX - 1) Omega <- tcrossprod(spatialreg::invIrW(lw, rho=e.errorsar$lambda)) e.clocmor <- summary(localmoran.sad(lm.target, nb=eire.nb, Omega=Omega)) e.clocmor } #>              Local Morans I Stand. dev. (N)   Pr. (N) Saddlepoint    Pr. (Sad) #> 1 Carlow         0.17958462      -0.5947094 1.4479623 -0.01890335 0.9849182097 #> 2 Cavan         -0.24752628      -0.9775195 1.6716880 -1.30903979 0.1905208730 #> 3 Clare         -0.27901334      -0.9987481 1.6820833 -1.41535136 0.1569655035 #> 4 Cork           0.37808655      -0.5304596 1.4042067  0.06399747 0.9489722431 #> 5 Donegal       -1.01894688      -1.4634181 1.8566470 -1.88871177 0.0589304608 #> 6 Dublin        -0.18171297      -0.9790853 1.6724621 -1.11436913 0.2651208631 #> 7 Galway         1.02193390       0.9527103 0.3407369  1.44844014 0.1474939944 #> 8 Kerry         -0.94967914      -1.1410950 1.7461696 -2.37909992 0.0173549707 #> 9 Kildare        0.07005053      -0.6531380 1.4863327 -0.10338270 0.9176592421 #> 10 Kilkenny      0.43022231      -0.3097714 1.2432652  0.46873471 0.6392592765 #> 11 Laoghis      -0.12239133      -0.9818401 1.6738214 -0.97718184 0.3284791346 #> 12 Leitrim      -0.24203970      -0.9591963 1.6625401 -1.53246533 0.1254076470 #> 13 Limerick     -0.03214546      -0.7729433 1.5604441 -0.80301568 0.4219656705 #> 14 Longford      0.38307454      -0.4899146 1.3758057  0.16621954 0.8679841832 #> 15 Louth         0.21301552      -0.6509309 1.4849089 -0.21224290 0.8319175422 #> 16 Mayo          0.93971200       0.3895188 0.6968924  1.15011408 0.2500968882 #> 17 Meath         0.12484415      -0.6182203 1.4635699 -0.09720926 0.9225602152 #> 18 Monaghan     -0.16109919      -0.8608004 1.6106520 -1.20575831 0.2279106933 #> 19 Offaly       -0.00632492      -0.7740865 1.5611204 -0.33915072 0.7344961920 #> 20 Roscommon     1.02089429       0.6454801 0.5186161  1.21215474 0.2254531515 #> 21 Sligo        -2.01629233      -1.8957526 1.9420072 -3.59571732 0.0003234989 #> 22 Tipperary    -0.10810709      -0.9082666 1.6362626 -1.09721448 0.2725476427 #> 23 Waterford     0.44099279      -0.3488980 1.2728341  0.41219202 0.6801986841 #> 24 Westmeath    -0.06329661      -0.8267635 1.5916289 -0.81444158 0.4153920274 #> 25 Wexford       0.30764883      -0.5219835 1.3983182  0.12395154 0.9013536461 #> 26 Wicklow      -0.01696406      -0.7708237 1.5591886 -0.68244661 0.4949565907 #>              Expectation   Variance Skewness  Kurtosis       Minimum   Maximum #> 1 Carlow       0.8594106  1.3067303 2.362830 10.416149  6.743373e-17 20.625856 #> 2 Cavan        1.1247112  1.9706416 2.347202 10.347468  1.645654e+00 25.347414 #> 3 Clare        1.2679076  2.3989670 2.334022 10.287656  2.485514e+00 27.944268 #> 4 Cork         1.2841620  2.9175890 2.362830 10.416149 -2.406699e-16 30.819888 #> 5 Donegal      1.7253177  3.5165365 2.172101  9.492322  8.227735e+00 33.179890 #> 6 Dublin       0.9462667  1.3272768 2.331563 10.276363  1.928660e+00 20.781740 #> 7 Galway       0.4507425  0.3594525 2.362830 10.416149  1.587770e-16 10.817821 #> 8 Kerry        2.6933183 10.1923447 2.307813 10.165571  7.170614e+00 57.469026 #> 9 Kildare      0.5337376  0.5040110 2.362830 10.416149 -6.444628e-18 12.809701 #> 10 Kilkenny    0.7317135  0.9472545 2.362830 10.416149  5.035617e-16 17.561125 #> 11 Laoghis     0.6035313  0.5466372 2.336004 10.296727  1.143655e+00 13.341096 #> 12 Leitrim     1.2258675  2.3419747 2.347302 10.347916  1.788145e+00 27.632674 #> 13 Limerick    1.5147254  4.0050955 2.362668 10.415466  2.341575e-01 36.119253 #> 14 Longford    1.0996747  2.1395031 2.362830 10.416149  5.674463e-16 26.392192 #> 15 Louth       1.5875248  4.4588771 2.362830 10.416149  4.309554e-16 38.100594 #> 16 Mayo        0.6190019  0.6779043 2.362830 10.416149 -2.035156e-16 14.856045 #> 17 Meath       0.7025948  0.8733620 2.362830 10.416149 -7.624840e-18 16.862274 #> 18 Monaghan    1.5519577  3.9603958 2.357838 10.394611  1.306155e+00 35.940829 #> 19 Offaly      0.3048481  0.1615939 2.362560 10.415009  6.073803e-02  7.255616 #> 20 Roscommon   0.5492905  0.5338125 2.362830 10.416149  9.144870e-16 13.182973 #> 21 Sligo       2.3130311  5.2152695 1.886102  7.938452  1.739456e+01 38.118185 #> 22 Tipperary   0.7147979  0.8208668 2.354040 10.377921  7.922254e-01 16.362924 #> 23 Waterford   0.8228671  1.1979644 2.362830 10.416149  1.408133e-15 19.748811 #> 24 Westmeath   0.8426747  1.2007879 2.360962 10.408167  4.379239e-01 19.786270 #> 25 Wexford     1.0063848  1.7918953 2.362830 10.416149  1.028640e-17 24.153236 #> 26 Wicklow     0.9927147  1.7157589 2.362598 10.415171  1.833509e-01 23.641801 #>                     omega       sad.r       sad.u #> 1 Carlow     -0.017838447 -0.38297869 -0.33313448 #> 2 Cavan      -0.066132684 -1.21593175 -1.36168605 #> 3 Clare      -0.066612498 -1.30513958 -1.50704646 #> 4 Cork       -0.010368850 -0.33915229 -0.29581081 #> 5 Donegal    -0.045800559 -1.66568212 -2.41507712 #> 6 Dublin     -0.056683668 -1.03296356 -1.12358099 #> 7 Galway      0.031762997  1.14153962  1.62047125 #> 8 Kerry      -0.079689480 -2.19374456 -3.29442701 #> 9 Kildare    -0.025051491 -0.36678693 -0.33300845 #> 10 Kilkenny   0.003214928  0.09217307  0.09542846 #> 11 Laoghis   -0.065438986 -0.89335507 -0.96282454 #> 12 Leitrim   -0.092395573 -1.43474097 -1.65069014 #> 13 Limerick  -0.047140362 -0.97737323 -0.82423542 #> 14 Longford  -0.007176482 -0.22762630 -0.20810767 #> 15 Louth     -0.018552546 -0.58005974 -0.46861210 #> 16 Mayo       0.019992304  0.84088281  1.09059594 #> 17 Meath     -0.026958325 -0.44558661 -0.38151850 #> 18 Monaghan  -0.062388996 -1.21509194 -1.20138917 #> 19 Offaly    -0.044380046 -0.41568118 -0.40266554 #> 20 Roscommon  0.023338184  0.88169755  1.17993235 #> 21 Sligo     -0.131646728 -3.40243100 -6.56750200 #> 22 Tipperary -0.089378129 -1.06748205 -1.10190609 #> 23 Waterford  0.001151041  0.03534520  0.03581914 #> 24 Westmeath -0.058470593 -0.88397327 -0.83127666 #> 25 Wexford   -0.009550496 -0.26689930 -0.24045996 #> 26 Wicklow   -0.050401553 -0.84395069 -0.73641410 if (run) { hist(e.clocmor[,\"Pr. (Sad)\"]) }"},{"path":"https://r-spatial.github.io/spdep/reference/localmoran_bv.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the Local Bivariate Moran's I Statistic — localmoran_bv","title":"Compute the Local Bivariate Moran's I Statistic — localmoran_bv","text":"Given two continuous numeric variables, calculate bivariate Local Moran's .","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran_bv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the Local Bivariate Moran's I Statistic — localmoran_bv","text":"","code":"localmoran_bv(x, y, listw, nsim = 199, scale = TRUE, alternative=\"two.sided\",  iseed=1L, no_repeat_in_row=FALSE, zero.policy=attr(listw, \"zero.policy\"))"},{"path":"https://r-spatial.github.io/spdep/reference/localmoran_bv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the Local Bivariate Moran's I Statistic — localmoran_bv","text":"x numeric vector length y. y numeric vector length x. listw listw object example created nb2listw(). nsim number simulations run. scale default TRUE. alternative character string specifying alternative hypothesis, must one \"greater\" (default), \"two.sided\", \"less\". iseed default NULL, used set seed; output reproducible count CPU cores across computation distributed . no_repeat_in_row default FALSE, TRUE, sample conditionally row without replacements avoid duplicate values, https://github.com/r-spatial/spdep/issues/124 zero.policy default default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran_bv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the Local Bivariate Moran's I Statistic — localmoran_bv","text":"data.frame containing two columns Ib p_sim containing local bivariate Moran's simulated p-values respectively.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran_bv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the Local Bivariate Moran's I Statistic — localmoran_bv","text":"Bivariate Local Moran, like global counterpart, evaluates value x observation spatial neighbors' value y. value \\(I_i^B\\) xi * Wyi. , simpler words, local bivariate Moran result multiplying x spatial lag y. Formally defined \\( I_i^B= cx_i\\Sigma_j{w_{ij}y_j} \\)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran_bv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute the Local Bivariate Moran's I Statistic — localmoran_bv","text":"Anselin, Luc, Ibnu Syabri, Oleg Smirnov. 2002. “Visualizing Multivariate Spatial Correlation Dynamically Linked Windows.” New Tools Spatial Data Analysis: Proceedings Specialist Meeting, edited Luc Anselin Sergio Rey. University California, Santa Barbara: Center Spatially Integrated Social Science (CSISS).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran_bv.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute the Local Bivariate Moran's I Statistic — localmoran_bv","text":"Josiah Parry josiah.parry@gmail.com","code":""},{"path":"https://r-spatial.github.io/spdep/reference/localmoran_bv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the Local Bivariate Moran's I Statistic — localmoran_bv","text":"","code":"# load columbus datay columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")) #> Reading layer `columbus' from data source  #>   `/home/rsb/lib/r_libs/spData/shapes/columbus.gpkg' using driver `GPKG' #> Simple feature collection with 49 features and 20 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 5.874907 ymin: 10.78863 xmax: 11.28742 ymax: 14.74245 #> Projected CRS: Undefined Cartesian SRS with unknown unit nb <- poly2nb(columbus) listw <- nb2listw(nb) set.seed(1) (res <- localmoran_bv(columbus$CRIME, columbus$INC, listw, nsim = 499)) #>                Ibvi        E.Ibvi    Var.Ibvi      Z.Ibvi Pr(z != E(Ibvi)) #>  [1,] -0.8578252210 -1.826370e-02 0.731541578 -0.98159654     3.262987e-01 #>  [2,]  0.1802618568  2.554658e-02 0.334247968  0.26760782     7.890012e-01 #>  [3,]  0.0118856298  7.791116e-03 0.017162929  0.03125407     9.750669e-01 #>  [4,] -0.0163525887 -3.452848e-03 0.005852145 -0.16862558     8.660912e-01 #>  [5,] -0.5037734606  1.811633e-02 0.101966376 -1.63436973     1.021812e-01 #>  [6,] -0.0041841415  1.293651e-02 0.139142736 -0.04589760     9.633919e-01 #>  [7,]  1.5201688711 -1.466392e-04 1.099034279  1.45020069     1.470026e-01 #>  [8,] -0.2016456990  7.471406e-03 0.007231278 -2.45913301     1.392730e-02 #>  [9,]  0.0297432891  1.600490e-03 0.009219518  0.29309821     7.694471e-01 #> [10,] -0.0374203146  1.218906e-03 0.001100110 -1.16495823     2.440359e-01 #> [11,] -1.2368494456  7.720869e-02 0.498286158 -1.86155199     6.266627e-02 #> [12,] -1.2010054212  4.055009e-02 0.266658169 -2.40430022     1.620346e-02 #> [13,] -0.5377131737  1.218864e-02 0.122363375 -1.57202494     1.159448e-01 #> [14,] -0.9879712511  3.048475e-02 0.320475271 -1.79905736     7.200961e-02 #> [15,] -0.6057303757  2.137030e-02 0.102916086 -1.95476986     5.061024e-02 #> [16,] -0.7878039284  1.378587e-02 0.161039891 -1.99749384     4.577156e-02 #> [17,]  0.1379508106  9.352179e-04 0.003351141  2.36686570     1.793944e-02 #> [18,] -0.3253226893  1.066349e-02 0.078469609 -1.19941831     2.303653e-01 #> [19,] -0.3888822685 -7.104732e-06 0.432305953 -0.59144532     5.542221e-01 #> [20,] -0.4544889957  1.367811e-01 0.355060554 -0.99228105     3.210604e-01 #> [21,] -0.0006014046  3.919068e-03 0.031597455 -0.02543067     9.797114e-01 #> [22,] -0.0068813684 -3.664201e-03 0.001242910 -0.09125440     9.272904e-01 #> [23,] -0.8788967496  1.189579e-02 0.289002627 -1.65701209     9.751703e-02 #> [24,] -0.1256865340 -3.048451e-03 0.004692164 -1.79035349     7.339710e-02 #> [25,] -0.9307459211  4.509269e-02 0.303474056 -1.77140234     7.649382e-02 #> [26,] -0.2252775788  1.039843e-02 0.019527743 -1.68651169     9.169728e-02 #> [27,]  0.1413018326 -1.409345e-02 0.236810168  0.31932848     7.494774e-01 #> [28,] -0.7804482928  3.200178e-02 0.184987862 -1.88897002     5.889585e-02 #> [29,] -0.7654416689  5.928648e-02 0.364667175 -1.36572255     1.720261e-01 #> [30,] -0.9074829015  7.597435e-03 0.737090639 -1.06585659     2.864885e-01 #> [31,] -0.5510119267 -1.377557e-03 0.388899970 -0.88136323     3.781213e-01 #> [32,] -1.9581476375  2.561515e-02 0.239115219 -4.05682367     4.974461e-05 #> [33,]  0.0907015890  3.048227e-02 0.043681309  0.28812970     7.732475e-01 #> [34,] -0.4297843082  2.130996e-02 0.104683121 -1.39421250     1.632534e-01 #> [35,]  0.1181174820  6.746380e-04 0.008393054  1.28193663     1.998649e-01 #> [36,] -0.9901007017  2.760845e-02 0.278368628 -1.92891697     5.374117e-02 #> [37,] -0.2195812498 -7.723065e-03 0.032151838 -1.18152344     2.373948e-01 #> [38,] -0.3096268627  3.401135e-02 0.205499338 -0.75804717     4.484227e-01 #> [39,] -0.6090192229  1.689079e-02 0.308320019 -1.12722610     2.596469e-01 #> [40,] -1.2709838927  6.528265e-02 0.216905961 -2.86917707     4.115413e-03 #> [41,] -1.3940681427  9.430182e-02 0.304439982 -2.69749131     6.986411e-03 #> [42,] -0.4820987026  3.961324e-02 0.632999863 -0.65573592     5.119941e-01 #> [43,] -0.0064402410  2.939096e-03 0.001385154 -0.25201308     8.010310e-01 #> [44,]  0.0761664412  2.162964e-02 0.054095662  0.23448142     8.146113e-01 #> [45,] -0.0560342555  7.788766e-03 0.029796273 -0.36973996     7.115763e-01 #> [46,] -0.8249832451 -2.301643e-02 0.673531467 -0.97718648     3.284768e-01 #> [47,] -0.8915318222  2.294960e-02 0.095247718 -2.96310881     3.045489e-03 #> [48,] -0.1282863305 -9.674295e-03 0.061579149 -0.47798241     6.326627e-01 #> [49,]  0.0094888641 -4.828535e-03 0.222107368  0.03037964     9.757643e-01 #>       Pr(z != E(Ibvi)) Sim Pr(folded) Sim #>  [1,]                0.324          0.162 #>  [2,]                0.880          0.440 #>  [3,]                0.976          0.488 #>  [4,]                0.800          0.400 #>  [5,]                0.112          0.056 #>  [6,]                0.864          0.430 #>  [7,]                0.096          0.048 #>  [8,]                0.004          0.002 #>  [9,]                0.852          0.426 #> [10,]                0.260          0.130 #> [11,]                0.056          0.028 #> [12,]                0.008          0.004 #> [13,]                0.084          0.042 #> [14,]                0.064          0.032 #> [15,]                0.052          0.026 #> [16,]                0.028          0.014 #> [17,]                0.028          0.014 #> [18,]                0.192          0.096 #> [19,]                0.608          0.304 #> [20,]                0.368          0.184 #> [21,]                0.936          0.468 #> [22,]                0.928          0.464 #> [23,]                0.120          0.060 #> [24,]                0.040          0.020 #> [25,]                0.044          0.022 #> [26,]                0.076          0.038 #> [27,]                0.736          0.368 #> [28,]                0.032          0.016 #> [29,]                0.140          0.070 #> [30,]                0.284          0.142 #> [31,]                0.408          0.204 #> [32,]                0.004          0.002 #> [33,]                0.724          0.362 #> [34,]                0.188          0.094 #> [35,]                0.216          0.108 #> [36,]                0.084          0.042 #> [37,]                0.232          0.116 #> [38,]                0.464          0.232 #> [39,]                0.268          0.134 #> [40,]                0.004          0.002 #> [41,]                0.020          0.010 #> [42,]                0.468          0.234 #> [43,]                0.884          0.442 #> [44,]                0.904          0.452 #> [45,]                0.672          0.336 #> [46,]                0.344          0.172 #> [47,]                0.012          0.006 #> [48,]                0.544          0.272 #> [49,]                0.896          0.448 #> attr(,\"quadr\") #>         mean    median     pysal #> 1   Low-High  Low-High  Low-High #> 2    Low-Low   Low-Low   Low-Low #> 3    Low-Low   Low-Low   Low-Low #> 4   Low-High  Low-High  Low-High #> 5   High-Low  High-Low  High-Low #> 6    Low-Low  Low-High  Low-High #> 7    Low-Low   Low-Low   Low-Low #> 8   High-Low  High-Low  High-Low #> 9    Low-Low   Low-Low   Low-Low #> 10  Low-High  Low-High  Low-High #> 11  High-Low  High-Low  High-Low #> 12  High-Low  High-Low  High-Low #> 13  High-Low  High-Low  High-Low #> 14  High-Low  High-Low  High-Low #> 15  High-Low  High-Low  High-Low #> 16  High-Low  High-Low  High-Low #> 17 High-High High-High High-High #> 18  High-Low  High-Low  High-Low #> 19  High-Low  High-Low  High-Low #> 20  Low-High  Low-High  Low-High #> 21  High-Low High-High  High-Low #> 22  Low-High  Low-High  Low-High #> 23  Low-High  Low-High  Low-High #> 24  High-Low  High-Low  High-Low #> 25  High-Low  High-Low  High-Low #> 26  High-Low  High-Low  High-Low #> 27 High-High High-High High-High #> 28  High-Low  High-Low  High-Low #> 29  High-Low  High-Low  High-Low #> 30  High-Low  High-Low  High-Low #> 31  Low-High  Low-High  Low-High #> 32  Low-High  Low-High  Low-High #> 33 High-High High-High High-High #> 34  Low-High  Low-High  Low-High #> 35 High-High High-High High-High #> 36  Low-High  Low-High  Low-High #> 37  High-Low  High-Low  High-Low #> 38  High-Low  High-Low  High-Low #> 39  Low-High  Low-High  Low-High #> 40  Low-High  Low-High  Low-High #> 41  Low-High  Low-High  Low-High #> 42  Low-High  Low-High  Low-High #> 43  High-Low  High-Low  High-Low #> 44   Low-Low   Low-Low   Low-Low #> 45  Low-High  Low-High  Low-High #> 46  Low-High  Low-High  Low-High #> 47  Low-High  Low-High  Low-High #> 48  Low-High  Low-High  Low-High #> 49   Low-Low   Low-Low   Low-Low #> attr(,\"class\") #> [1] \"localmoran\" \"matrix\"     \"array\"      #> attr(,\"ncpus\") #> [1] 1 columbus$hs <- hotspot(res, Prname=\"Pr(folded) Sim\", cutoff=0.05,  quadrant.type=\"pysal\", p.adjust=\"none\") # \\donttest{ if (require(\"tmap\", quietly=TRUE)) { tmap4 <- packageVersion(\"tmap\") >= \"3.99\" if (tmap4) {   tm_shape(columbus) + tm_polygons(fill=\"hs\",     fill.scale=tm_scale(values=\"brewer.set3\"),     fill.legend=tm_legend(position=tm_pos_in(\"left\", \"top\"),       frame=FALSE, item.r=0), lwd=0.01) } else {   tm_shape(columbus) + tm_fill(\"hs\") } }  # } moran.plot(x=columbus$CRIME, y=columbus$INC, listw=listw)"},{"path":"https://r-spatial.github.io/spdep/reference/mat2listw.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a square spatial weights matrix to a weights list object — mat2listw","title":"Convert a square spatial weights matrix to a weights list object — mat2listw","text":"function converts square spatial weights matrix, optionally sparse matrix weights list object, optionally adding region IDs row names matrix, sequence numbers 1:nrow(x), given argument. style can imposed rebuilting weights list object internally.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/mat2listw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a square spatial weights matrix to a weights list object — mat2listw","text":"","code":"mat2listw(x, row.names = NULL, style=NULL, zero.policy = NULL)"},{"path":"https://r-spatial.github.io/spdep/reference/mat2listw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a square spatial weights matrix to a weights list object — mat2listw","text":"x square non-negative matrix NAs representing spatial weights; may matrix class “sparseMatrix” row.names row names use region IDs style default NULL, missing, set \"M\" warning given; \"M\", passed nb2listw re-build object zero.policy default NULL, use global option value; FALSE stop error empty neighbour sets, TRUE permit weights list formed zero-length weights vectors","code":""},{"path":"https://r-spatial.github.io/spdep/reference/mat2listw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a square spatial weights matrix to a weights list object — mat2listw","text":"listw object following members: style \"M\", meaning matrix style, underlying style unknown, assigned style argument rebuilt object neighbours derived neighbours list weights weights neighbours derived matrix","code":""},{"path":"https://r-spatial.github.io/spdep/reference/mat2listw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert a square spatial weights matrix to a weights list object — mat2listw","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/mat2listw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a square spatial weights matrix to a weights list object — mat2listw","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col005 <- dnearneigh(st_coordinates(st_centroid(st_geometry(columbus),  of_largest_polygon=TRUE)), 0, 0.5, as.character(columbus$NEIGNO)) #> Warning: neighbour object has 8 sub-graphs summary(col005) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 170  #> Percentage nonzero weights: 7.080383  #> Average number of links: 3.469388  #> 4 regions with no links: #> 1005, 1006, 1008, 1043 #> 8 disjoint connected subgraphs #> Link number distribution: #>  #>  0  1  2  3  4  5  6  7  8  9  #>  4 11  5  8  3  9  2  2  3  2  #> 11 least connected regions: #> 1001 1007 1018 1010 1045 1044 1046 1047 1049 1048 1015 with 1 link #> 2 most connected regions: #> 1038 1036 with 9 links col005.w.mat <- nb2mat(col005, style=\"W\", zero.policy=TRUE) try(col005.w.b <- mat2listw(col005.w.mat, style=\"W\")) #> Warning: no-neighbour observations found, set zero.policy to TRUE; #> this warning will soon become an error #> Warning: neighbour object has 8 sub-graphs #> Error in nb2listw(res$neighbours, glist = res$weights, style = style,  :  #>   Empty neighbour sets found (zero.policy: FALSE) col005.w.b <- mat2listw(col005.w.mat, style=\"W\", zero.policy=TRUE) #> Warning: neighbour object has 8 sub-graphs summary(col005.w.b$neighbours) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 170  #> Percentage nonzero weights: 7.080383  #> Average number of links: 3.469388  #> 4 regions with no links: #> 1005, 1006, 1008, 1043 #> 8 disjoint connected subgraphs #> Link number distribution: #>  #>  0  1  2  3  4  5  6  7  8  9  #>  4 11  5  8  3  9  2  2  3  2  #> 11 least connected regions: #> 1001 1007 1018 1010 1045 1044 1046 1047 1049 1048 1015 with 1 link #> 2 most connected regions: #> 1038 1036 with 9 links diffnb(col005, col005.w.b$neighbours) #> Warning: neighbour object has 49 sub-graphs #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 0  #> Percentage nonzero weights: 0  #> Average number of links: 0  #> 49 regions with no links: #> 1005, 1001, 1006, 1002, 1007, 1008, 1004, 1003, 1018, 1010, 1038, 1037, #> 1039, 1040, 1009, 1036, 1011, 1042, 1041, 1017, 1043, 1019, 1012, 1035, #> 1032, 1020, 1021, 1031, 1033, 1034, 1045, 1013, 1022, 1044, 1023, 1046, #> 1030, 1024, 1047, 1016, 1014, 1049, 1029, 1025, 1028, 1048, 1015, 1027, #> 1026 #> 49 disjoint connected subgraphs col005.w.mat.3T <- kronecker(diag(3), col005.w.mat) col005.w.b.3T <- mat2listw(col005.w.mat.3T, style=\"W\", zero.policy=TRUE) #> Warning: neighbour object has 24 sub-graphs summary(col005.w.b.3T$neighbours) #> Neighbour list object: #> Number of regions: 147  #> Number of nonzero links: 510  #> Percentage nonzero weights: 2.360128  #> Average number of links: 3.469388  #> 12 regions with no links: #> 1, 3, 6, 21, 50, 52, 55, 70, 99, 101, 104, 119 #> 24 disjoint connected subgraphs #> Link number distribution: #>  #>  0  1  2  3  4  5  6  7  8  9  #> 12 33 15 24  9 27  6  6  9  6  #> 33 least connected regions: #> 2 5 9 10 31 34 36 39 42 46 47 51 54 58 59 80 83 85 88 91 95 96 100 103 107 108 129 132 134 137 140 144 145 with 1 link #> 6 most connected regions: #> 11 16 60 65 109 114 with 9 links run <- FALSE if (require(\"spatialreg\", quiet=TRUE)) run <- TRUE if (run) { W <- as(nb2listw(col005, style=\"W\", zero.policy=TRUE), \"CsparseMatrix\") try(col005.spM <- mat2listw(W)) col005.spM <- mat2listw(W, style=\"W\", zero.policy=TRUE) summary(col005.spM$neighbours) } #> Warning: style is M (missing); style should be set to a valid value #> Warning: style is M (missing); style should be set to a valid value #> Warning: 1005, 1006, 1008, 1043 are not origins #> Warning: no-neighbour observations found, set zero.policy to TRUE; #> this warning will soon become an error #> Warning: neighbour object has 8 sub-graphs #> Warning: no-neighbour observations found, set zero.policy to TRUE; #> this warning will soon become an error #> Warning: neighbour object has 8 sub-graphs #> Warning: no-neighbour observations found, set zero.policy to TRUE; #> this warning will soon become an error #> Warning: neighbour object has 8 sub-graphs #> Warning: neighbour object has 8 sub-graphs #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 170  #> Percentage nonzero weights: 7.080383  #> Average number of links: 3.469388  #> 4 regions with no links: #> 1005, 1006, 1008, 1043 #> 8 disjoint connected subgraphs #> Link number distribution: #>  #>  0  1  2  3  4  5  6  7  8  9  #>  4 11  5  8  3  9  2  2  3  2  #> 11 least connected regions: #> 1001 1007 1018 1010 1045 1044 1046 1047 1049 1048 1015 with 1 link #> 2 most connected regions: #> 1038 1036 with 9 links if (run) { diffnb(col005, col005.spM$neighbours) } #> Warning: neighbour object has 49 sub-graphs #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 0  #> Percentage nonzero weights: 0  #> Average number of links: 0  #> 49 regions with no links: #> 1005, 1001, 1006, 1002, 1007, 1008, 1004, 1003, 1018, 1010, 1038, 1037, #> 1039, 1040, 1009, 1036, 1011, 1042, 1041, 1017, 1043, 1019, 1012, 1035, #> 1032, 1020, 1021, 1031, 1033, 1034, 1045, 1013, 1022, 1044, 1023, 1046, #> 1030, 1024, 1047, 1016, 1014, 1049, 1029, 1025, 1028, 1048, 1015, 1027, #> 1026 #> 49 disjoint connected subgraphs if (run && require(\"Matrix\", quiet=TRUE)) { IW <- kronecker(Diagonal(3), W) col005.spM.3T <- mat2listw(as(IW, \"CsparseMatrix\"), style=\"W\", zero.policy=TRUE) summary(col005.spM.3T$neighbours) } #> Warning: no-neighbour observations found, set zero.policy to TRUE; #> this warning will soon become an error #> Warning: neighbour object has 24 sub-graphs #> Warning: neighbour object has 24 sub-graphs #> Neighbour list object: #> Number of regions: 147  #> Number of nonzero links: 510  #> Percentage nonzero weights: 2.360128  #> Average number of links: 3.469388  #> 12 regions with no links: #> 1, 3, 6, 21, 50, 52, 55, 70, 99, 101, 104, 119 #> 24 disjoint connected subgraphs #> Link number distribution: #>  #>  0  1  2  3  4  5  6  7  8  9  #> 12 33 15 24  9 27  6  6  9  6  #> 33 least connected regions: #> 2 5 9 10 31 34 36 39 42 46 47 51 54 58 59 80 83 85 88 91 95 96 100 103 107 108 129 132 134 137 140 144 145 with 1 link #> 6 most connected regions: #> 11 16 60 65 109 114 with 9 links"},{"path":"https://r-spatial.github.io/spdep/reference/moran.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Moran's I — moran","title":"Compute Moran's I — moran","text":"simple function compute Moran's , called moran.test moran.mc; $$= \\frac{n}{\\sum_{=1}^{n}\\sum_{j=1}^{n}w_{ij}} \\frac{\\sum_{=1}^{n}\\sum_{j=1}^{n}w_{ij}(x_i-\\bar{x})(x_j-\\bar{x})}{\\sum_{=1}^{n}(x_i - \\bar{x})^2} $$","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Moran's I — moran","text":"","code":"moran(x, listw, n, S0, zero.policy=attr(listw, \"zero.policy\"), NAOK=FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/moran.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Moran's I — moran","text":"x numeric vector length neighbours list listw listw listw object created example nb2listw n number zones S0 global sum weights zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA NAOK 'TRUE' 'NA' 'NaN' 'Inf' values x passed foreign function.  'FALSE', presence 'NA' 'NaN' 'Inf' values regarded error.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Moran's I — moran","text":"list Moran's K sample kurtosis x","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute Moran's I — moran","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, p. 17.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute Moran's I — moran","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/moran.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Moran's I — moran","text":"","code":"data(oldcol) col.W <- nb2listw(COL.nb, style=\"W\") crime <- COL.OLD$CRIME str(moran(crime, col.W, length(COL.nb), Szero(col.W))) #> List of 2 #>  $ I: num 0.511 #>  $ K: num 2.23 is.na(crime) <- sample(1:length(crime), 10) str(moran(crime, col.W, length(COL.nb), Szero(col.W), NAOK=TRUE)) #> Warning: NAs in lagged values #> List of 2 #>  $ I: num 0.142 #>  $ K: num 2.82"},{"path":"https://r-spatial.github.io/spdep/reference/moran.mc.html","id":null,"dir":"Reference","previous_headings":"","what":"Permutation test for Moran's I statistic — moran.mc","title":"Permutation test for Moran's I statistic — moran.mc","text":"permutation test Moran's statistic calculated using nsim random permutations x given spatial weighting scheme, establish rank observed statistic relation nsim simulated values.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.mc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permutation test for Moran's I statistic — moran.mc","text":"","code":"moran.mc(x, listw, nsim, zero.policy=attr(listw, \"zero.policy\"),  alternative=\"greater\", na.action=na.fail, spChk=NULL, return_boot=FALSE,  adjust.n=TRUE)"},{"path":"https://r-spatial.github.io/spdep/reference/moran.mc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permutation test for Moran's I statistic — moran.mc","text":"x numeric vector length neighbours list listw listw listw object created example nb2listw nsim number permutations zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA alternative character string specifying alternative hypothesis, must one \"greater\" (default), \"two.sided\", \"less\". na.action function (default na.fail), can also na.omit na.exclude - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. na.pass permitted meaningless permutation test. spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() return_boot return object class boot equivalent permutation bootstrap rather object class htest adjust.n default TRUE, FALSE number observations adjusted -neighbour observations, TRUE, number observations adjusted","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.mc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permutation test for Moran's I statistic — moran.mc","text":"list class htest mc.sim containing following components: statistic value observed Moran's . parameter rank observed Moran's . p.value pseudo p-value test. alternative character string describing alternative hypothesis. method character string giving method used. data.name character string giving name(s) data, number simulations. res nsim simulated values statistic, final value observed statistic","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.mc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Permutation test for Moran's I statistic — moran.mc","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, p. 63-5.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.mc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Permutation test for Moran's I statistic — moran.mc","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/moran.mc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Permutation test for Moran's I statistic — moran.mc","text":"","code":"data(oldcol) colw <- nb2listw(COL.nb, style=\"W\") nsim <- 99 set.seed(1234) sim1 <- moran.mc(COL.OLD$CRIME, listw=colw, nsim=nsim) sim1 #>  #> \tMonte-Carlo simulation of Moran I #>  #> data:  COL.OLD$CRIME  #> weights: colw   #> number of simulations + 1: 100  #>  #> statistic = 0.51095, observed rank = 100, p-value = 0.01 #> alternative hypothesis: greater #>  mean(sim1$res[1:nsim]) #> [1] -0.003196117 var(sim1$res[1:nsim]) #> [1] 0.008543554 summary(sim1$res[1:nsim]) #>      Min.   1st Qu.    Median      Mean   3rd Qu.      Max.  #> -0.180085 -0.073721 -0.009528 -0.003196  0.063865  0.206779  colold.lags <- nblag(COL.nb, 3) set.seed(1234) sim2 <- moran.mc(COL.OLD$CRIME, nb2listw(colold.lags[[2]],  style=\"W\"), nsim=nsim) summary(sim2$res[1:nsim]) #>     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.  #> -0.15905 -0.07503 -0.01535 -0.02060  0.03305  0.13023  sim3 <- moran.mc(COL.OLD$CRIME, nb2listw(colold.lags[[3]],  style=\"W\"), nsim=nsim) summary(sim3$res[1:nsim]) #>      Min.   1st Qu.    Median      Mean   3rd Qu.      Max.  #> -0.192986 -0.055468 -0.024154 -0.026327  0.004769  0.129996  crime <- COL.OLD$CRIME is.na(crime) <- sample(1:length(crime), 10) try(moran.mc(crime, nb2listw(COL.nb, style=\"W\"), nsim=99,  na.action=na.fail)) #> Error in na.fail.default(x) : missing values in object moran.mc(crime, nb2listw(COL.nb, style=\"W\"), nsim=99, zero.policy=TRUE,  na.action=na.omit) #>  #> \tMonte-Carlo simulation of Moran I #>  #> data:  crime  #> weights: nb2listw(COL.nb, style = \"W\")  #> omitted: 5, 7, 9, 15, 19, 33, 40, 45, 47, 48  #> number of simulations + 1: 100  #>  #> statistic = 0.42342, observed rank = 100, p-value = 0.01 #> alternative hypothesis: greater #>  moran.mc(crime, nb2listw(COL.nb, style=\"W\"), nsim=99, zero.policy=TRUE,  return_boot=TRUE, na.action=na.omit) #> NA observations omitted: 5, 7, 9, 15, 19, 33, 40, 45, 47, 48 #>  #> DATA PERMUTATION #>  #>  #> Call: #> boot(data = x, statistic = moran_boot, R = nsim, sim = \"permutation\",  #>     listw = listw, n = n, S0 = S0, zero.policy = zero.policy,  #>     parallel = parallel, ncpus = ncpus, cl = cl) #>  #>  #> Bootstrap Statistics : #>      original     bias    std. error #> t1* 0.4234221 -0.4429891   0.1293935 moran.mc(crime, nb2listw(COL.nb, style=\"W\"), nsim=99, zero.policy=TRUE,  na.action=na.exclude) #>  #> \tMonte-Carlo simulation of Moran I #>  #> data:  crime  #> weights: nb2listw(COL.nb, style = \"W\")  #> omitted: 5, 7, 9, 15, 19, 33, 40, 45, 47, 48  #> number of simulations + 1: 100  #>  #> statistic = 0.42342, observed rank = 100, p-value = 0.01 #> alternative hypothesis: greater #>  moran.mc(crime, nb2listw(COL.nb, style=\"W\"), nsim=99, zero.policy=TRUE,  return_boot=TRUE, na.action=na.exclude) #> NA observations omitted: 5, 7, 9, 15, 19, 33, 40, 45, 47, 48 #>  #> DATA PERMUTATION #>  #>  #> Call: #> boot(data = x, statistic = moran_boot, R = nsim, sim = \"permutation\",  #>     listw = listw, n = n, S0 = S0, zero.policy = zero.policy,  #>     parallel = parallel, ncpus = ncpus, cl = cl) #>  #>  #> Bootstrap Statistics : #>      original     bias    std. error #> t1* 0.4234221 -0.4384413   0.1243937 try(moran.mc(crime, nb2listw(COL.nb, style=\"W\"), nsim=99, na.action=na.pass)) #> Error in moran.mc(crime, nb2listw(COL.nb, style = \"W\"), nsim = 99, na.action = na.pass) :  #>   na.pass not permitted"},{"path":"https://r-spatial.github.io/spdep/reference/moran.plot.html","id":null,"dir":"Reference","previous_headings":"","what":"Moran scatterplot — moran.plot","title":"Moran scatterplot — moran.plot","text":"plot spatial data spatially lagged values, augmented reporting summary influence measures linear relationship data lag. zero policy TRUE, observations also marked occur.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.plot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Moran scatterplot — moran.plot","text":"","code":"moran.plot(x, listw, y=NULL, zero.policy=attr(listw, \"zero.policy\"), spChk=NULL,  labels=NULL, xlab=NULL, ylab=NULL, quiet=NULL, plot=TRUE, return_df=TRUE, ...)"},{"path":"https://r-spatial.github.io/spdep/reference/moran.plot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Moran scatterplot — moran.plot","text":"x numeric vector length neighbours list listw listw listw object created example nb2listw y optional numeric vector length neighbours list listw bi-variate plot zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() labels character labels points high influence measures, set FALSE, labels plotted points large influence xlab label x axis ylab label x axis quiet default NULL, use !verbose global option value; TRUE, output summary influence object suppressed plot default TRUE, false, plotting suppressed return_df default TRUE, invisibly return data.frame object; FALSE invisibly return influence measures object ... graphical parameters par(..)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.plot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Moran scatterplot — moran.plot","text":"function returns data.frame object coordinates influence measures return_df TRUE, influence object influence.measures.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.plot.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Moran scatterplot — moran.plot","text":"Anselin, L. 1996. Moran scatterplot ESDA tool assess local instability spatial association. pp. 111–125 M. M. Fischer, H. J. Scholten D. Unwin (eds) Spatial analytical perspectives GIS, London, Taylor Francis; Anselin, L. 1995. Local indicators spatial association, Geographical Analysis, 27, 93–115","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.plot.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Moran scatterplot — moran.plot","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/moran.plot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Moran scatterplot — moran.plot","text":"","code":"data(afcon, package=\"spData\") mp <- moran.plot(afcon$totcon, nb2listw(paper.nb),  labels=as.character(afcon$name), pch=19)  moran.plot(as.vector(scale(afcon$totcon)), nb2listw(paper.nb),  labels=as.character(afcon$name), xlim=c(-2, 4), ylim=c(-2,4), pch=19)  if (require(ggplot2, quietly=TRUE)) {   xname <- attr(mp, \"xname\")   ggplot(mp, aes(x=x, y=wx)) + geom_point(shape=1) +      geom_smooth(formula=y ~ x, method=\"lm\") +      geom_hline(yintercept=mean(mp$wx), lty=2) +      geom_vline(xintercept=mean(mp$x), lty=2) + theme_minimal() +      geom_point(data=mp[mp$is_inf,], aes(x=x, y=wx), shape=9) +     geom_text(data=mp[mp$is_inf,], aes(x=x, y=wx, label=labels, vjust=1.5)) +     xlab(xname) + ylab(paste0(\"Spatially lagged \", xname)) }  columbus <- st_read(system.file(\"shapes/columbus.shp\", package=\"spData\")) #> Reading layer `columbus' from data source  #>   `/home/rsb/lib/r_libs/spData/shapes/columbus.shp' using driver `ESRI Shapefile' #> Simple feature collection with 49 features and 20 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 5.874907 ymin: 10.78863 xmax: 11.28742 ymax: 14.74245 #> CRS:           NA nb <- poly2nb(columbus) listw <- nb2listw(nb) moran.plot(x=columbus$CRIME, y=columbus$INC, listw=listw)  moran.plot(x=columbus$INC, y=columbus$CRIME, listw=listw)"},{"path":"https://r-spatial.github.io/spdep/reference/moran.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Moran's I test for spatial autocorrelation — moran.test","title":"Moran's I test for spatial autocorrelation — moran.test","text":"Moran's test spatial autocorrelation using spatial weights matrix weights list form. assumptions underlying test sensitive form graph neighbour relationships factors, results may checked moran.mc permutations.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Moran's I test for spatial autocorrelation — moran.test","text":"","code":"moran.test(x, listw, randomisation=TRUE, zero.policy=attr(listw, \"zero.policy\"),  alternative=\"greater\", rank = FALSE, na.action=na.fail, spChk=NULL,  adjust.n=TRUE, drop.EI2=FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/moran.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Moran's I test for spatial autocorrelation — moran.test","text":"x numeric vector length neighbours list listw listw listw object created example nb2listw randomisation variance calculated assumption randomisation, FALSE normality zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without neighbours, FALSE assign NA alternative character string specifying alternative hypothesis, must one greater (default), less two.sided. rank logical value - default FALSE continuous variables, TRUE, uses adaptation Moran's ranks suggested Cliff Ord (1981, p. 46) na.action function (default na.fail), can also na.omit na.exclude - cases weights list subsetted remove NAs data. may necessary set zero.policy TRUE subsetting may create -neighbour observations. Note weights lists created without using glist argument nb2listw may subsetted. na.pass used, zero substituted NA values calculating spatial lag spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() adjust.n default TRUE, FALSE number observations adjusted -neighbour observations, TRUE, number observations adjusted drop.EI2 default FALSE, TRUE, emulate CrimeStat <= 4.02","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Moran's I test for spatial autocorrelation — moran.test","text":"list class htest containing following components: statistic value standard deviate Moran's . p.value p-value test. estimate value observed Moran's , expectation variance method assumption. alternative character string describing alternative hypothesis. method character string giving assumption used calculating standard deviate. data.name character string giving name(s) data.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.test.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Moran's I test for spatial autocorrelation — moran.test","text":"Var() taken Cliff Ord (1969, p. 28), Goodchild's CATMOG 47 (1986), see also Upton & Fingleton (1985) p. 171; agrees SpaceStat, see Tutorial workbook Chapter 22; VI second crude moment minus square first crude moment. derivation test (Cliff Ord, 1981, p. 18) assumes weights matrix symmetric. inherently non-symmetric matrices, k-nearest neighbour matrices, listw2U() can used make matrix symmetric.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.test.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Moran's I test for spatial autocorrelation — moran.test","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, p. 21; Bivand RS, Wong DWS 2018 Comparing implementations global local indicators spatial association. TEST, 27(3), 716–748 doi:10.1007/s11749-018-0599-x","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran.test.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Moran's I test for spatial autocorrelation — moran.test","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/moran.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Moran's I test for spatial autocorrelation — moran.test","text":"","code":"data(oldcol) coords.OLD <- cbind(COL.OLD$X, COL.OLD$Y) moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style=\"W\")) #>  #> \tMoran I test under randomisation #>  #> data:  COL.OLD$CRIME   #> weights: nb2listw(COL.nb, style = \"W\")     #>  #> Moran I statistic standard deviate = 5.6341, p-value = 8.797e-09 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.510951264      -0.020833333       0.008908762  #>  moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style=\"B\")) #>  #> \tMoran I test under randomisation #>  #> data:  COL.OLD$CRIME   #> weights: nb2listw(COL.nb, style = \"B\")     #>  #> Moran I statistic standard deviate = 6.2116, p-value = 2.622e-10 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>        0.52063815       -0.02083333        0.00759872  #>  moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style=\"C\")) #>  #> \tMoran I test under randomisation #>  #> data:  COL.OLD$CRIME   #> weights: nb2listw(COL.nb, style = \"C\")     #>  #> Moran I statistic standard deviate = 6.2116, p-value = 2.622e-10 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>        0.52063815       -0.02083333        0.00759872  #>  moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style=\"S\")) #>  #> \tMoran I test under randomisation #>  #> data:  COL.OLD$CRIME   #> weights: nb2listw(COL.nb, style = \"S\")     #>  #> Moran I statistic standard deviate = 5.9786, p-value = 1.125e-09 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.512957470      -0.020833333       0.007971504  #>  moran.test(COL.OLD$CRIME, nb2listw(COL.nb, style=\"W\"),  randomisation=FALSE) #>  #> \tMoran I test under normality #>  #> data:  COL.OLD$CRIME   #> weights: nb2listw(COL.nb, style = \"W\")     #>  #> Moran I statistic standard deviate = 5.6754, p-value = 6.92e-09 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.510951264      -0.020833333       0.008779831  #>  colold.lags <- nblag(COL.nb, 3) moran.test(COL.OLD$CRIME, nb2listw(colold.lags[[2]],  style=\"W\")) #>  #> \tMoran I test under randomisation #>  #> data:  COL.OLD$CRIME   #> weights: nb2listw(colold.lags[[2]], style = \"W\")     #>  #> Moran I statistic standard deviate = 2.6076, p-value = 0.004559 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.168485742      -0.020833333       0.005271314  #>  moran.test(COL.OLD$CRIME, nb2listw(colold.lags[[3]],  style=\"W\")) #>  #> \tMoran I test under randomisation #>  #> data:  COL.OLD$CRIME   #> weights: nb2listw(colold.lags[[3]], style = \"W\")     #>  #> Moran I statistic standard deviate = -1.7896, p-value = 0.9632 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>      -0.138930745      -0.020833333       0.004354683  #>  print(is.symmetric.nb(COL.nb)) #> [1] TRUE COL.k4.nb <- knn2nb(knearneigh(coords.OLD, 4)) print(is.symmetric.nb(COL.k4.nb)) #> [1] FALSE moran.test(COL.OLD$CRIME, nb2listw(COL.k4.nb, style=\"W\")) #>  #> \tMoran I test under randomisation #>  #> data:  COL.OLD$CRIME   #> weights: nb2listw(COL.k4.nb, style = \"W\")     #>  #> Moran I statistic standard deviate = 7.2183, p-value = 2.632e-13 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.624933667      -0.020833333       0.008003503  #>  moran.test(COL.OLD$CRIME, nb2listw(COL.k4.nb, style=\"W\"),  randomisation=FALSE) #>  #> \tMoran I test under normality #>  #> data:  COL.OLD$CRIME   #> weights: nb2listw(COL.k4.nb, style = \"W\")     #>  #> Moran I statistic standard deviate = 7.2711, p-value = 1.782e-13 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.624933667      -0.020833333       0.007887613  #>  cat(\"Note: non-symmetric weights matrix, use listw2U()\") #> Note: non-symmetric weights matrix, use listw2U() moran.test(COL.OLD$CRIME, listw2U(nb2listw(COL.k4.nb,  style=\"W\"))) #>  #> \tMoran I test under randomisation #>  #> data:  COL.OLD$CRIME   #> weights: listw2U(nb2listw(COL.k4.nb, style = \"W\"))     #>  #> Moran I statistic standard deviate = 7.2183, p-value = 2.632e-13 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.624933667      -0.020833333       0.008003503  #>  moran.test(COL.OLD$CRIME, listw2U(nb2listw(COL.k4.nb,  style=\"W\")), randomisation=FALSE) #>  #> \tMoran I test under normality #>  #> data:  COL.OLD$CRIME   #> weights: listw2U(nb2listw(COL.k4.nb, style = \"W\"))     #>  #> Moran I statistic standard deviate = 7.2711, p-value = 1.782e-13 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.624933667      -0.020833333       0.007887613  #>  ranks <- rank(COL.OLD$CRIME) names(ranks) <- rownames(COL.OLD) moran.test(ranks, nb2listw(COL.nb, style=\"W\"), rank=TRUE) #>  #> \tMoran I test under randomisation #>  #> data:  ranks using rank correction  #> weights: nb2listw(COL.nb, style = \"W\")     #>  #> Moran I statistic standard deviate = 6.3815, p-value = 8.766e-11 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.584333495      -0.020833333       0.008992923  #>  crime <- COL.OLD$CRIME is.na(crime) <- sample(1:length(crime), 10) res <- try(moran.test(crime, nb2listw(COL.nb, style=\"W\"),  na.action=na.fail)) #> Error in na.fail.default(x) : missing values in object res #> [1] \"Error in na.fail.default(x) : missing values in object\\n\" #> attr(,\"class\") #> [1] \"try-error\" #> attr(,\"condition\") #> <simpleError in na.fail.default(x): missing values in object> moran.test(crime, nb2listw(COL.nb, style=\"W\"), zero.policy=TRUE,  na.action=na.omit) #> Warning: subsetting caused increase in subgraph count #>  #> \tMoran I test under randomisation #>  #> data:  crime   #> weights: nb2listw(COL.nb, style = \"W\")  #> omitted: 7, 10, 12, 13, 14, 18, 26, 41, 42, 47  #> n reduced by no-neighbour observations   #>  #> Moran I statistic standard deviate = 3.9826, p-value = 3.408e-05 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>        0.43709247       -0.02702703        0.01358066  #>  moran.test(crime, nb2listw(COL.nb, style=\"W\"), zero.policy=TRUE,  na.action=na.exclude) #> Warning: subsetting caused increase in subgraph count #>  #> \tMoran I test under randomisation #>  #> data:  crime   #> weights: nb2listw(COL.nb, style = \"W\")  #> omitted: 7, 10, 12, 13, 14, 18, 26, 41, 42, 47  #> n reduced by no-neighbour observations   #>  #> Moran I statistic standard deviate = 3.9826, p-value = 3.408e-05 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>        0.43709247       -0.02702703        0.01358066  #>  moran.test(crime, nb2listw(COL.nb, style=\"W\"), na.action=na.pass) #> Warning: NAs in lagged values #>  #> \tMoran I test under randomisation #>  #> data:  crime   #> weights: nb2listw(COL.nb, style = \"W\")     #>  #> Moran I statistic standard deviate = 2.4925, p-value = 0.006342 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.212782897      -0.020833333       0.008784908  #>  columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col_geoms <- st_geometry(columbus) col_geoms[1] <- st_buffer(col_geoms[1], dist=-0.05) st_geometry(columbus) <- col_geoms (nb1 <- poly2nb(columbus)) #> Warning: some observations have no neighbours; #> if this seems unexpected, try increasing the snap argument. #> Warning: neighbour object has 2 sub-graphs; #> if this sub-graph count seems unexpected, try increasing the snap argument. #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 232  #> Percentage nonzero weights: 9.662641  #> Average number of links: 4.734694  #> 1 region with no links: #> 1 #> 2 disjoint connected subgraphs try(lw <- nb2listw(nb1, style=\"W\")) #> Error in nb2listw(nb1, style = \"W\") :  #>   Empty neighbour sets found (zero.policy: FALSE) (lw <- nb2listw(nb1, style=\"W\", zero.policy=TRUE)) #> Characteristics of weights list object: #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 232  #> Percentage nonzero weights: 9.662641  #> Average number of links: 4.734694  #> 1 region with no links: #> 1 #> 2 disjoint connected subgraphs #>  #> Weights style: W  #> Weights constants summary: #>    n   nn S0       S1       S2 #> W 48 2304 48 22.23035 199.8188 moran.test(COL.OLD$CRIME, lw) #>  #> \tMoran I test under randomisation #>  #> data:  COL.OLD$CRIME   #> weights: lw   #> n reduced by no-neighbour observations   #>  #> Moran I statistic standard deviate = 2.7707, p-value = 0.002797 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>        0.23901261       -0.02127660        0.00882535  #>"},{"path":"https://r-spatial.github.io/spdep/reference/moran_bv.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the Global Bivariate Moran's I — moran_bv","title":"Compute the Global Bivariate Moran's I — moran_bv","text":"Given two continuous numeric variables, calculate bivariate Moran's . See details .","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran_bv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the Global Bivariate Moran's I — moran_bv","text":"","code":"moran_bv(x, y, listw, nsim = 499, scale = TRUE)"},{"path":"https://r-spatial.github.io/spdep/reference/moran_bv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the Global Bivariate Moran's I — moran_bv","text":"x numeric vector length y. y numeric vector length x. listw listw object example created nb2listw(). nsim number simulations run. scale default TRUE.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran_bv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the Global Bivariate Moran's I — moran_bv","text":"object class \"boot\", observed statistic component t0.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran_bv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the Global Bivariate Moran's I — moran_bv","text":"Global Bivariate Moran defined \\( I_B = \\frac{\\Sigma_i(\\Sigma_j{w_{ij}y_j\\times x_i})}{\\Sigma_i{x_i^2}} \\) important note measure autocorrelation X spatial lag Y. , resultant measure may overestimate amount spatial autocorrelation may product inherent correlation X Y. output object class \"boot\", plots confidence intervals available using appropriate methods.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran_bv.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute the Global Bivariate Moran's I — moran_bv","text":"Wartenberg, D. (1985), Multivariate Spatial Correlation: Method Exploratory Geographical Analysis. Geographical Analysis, 17: 263-283. doi:10.1111/j.1538-4632.1985.tb00849.x","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran_bv.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute the Global Bivariate Moran's I — moran_bv","text":"Josiah Parry josiah.parry@gmail.com","code":""},{"path":"https://r-spatial.github.io/spdep/reference/moran_bv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the Global Bivariate Moran's I — moran_bv","text":"","code":"data(boston, package = \"spData\") x <- boston.c$CRIM y <- boston.c$NOX listw <- nb2listw(boston.soi) set.seed(1) res_xy <- moran_bv(x, y, listw, nsim=499) res_xy$t0 #> [1] 0.4082073 boot::boot.ci(res_xy, conf=c(0.99, 0.95, 0.9), type=\"basic\") #> BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS #> Based on 499 bootstrap replicates #>  #> CALL :  #> boot::boot.ci(boot.out = res_xy, conf = c(0.99, 0.95, 0.9), type = \"basic\") #>  #> Intervals :  #> Level      Basic          #> 99%   ( 0.7443,  0.8789 )    #> 95%   ( 0.7639,  0.8673 )    #> 90%   ( 0.7739,  0.8615 )   #> Calculations and Intervals on Original Scale #> Some basic intervals may be unstable plot(res_xy)  set.seed(1) lee_xy <- lee.mc(x, y, listw, nsim=499, return_boot=TRUE) lee_xy$t0 #> [1] 0.3993476 boot::boot.ci(lee_xy, conf=c(0.99, 0.95, 0.9), type=\"basic\") #> BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS #> Based on 499 bootstrap replicates #>  #> CALL :  #> boot::boot.ci(boot.out = lee_xy, conf = c(0.99, 0.95, 0.9), type = \"basic\") #>  #> Intervals :  #> Level      Basic          #> 99%   ( 0.6363,  0.7236 )    #> 95%   ( 0.6538,  0.7131 )    #> 90%   ( 0.6584,  0.7098 )   #> Calculations and Intervals on Original Scale #> Some basic intervals may be unstable plot(lee_xy)  set.seed(1) res_yx <- moran_bv(y, x, listw, nsim=499) res_yx$t0 #> [1] 0.4029821 boot::boot.ci(res_yx, conf=c(0.99, 0.95, 0.9), type=\"basic\") #> BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS #> Based on 499 bootstrap replicates #>  #> CALL :  #> boot::boot.ci(boot.out = res_yx, conf = c(0.99, 0.95, 0.9), type = \"basic\") #>  #> Intervals :  #> Level      Basic          #> 99%   ( 0.7301,  0.8729 )    #> 95%   ( 0.7574,  0.8584 )    #> 90%   ( 0.7664,  0.8541 )   #> Calculations and Intervals on Original Scale #> Some basic intervals may be unstable plot(res_yx)  set.seed(1) lee_yx <- lee.mc(y, x, listw, nsim=499, return_boot=TRUE) lee_yx$t0 #> [1] 0.3993476 boot::boot.ci(lee_yx, conf=c(0.99, 0.95, 0.9), type=\"basic\") #> BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS #> Based on 499 bootstrap replicates #>  #> CALL :  #> boot::boot.ci(boot.out = lee_yx, conf = c(0.99, 0.95, 0.9), type = \"basic\") #>  #> Intervals :  #> Level      Basic          #> 99%   ( 0.6363,  0.7236 )    #> 95%   ( 0.6538,  0.7131 )    #> 90%   ( 0.6584,  0.7098 )   #> Calculations and Intervals on Original Scale #> Some basic intervals may be unstable plot(lee_yx)"},{"path":"https://r-spatial.github.io/spdep/reference/mstree.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the minimal spanning tree — mstree","title":"Find the minimal spanning tree — mstree","text":"minimal spanning tree connected graph n nodes n-1   edges. smaller class possible partitions graph   pruning edges high dissimilarity. one edge removed,   graph partioned two unconnected subgraphs. function   implements algorithm due Prim (1987).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/mstree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the minimal spanning tree — mstree","text":"","code":"mstree(nbw, ini = NULL)"},{"path":"https://r-spatial.github.io/spdep/reference/mstree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the minimal spanning tree — mstree","text":"nbw object listw class returned     nb2listw function. See help details. ini initial node minimal spanning tree.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/mstree.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find the minimal spanning tree — mstree","text":"minimum spanning tree algorithm. Input connected graph. Begin empty set nodes. Add arbitrary note set. nodes set, find minimum cost edge connecting   node set node set add node   set. set edges minimum spanning tree.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/mstree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the minimal spanning tree — mstree","text":"matrix n-1 rows tree columns. row two nodes   cost, . e. edge cost.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/mstree.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Find the minimal spanning tree — mstree","text":"R. C. Prim (1957) Shortest connection networks   generalisations. : Bell System Technical Journal, 36, pp. 1389-1401","code":""},{"path":"https://r-spatial.github.io/spdep/reference/mstree.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Find the minimal spanning tree — mstree","text":"Renato M. Assuncao Elias T. Krainski","code":""},{"path":"https://r-spatial.github.io/spdep/reference/mstree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the minimal spanning tree — mstree","text":"","code":"### loading data (GDAL37 <- as.numeric_version(unname(sf_extSoftVersion()[\"GDAL\"])) >= \"3.7.0\") #> [1] TRUE file <- \"etc/shapes/bhicv.gpkg.zip\" zipfile <- system.file(file, package=\"spdep\") if (GDAL37) {     bh <- st_read(zipfile) } else {     td <- tempdir()     bn <- sub(\".zip\", \"\", basename(file), fixed=TRUE)     target <- unzip(zipfile, files=bn, exdir=td)     bh <- st_read(target) } #> Reading layer `bhicv' from data source  #>   `/tmp/RtmpqhccSk/temp_libpath108a2257736002/spdep/etc/shapes/bhicv.gpkg.zip'  #>   using driver `GPKG' #> Simple feature collection with 98 features and 8 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -45.02175 ymin: -20.93007 xmax: -42.50321 ymax: -18.08342 #> Geodetic CRS:  Corrego Alegre 1970-72 ### data padronized dpad <- data.frame(scale(as.data.frame(bh)[,5:8]))  ### neighboorhod list  bh.nb <- poly2nb(bh)  ### calculing costs lcosts <- nbcosts(bh.nb, dpad)  ### making listw nb.w <- nb2listw(bh.nb, lcosts, style=\"B\")  ### find a minimum spanning tree system.time(mst.bh <- mstree(nb.w,5)) #>    user  system elapsed  #>   0.002   0.000   0.002  dim(mst.bh) #> [1] 97  3 head(mst.bh) #>      [,1] [,2]      [,3] #> [1,]    5   12 1.2951120 #> [2,]   12   13 0.6141101 #> [3,]   13   11 0.7913745 #> [4,]   13    6 0.9775650 #> [5,]   11   31 0.9965625 #> [6,]   31   39 0.6915158 tail(mst.bh) #>       [,1] [,2]      [,3] #> [92,]   89   90 2.5743702 #> [93,]   26   56 2.6235317 #> [94,]   86   87 2.6471303 #> [95,]   87   72 0.7874461 #> [96,]   49   36 2.8743677 #> [97,]   24   25 3.4675168 ### the mstree plot par(mar=c(0,0,0,0)) plot(st_geometry(bh), border=gray(.5)) plot(mst.bh, st_coordinates(st_centroid(bh)), col=2,       cex.lab=.6, cex.circles=0.035, fg=\"blue\", add=TRUE) #> Warning: st_centroid assumes attributes are constant over geometries"},{"path":"https://r-spatial.github.io/spdep/reference/nb2INLA.html","id":null,"dir":"Reference","previous_headings":"","what":"Output spatial neighbours for INLA — nb2INLA","title":"Output spatial neighbours for INLA — nb2INLA","text":"Output spatial neighbours INLA","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2INLA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Output spatial neighbours for INLA — nb2INLA","text":"","code":"nb2INLA(file, nb)"},{"path":"https://r-spatial.github.io/spdep/reference/nb2INLA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Output spatial neighbours for INLA — nb2INLA","text":"file file adjacency matrix stored nb object class nb","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2INLA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Output spatial neighbours for INLA — nb2INLA","text":"Nothing returned file created representation adjacency matrix required INLA spatial models.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2INLA.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Output spatial neighbours for INLA — nb2INLA","text":"http://www.r-inla.org","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2INLA.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Output spatial neighbours for INLA — nb2INLA","text":"Virgilio Gomez-Rubio","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2INLA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Output spatial neighbours for INLA — nb2INLA","text":"","code":"col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) td <- tempdir() x <- nb2INLA(paste(td, \"columbus-INLA.adj\", sep=\"/\"), col.gal.nb) readLines(paste(td, \"columbus-INLA.adj\", sep=\"/\"), n=10) #>  [1] \"49\"                        \"1 2 2 3\"                   #>  [3] \"2 3 1 3 4\"                 \"3 4 1 2 4 5\"               #>  [5] \"4 4 2 3 5 8\"               \"5 7 3 4 6 8 9 11 15\"       #>  [7] \"6 2 5 9\"                   \"7 4 8 12 13 14\"            #>  [9] \"8 6 4 5 7 11 12 13\"        \"9 8 5 6 10 15 20 22 25 26\""},{"path":"https://r-spatial.github.io/spdep/reference/nb2WB.html","id":null,"dir":"Reference","previous_headings":"","what":"Output spatial weights for WinBUGS — nb2WB","title":"Output spatial weights for WinBUGS — nb2WB","text":"Output spatial weights WinBUGS","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2WB.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Output spatial weights for WinBUGS — nb2WB","text":"","code":"nb2WB(nb) listw2WB(listw)"},{"path":"https://r-spatial.github.io/spdep/reference/nb2WB.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Output spatial weights for WinBUGS — nb2WB","text":"nb object class nb listw listw object example nb2listw","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2WB.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Output spatial weights for WinBUGS — nb2WB","text":"list suitable convering using dput WinBUGS","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2WB.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Output spatial weights for WinBUGS — nb2WB","text":"http://www.mrc-bsu.cam.ac.uk/bugs/winbugs/geobugs12manual.pdf","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2WB.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Output spatial weights for WinBUGS — nb2WB","text":"Virgilio Gomez-Rubio","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/nb2WB.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Output spatial weights for WinBUGS — nb2WB","text":"","code":"col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) x <- nb2WB(col.gal.nb) dput(x, control=NULL) #> list(c(2, 3, 1, 3, 4, 1, 2, 4, 5, 2, 3, 5, 8, 3, 4, 6, 8, 9,  #> 11, 15, 5, 9, 8, 12, 13, 14, 4, 5, 7, 11, 12, 13, 5, 6, 10, 15,  #> 20, 22, 25, 26, 9, 17, 20, 22, 5, 8, 12, 15, 16, 7, 8, 11, 13,  #> 14, 16, 7, 8, 12, 14, 7, 12, 13, 16, 18, 19, 5, 9, 11, 16, 25,  #> 26, 11, 12, 14, 15, 18, 24, 25, 10, 20, 23, 14, 16, 19, 24, 14,  #> 18, 24, 9, 10, 17, 22, 23, 27, 32, 33, 35, 40, 24, 30, 34, 9,  #> 10, 20, 26, 27, 28, 17, 20, 32, 16, 18, 19, 21, 25, 29, 30, 9,  #> 15, 16, 24, 26, 28, 29, 9, 15, 22, 25, 28, 29, 20, 22, 28, 33,  #> 22, 25, 26, 27, 29, 33, 35, 37, 38, 24, 25, 26, 28, 30, 37, 38,  #> 21, 24, 29, 37, 34, 36, 20, 23, 40, 41, 20, 27, 28, 35, 21, 31,  #> 36, 42, 20, 28, 33, 38, 40, 43, 44, 31, 34, 39, 42, 46, 28, 29,  #> 30, 38, 43, 45, 28, 29, 35, 37, 43, 44, 36, 46, 20, 32, 35, 41,  #> 47, 32, 40, 47, 34, 36, 35, 37, 38, 44, 45, 48, 35, 38, 43, 48,  #> 49, 37, 43, 48, 49, 36, 39, 40, 41, 43, 44, 45, 49, 44, 45, 48 #> ), c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  #> 1), c(2, 3, 4, 4, 7, 2, 4, 6, 8, 4, 5, 6, 4, 6, 6, 7, 3, 4, 3,  #> 10, 3, 6, 3, 7, 7, 6, 4, 9, 7, 4, 2, 4, 4, 4, 7, 5, 6, 6, 2,  #> 5, 3, 2, 6, 5, 4, 2, 2, 4, 3)) x <- listw2WB(nb2listw(col.gal.nb)) dput(x, control=NULL) #> list(c(2, 3, 1, 3, 4, 1, 2, 4, 5, 2, 3, 5, 8, 3, 4, 6, 8, 9,  #> 11, 15, 5, 9, 8, 12, 13, 14, 4, 5, 7, 11, 12, 13, 5, 6, 10, 15,  #> 20, 22, 25, 26, 9, 17, 20, 22, 5, 8, 12, 15, 16, 7, 8, 11, 13,  #> 14, 16, 7, 8, 12, 14, 7, 12, 13, 16, 18, 19, 5, 9, 11, 16, 25,  #> 26, 11, 12, 14, 15, 18, 24, 25, 10, 20, 23, 14, 16, 19, 24, 14,  #> 18, 24, 9, 10, 17, 22, 23, 27, 32, 33, 35, 40, 24, 30, 34, 9,  #> 10, 20, 26, 27, 28, 17, 20, 32, 16, 18, 19, 21, 25, 29, 30, 9,  #> 15, 16, 24, 26, 28, 29, 9, 15, 22, 25, 28, 29, 20, 22, 28, 33,  #> 22, 25, 26, 27, 29, 33, 35, 37, 38, 24, 25, 26, 28, 30, 37, 38,  #> 21, 24, 29, 37, 34, 36, 20, 23, 40, 41, 20, 27, 28, 35, 21, 31,  #> 36, 42, 20, 28, 33, 38, 40, 43, 44, 31, 34, 39, 42, 46, 28, 29,  #> 30, 38, 43, 45, 28, 29, 35, 37, 43, 44, 36, 46, 20, 32, 35, 41,  #> 47, 32, 40, 47, 34, 36, 35, 37, 38, 44, 45, 48, 35, 38, 43, 48,  #> 49, 37, 43, 48, 49, 36, 39, 40, 41, 43, 44, 45, 49, 44, 45, 48 #> ), c(0.5, 0.5, 0.333333333333333, 0.333333333333333, 0.333333333333333,  #> 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.142857142857143,  #> 0.142857142857143, 0.142857142857143, 0.142857142857143, 0.142857142857143,  #> 0.142857142857143, 0.142857142857143, 0.5, 0.5, 0.25, 0.25, 0.25,  #> 0.25, 0.166666666666667, 0.166666666666667, 0.166666666666667,  #> 0.166666666666667, 0.166666666666667, 0.166666666666667, 0.125,  #> 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.125, 0.25, 0.25,  #> 0.25, 0.25, 0.2, 0.2, 0.2, 0.2, 0.2, 0.166666666666667, 0.166666666666667,  #> 0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667,  #> 0.25, 0.25, 0.25, 0.25, 0.166666666666667, 0.166666666666667,  #> 0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667,  #> 0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667,  #> 0.166666666666667, 0.166666666666667, 0.142857142857143, 0.142857142857143,  #> 0.142857142857143, 0.142857142857143, 0.142857142857143, 0.142857142857143,  #> 0.142857142857143, 0.333333333333333, 0.333333333333333, 0.333333333333333,  #> 0.25, 0.25, 0.25, 0.25, 0.333333333333333, 0.333333333333333,  #> 0.333333333333333, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1,  #> 0.1, 0.333333333333333, 0.333333333333333, 0.333333333333333,  #> 0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667,  #> 0.166666666666667, 0.166666666666667, 0.333333333333333, 0.333333333333333,  #> 0.333333333333333, 0.142857142857143, 0.142857142857143, 0.142857142857143,  #> 0.142857142857143, 0.142857142857143, 0.142857142857143, 0.142857142857143,  #> 0.142857142857143, 0.142857142857143, 0.142857142857143, 0.142857142857143,  #> 0.142857142857143, 0.142857142857143, 0.142857142857143, 0.166666666666667,  #> 0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667,  #> 0.166666666666667, 0.25, 0.25, 0.25, 0.25, 0.111111111111111,  #> 0.111111111111111, 0.111111111111111, 0.111111111111111, 0.111111111111111,  #> 0.111111111111111, 0.111111111111111, 0.111111111111111, 0.111111111111111,  #> 0.142857142857143, 0.142857142857143, 0.142857142857143, 0.142857142857143,  #> 0.142857142857143, 0.142857142857143, 0.142857142857143, 0.25,  #> 0.25, 0.25, 0.25, 0.5, 0.5, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25,  #> 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.142857142857143, 0.142857142857143,  #> 0.142857142857143, 0.142857142857143, 0.142857142857143, 0.142857142857143,  #> 0.142857142857143, 0.2, 0.2, 0.2, 0.2, 0.2, 0.166666666666667,  #> 0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667,  #> 0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667,  #> 0.166666666666667, 0.166666666666667, 0.166666666666667, 0.5,  #> 0.5, 0.2, 0.2, 0.2, 0.2, 0.2, 0.333333333333333, 0.333333333333333,  #> 0.333333333333333, 0.5, 0.5, 0.166666666666667, 0.166666666666667,  #> 0.166666666666667, 0.166666666666667, 0.166666666666667, 0.166666666666667,  #> 0.2, 0.2, 0.2, 0.2, 0.2, 0.25, 0.25, 0.25, 0.25, 0.5, 0.5, 0.5,  #> 0.5, 0.25, 0.25, 0.25, 0.25, 0.333333333333333, 0.333333333333333,  #> 0.333333333333333), c(2, 3, 4, 4, 7, 2, 4, 6, 8, 4, 5, 6, 4,  #> 6, 6, 7, 3, 4, 3, 10, 3, 6, 3, 7, 7, 6, 4, 9, 7, 4, 2, 4, 4,  #> 4, 7, 5, 6, 6, 2, 5, 3, 2, 6, 5, 4, 2, 2, 4, 3))"},{"path":"https://r-spatial.github.io/spdep/reference/nb2blocknb.html","id":null,"dir":"Reference","previous_headings":"","what":"Block up neighbour list for location-less observations — nb2blocknb","title":"Block up neighbour list for location-less observations — nb2blocknb","text":"function blocks neighbour list known spatial locations create new neighbour list multiple location-less observations know belong spatial locations, using identification tags locations key.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2blocknb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Block up neighbour list for location-less observations — nb2blocknb","text":"","code":"nb2blocknb(nb=NULL, ID, row.names = NULL)"},{"path":"https://r-spatial.github.io/spdep/reference/nb2blocknb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Block up neighbour list for location-less observations — nb2blocknb","text":"nb object class nb list integer vectors containing neighbour region number ids; null, nb object neighbours created length unique(.character(ID)) ID identification tags locations location-less observations; sort(unique(.character(ID))) must identical sort(.character(attr(nb, \"region.id\"))); length row.names provided. row.names character vector observation ids added neighbours list attribute region.id, default seq(1, nrow(x)); length ID provided.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2blocknb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Block up neighbour list for location-less observations — nb2blocknb","text":"Assume list unique locations, neighbour list can build , create input neighbour list. needs \"unfolded\", observations belonging unique location observation neighbours, observations belonging location neighbours unique location question also observation neighbours, finally removing observation (neighbour). scenario also arises say post codes available, post codes contain multiple observations, known belong specific post code, located within (given post code locations known).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2blocknb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Block up neighbour list for location-less observations — nb2blocknb","text":"function returns object class nb list integer vectors containing neighbour observation number ids.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2blocknb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Block up neighbour list for location-less observations — nb2blocknb","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/nb2blocknb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Block up neighbour list for location-less observations — nb2blocknb","text":"","code":"# \\dontrun{ data(boston, package=\"spData\") summary(as.vector(table(boston.c$TOWN))) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>     1.0     2.0     4.0     5.5     7.0    30.0  townaggr <- aggregate(boston.utm, list(town=boston.c$TOWN), mean) block.rel <- graph2nb(relativeneigh(as.matrix(townaggr[,2:3])),  as.character(townaggr[,1]), sym=TRUE) block.rel #> Neighbour list object: #> Number of regions: 92  #> Number of nonzero links: 240  #> Percentage nonzero weights: 2.835539  #> Average number of links: 2.608696  print(is.symmetric.nb(block.rel)) #> [1] TRUE plot(block.rel, as.matrix(townaggr[,2:3])) points(boston.utm, pch=18, col=\"lightgreen\")  block.nb <- nb2blocknb(block.rel, as.character(boston.c$TOWN)) block.nb #> Neighbour list object: #> Number of regions: 506  #> Number of nonzero links: 15234  #> Percentage nonzero weights: 5.949945  #> Average number of links: 30.10672  print(is.symmetric.nb(block.nb)) #> [1] TRUE plot(block.nb, boston.utm) points(boston.utm, pch=18, col=\"lightgreen\")  n.comp.nb(block.nb)$nc #> [1] 1 moran.test(boston.c$CMEDV, nb2listw(boston.soi)) #>  #> \tMoran I test under randomisation #>  #> data:  boston.c$CMEDV   #> weights: nb2listw(boston.soi)     #>  #> Moran I statistic standard deviate = 21.786, p-value < 2.2e-16 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.690285059      -0.001980198       0.001009685  #>  moran.test(boston.c$CMEDV, nb2listw(block.nb)) #>  #> \tMoran I test under randomisation #>  #> data:  boston.c$CMEDV   #> weights: nb2listw(block.nb)     #>  #> Moran I statistic standard deviate = 22.455, p-value < 2.2e-16 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>      0.3122905961     -0.0019801980      0.0001958827  #>  block.nb <- nb2blocknb(NULL, as.character(boston.c$TOWN)) #> Warning: neighbour object has 92 sub-graphs block.nb #> Neighbour list object: #> Number of regions: 506  #> Number of nonzero links: 4868  #> Percentage nonzero weights: 1.901295  #> Average number of links: 9.620553  #> 17 regions with no links: #> 1, 55, 56, 57, 58, 65, 196, 257, 284, 285, 286, 287, 342, 343, 348, #> 349, 354 #> 92 disjoint connected subgraphs print(is.symmetric.nb(block.nb)) #> [1] TRUE plot(block.nb, boston.utm)  n.comp.nb(block.nb)$nc #> [1] 92 moran.test(boston.c$CMEDV, nb2listw(block.nb, zero.policy=TRUE), zero.policy=TRUE) #>  #> \tMoran I test under randomisation #>  #> data:  boston.c$CMEDV   #> weights: nb2listw(block.nb, zero.policy = TRUE)   #> n reduced by no-neighbour observations   #>  #> Moran I statistic standard deviate = 21.145, p-value < 2.2e-16 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>      0.6188830566     -0.0020491803      0.0008623116  #>  # }"},{"path":"https://r-spatial.github.io/spdep/reference/nb2lines.html","id":null,"dir":"Reference","previous_headings":"","what":"Use vector files for import and export of weights — nb2lines","title":"Use vector files for import and export of weights — nb2lines","text":"Use vector files import export weights, storing spatial entity coordinates arcs, entity indices data frame.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2lines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use vector files for import and export of weights — nb2lines","text":"","code":"nb2lines(nb, wts, coords, proj4string=NULL, as_sf=FALSE) listw2lines(listw, coords, proj4string=NULL, as_sf=FALSE) df2sn(df, i=\"i\", i_ID=\"i_ID\", j=\"j\", wt=\"wt\")"},{"path":"https://r-spatial.github.io/spdep/reference/nb2lines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use vector files for import and export of weights — nb2lines","text":"nb neighbour object class nb wts list general weights corresponding neighbours coords matrix region point coordinates, Spatial object (points polygons), sfc object (points polygons) proj4string default NULL; coords Spatial sf object, value used, otherwise value converted appropriately as_sf output object Spatial sf format, default FALSE, set TRUE coords sfc object FALSE Spatial object listw listw object spatial weights df data frame read shapefile, derived output nb2lines character name column df entity index i_ID character name column df entity region ID j character name column df entity index wt character name column df weights","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2lines.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Use vector files for import and export of weights — nb2lines","text":"neighbour weights objects may retrieved converting specified columns data slot SpatialLinesDataFrame object spatial.neighbour object, converted weights list object.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2lines.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Use vector files for import and export of weights — nb2lines","text":"nb2lines listw2lines return SpatialLinesDataFrame object sf object; data frame contains indices neighbour links weights. df2sn converts data retrieved reading data df back spatial.neighbour object.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2lines.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Use vector files for import and export of weights — nb2lines","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2lines.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Use vector files for import and export of weights — nb2lines","text":"Original idea due Gidske Leknes Andersen, Department Biology, University Bergen, Norway","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/nb2lines.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Use vector files for import and export of weights — nb2lines","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) res <- listw2lines(nb2listw(col.gal.nb), st_geometry(columbus)) summary(res) #>        i               j             i_ID               j_ID           #>  Min.   : 1.00   Min.   : 1.00   Length:230         Length:230         #>  1st Qu.:13.00   1st Qu.:13.00   Class :character   Class :character   #>  Median :24.00   Median :24.00   Mode  :character   Mode  :character   #>  Mean   :24.19   Mean   :24.19                                         #>  3rd Qu.:35.00   3rd Qu.:35.00                                         #>  Max.   :49.00   Max.   :49.00                                         #>        wt               geometry   #>  Min.   :0.1000   LINESTRING:230   #>  1st Qu.:0.1429   epsg:NA   :  0   #>  Median :0.1667                    #>  Mean   :0.2130                    #>  3rd Qu.:0.2500                    #>  Max.   :0.5000                    tf <- paste0(tempfile(), \".gpkg\") st_write(res, dsn=tf, driver=\"GPKG\") #> Writing layer `file1096c55f392772' to data source  #>   `/tmp/RtmpWV09nn/file1096c55f392772.gpkg' using driver `GPKG' #> Writing 230 features with 5 fields and geometry type Line String. inMap <- st_read(tf) #> Reading layer `file1096c55f392772' from data source  #>   `/tmp/RtmpWV09nn/file1096c55f392772.gpkg' using driver `GPKG' #> Simple feature collection with 230 features and 5 fields #> Geometry type: LINESTRING #> Dimension:     XY #> Bounding box:  xmin: 6.165913 ymin: 11.04088 xmax: 10.96206 ymax: 14.43766 #> Projected CRS: Undefined Cartesian SRS with unknown unit summary(inMap) #>        i               j             i_ID               j_ID           #>  Min.   : 1.00   Min.   : 1.00   Length:230         Length:230         #>  1st Qu.:13.00   1st Qu.:13.00   Class :character   Class :character   #>  Median :24.00   Median :24.00   Mode  :character   Mode  :character   #>  Mean   :24.19   Mean   :24.19                                         #>  3rd Qu.:35.00   3rd Qu.:35.00                                         #>  Max.   :49.00   Max.   :49.00                                         #>        wt                 geom     #>  Min.   :0.1000   LINESTRING:230   #>  1st Qu.:0.1429   epsg:NA   :  0   #>  Median :0.1667                    #>  Mean   :0.2130                    #>  3rd Qu.:0.2500                    #>  Max.   :0.5000                    diffnb(sn2listw(df2sn(as.data.frame(inMap)))$neighbours, col.gal.nb) #> Warning: style is M (missing); style should be set to a valid value #> Warning: neighbour object has 49 sub-graphs #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 0  #> Percentage nonzero weights: 0  #> Average number of links: 0  #> 49 regions with no links: #> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, #> 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, #> 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49 #> 49 disjoint connected subgraphs res1 <- listw2lines(nb2listw(col.gal.nb), as(columbus, \"Spatial\")) summary(res1) #> Object of class SpatialLinesDataFrame #> Coordinates: #>         min      max #> x  6.221943 10.95359 #> y 11.010031 14.36908 #> Is projected: TRUE  #> proj4string : [NA] #> Data attributes: #>        i               j             i_ID               j_ID           #>  Min.   : 1.00   Min.   : 1.00   Length:230         Length:230         #>  1st Qu.:13.00   1st Qu.:13.00   Class :character   Class :character   #>  Median :24.00   Median :24.00   Mode  :character   Mode  :character   #>  Mean   :24.19   Mean   :24.19                                         #>  3rd Qu.:35.00   3rd Qu.:35.00                                         #>  Max.   :49.00   Max.   :49.00                                         #>        wt         #>  Min.   :0.1000   #>  1st Qu.:0.1429   #>  Median :0.1667   #>  Mean   :0.2130   #>  3rd Qu.:0.2500   #>  Max.   :0.5000"},{"path":"https://r-spatial.github.io/spdep/reference/nb2listw.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial weights for neighbours lists — nb2listw","title":"Spatial weights for neighbours lists — nb2listw","text":"nb2listw function supplements neighbours list spatial weights chosen coding scheme. can..simmed helper function checks whether spatial weights object similar symmetric can transformed yield real eigenvalues Cholesky decomposition. helper function listw2U() constructs weights list object corresponding sparse matrix \\(\\frac{1}{2} ( \\mathbf{W} + \\mathbf{W}'\\).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2listw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial weights for neighbours lists — nb2listw","text":"","code":"nb2listw(neighbours, glist=NULL, style=\"W\", zero.policy=NULL) listw2U(listw)"},{"path":"https://r-spatial.github.io/spdep/reference/nb2listw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial weights for neighbours lists — nb2listw","text":"neighbours object class nb glist list general weights corresponding neighbours style style can take values “W”, “B”, “C”, “U”, “minmax” “S” zero.policy default NULL, use global option value; FALSE stop error empty neighbour sets, TRUE permit weights list formed zero-length weights vectors listw listw object created example nb2listw","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2listw.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial weights for neighbours lists — nb2listw","text":"Starting binary neighbours list, regions either listed neighbours absent (thus set neighbours definition), function adds weights list values given coding scheme style chosen. B basic binary coding, W row standardised (sums links n), C globally standardised (sums links n), U equal C divided number neighbours (sums links unity), S variance-stabilizing coding scheme proposed Tiefelsdorf et al. 1999, p. 167-168 (sums links n). zero policy set TRUE, weights vectors zero length inserted regions without neighbour neighbours list. turn generate lag values zero, equivalent sum products zero row t(rep(0, length=length(neighbours))) %*% x, arbitraty numerical vector x length length(neighbours). spatially lagged value x zero-neighbour region zero, may (may ) sensible choice. sum glist vector one observations zero, warning message issued. consequence later operations -neighbour observations present zero.policy argument set true. “minmax” style based Kelejian Prucha (2010), divides weights minimum maximum row sums maximum column sums input weights. similar C U styles; also available Stata.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2listw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial weights for neighbours lists — nb2listw","text":"listw object following members: style one W, B, C, U, S, minmax neighbours input neighbours list weights weights neighbours chosen style, attributes set report type relationships (binary general, general form glist argument), style attributes: region.id character, neighbour object call function call zero.policy logical; value zero.policy object created","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2listw.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spatial weights for neighbours lists — nb2listw","text":"Tiefelsdorf, M., Griffith, D. ., Boots, B. 1999 variance-stabilizing coding scheme spatial link matrices, Environment Planning , 31, pp. 165–180; Kelejian, H. H., . R. Prucha. 2010. Specification estimation spatial autoregressive models autoregressive heteroskedastic disturbances. Journal Econometrics, 157: pp. 53–67.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2listw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial weights for neighbours lists — nb2listw","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/nb2listw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial weights for neighbours lists — nb2listw","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) coords <- st_coordinates(st_centroid(columbus)) #> Warning: st_centroid assumes attributes are constant over geometries cards <- card(col.gal.nb) col.w <- nb2listw(col.gal.nb) plot(cards, unlist(lapply(col.w$weights, sum)),xlim=c(0,10), ylim=c(0,10), xlab=\"number of links\", ylab=\"row sums of weights\") col.b <- nb2listw(col.gal.nb, style=\"B\") points(cards, unlist(lapply(col.b$weights, sum)), col=\"red\") col.c <- nb2listw(col.gal.nb, style=\"C\") points(cards, unlist(lapply(col.c$weights, sum)), col=\"green\") col.u <- nb2listw(col.gal.nb, style=\"U\") points(cards, unlist(lapply(col.u$weights, sum)), col=\"orange\") col.s <- nb2listw(col.gal.nb, style=\"S\") points(cards, unlist(lapply(col.s$weights, sum)), col=\"blue\") legend(x=c(0, 1), y=c(7, 9), legend=c(\"W\", \"B\", \"C\", \"U\", \"S\"), bty=\"n\", col=c(\"black\", \"red\", \"green\", \"orange\", \"blue\"), pch=rep(1,5), cex=0.8, y.intersp=2.5)  summary(nb2listw(col.gal.nb, style=\"minmax\")) #> Characteristics of weights list object: #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.579342  #> Average number of links: 4.693878  #> Link number distribution: #>  #>  2  3  4  5  6  7  8  9 10  #>  7  7 13  4  9  6  1  1  1  #> 7 least connected regions: #> 1 6 31 39 42 46 47 with 2 links #> 1 most connected region: #> 20 with 10 links #>  #> Weights style: minmax  #> Weights constants summary: #>         n   nn S0  S1    S2 #> minmax 49 2401 23 4.6 50.48 dlist <- nbdists(col.gal.nb, coords) dlist <- lapply(dlist, function(x) 1/x) col.w.d <- nb2listw(col.gal.nb, glist=dlist) summary(unlist(col.w$weights)) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.1000  0.1429  0.1667  0.2130  0.2500  0.5000  summary(unlist(col.w.d$weights)) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #> 0.06977 0.13114 0.17710 0.21304 0.27124 0.67178  # introducing other conditions into weights - only earlier sales count # see http://sal.uiuc.edu/pipermail/openspace/2005-October/000610.html data(baltimore, package=\"spData\") set.seed(211) dates <- sample(1:500, nrow(baltimore), replace=TRUE) nb_15nn <- knn2nb(knearneigh(cbind(baltimore$X, baltimore$Y), k=15)) glist <- vector(mode=\"list\", length=length(nb_15nn)) for (i in seq(along=nb_15nn))   glist[[i]] <- ifelse(dates[i] > dates[nb_15nn[[i]]], 1, 0) listw_15nn_dates <- nb2listw(nb_15nn, glist=glist, style=\"B\") #> Warning: zero sum general weights which(lag(listw_15nn_dates, baltimore$PRICE) == 0.0) #>  [1]   1  22  29  35  66  74  80  99 117 147 155 169 195 197 200 which(sapply(glist, sum) == 0) #>  [1]   1  22  29  35  66  74  80  99 117 147 155 169 195 197 200 ex <- which(sapply(glist, sum) == 0)[1] dates[ex] #> [1] 28 dates[nb_15nn[[ex]]] #>  [1] 395 247 275 179 142 484 111 239 369 199 294 251 448 390 229"},{"path":"https://r-spatial.github.io/spdep/reference/nb2listwdist.html","id":null,"dir":"Reference","previous_headings":"","what":"Distance-based spatial weights for neighbours lists — nb2listwdist","title":"Distance-based spatial weights for neighbours lists — nb2listwdist","text":"nb2listwdist function supplements neighbours list spatial weights chosen types distance modelling coding scheme. offered coding schemes parallel nb2listw function, three distance-based types weights available: inverse distance weighting (IDW), double-power distance weights, exponential distance decay. can..simmed helper function checks whether spatial weights object similar symmetric can transformed yield real eigenvalues Cholesky decomposition.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2listwdist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distance-based spatial weights for neighbours lists — nb2listwdist","text":"","code":"nb2listwdist(neighbours, x, type=\"idw\", style=\"raw\",    alpha = 1, dmax = NULL, longlat = NULL, zero.policy=NULL)"},{"path":"https://r-spatial.github.io/spdep/reference/nb2listwdist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distance-based spatial weights for neighbours lists — nb2listwdist","text":"neighbours object class nb x sp sf, sfc object type default “idw”; intended type distance modelling, can take values “idw”, “exp”, “dpd” style default “raw”; style can take values “raw”, “W”, “B”, “C”, “U”, “minmax”, “S” alpha default 0; parameter controlling distance modelling, see “Details” dmax default NULL, maximum distance threshold required type “dpd” optional types longlat default NULL; TRUE point coordinates longitude-latitude decimal degrees, case distances measured metres; x SpatialPoints object, value taken object , overrides argument NULL; distances measured map units FALSE NULL zero.policy default NULL; use global option value; FALSE stop error empty neighbour sets, TRUE permit weights list formed zero-length weights vectors","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2listwdist.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Distance-based spatial weights for neighbours lists — nb2listwdist","text":"Starting binary neighbours list, regions either listed neighbours absent (thus set neighbours definition), function adds distance-based weights list. Three types distance weight calculations based pairwise distances \\(d_{ij}\\) possible, controlled parameter “alpha” (\\(\\alpha\\) ): $$\\textrm{idw: } w_{ij} = d_{ij}^{-\\alpha},$$ $$\\textrm{exp: } w_{ij} = \\exp(-\\alpha \\cdot d_{ij}),$$ $$\\textrm{dpd: } w_{ij} = \\left[1 - \\left(d_{ij}/d_{\\textrm{max}}\\right)^{\\alpha}\\right]^{\\alpha},$$ latter leads \\(w_{ij} = 0\\) \\(d_{ij} > d_{\\textrm{max}}\\). Note IDW weights show extreme behaviour close 0 can take value infinity. cases, infinite values replaced largest finite weight present weights list. default coding scheme “raw”, outputs raw distance-based weights without applying kind normalisation. addition, coding scheme styles also available nb2listw function can chosen. B basic binary coding, W row standardised (sums links n), C globally standardised (sums links n), U equal C divided number neighbours (sums links unity), S variance-stabilising coding scheme proposed Tiefelsdorf et al. 1999, p. 167-168 (sums links n). “minmax” style based Kelejian Prucha (2010), divides weights minimum maximum row sums maximum column sums input weights. similar C U styles; also available Stata. zero.policy set TRUE, weights vectors zero length inserted regions without neighbour neighbours list. turn generate lag values zero, equivalent sum products zero row t(rep(0, length=length(neighbours))) %*% x, arbitraty numerical vector x length length(neighbours). spatially lagged value x zero-neighbour region zero, may (may ) sensible choice.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2listwdist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distance-based spatial weights for neighbours lists — nb2listwdist","text":"listw object following members: style one W, B, C, U, S, minmax type one idw, exp, dpd neighbours input neighbours list weights weights neighbours chosen style, attributes set report type relationships (binary general, general form glist argument), style ","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2listwdist.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Distance-based spatial weights for neighbours lists — nb2listwdist","text":"Tiefelsdorf, M., Griffith, D. ., Boots, B. 1999 variance-stabilizing coding scheme spatial link matrices, Environment Planning , 31, pp. 165–180; Kelejian, H. H., . R. Prucha. 2010. Specification estimation spatial autoregressive models autoregressive heteroskedastic disturbances. Journal Econometrics, 157: pp. 53–67.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2listwdist.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Distance-based spatial weights for neighbours lists — nb2listwdist","text":"Rene Westerholt rene.westerholt@tu-dortmund.de","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/nb2listwdist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distance-based spatial weights for neighbours lists — nb2listwdist","text":"","code":"# World examples data(world, package=\"spData\") # neighbours on distance interval [0, 1000] kilometres # suppressWarnings(st_crs(world) <- \"+proj=longlat\") # for older PROJ pts <- st_centroid(st_transform(world, 3857)) #> Warning: st_centroid assumes attributes are constant over geometries nb_world <- dnearneigh(pts, 0, 1000000) #> Warning: neighbour object has 46 sub-graphs # Moran's I (life expectancy) with IDW with alpha = 2, no coding scheme world_weights <- nb2listwdist(nb_world, as(pts, \"Spatial\"), type = \"idw\",   alpha = 2, zero.policy = TRUE) moran.test(world$lifeExp, world_weights, zero.policy = TRUE, na.action = na.pass) #> Warning: NAs in lagged values #>  #> \tMoran I test under randomisation #>  #> data:  world$lifeExp   #> weights: world_weights   #> n reduced by no-neighbour observations   #>  #> Moran I statistic standard deviate = 2.7769, p-value = 0.002744 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.473883371      -0.007042254       0.029994057  #>  # \\dontrun{ # Moran's I (life expectancy) with IDW with alpha = 2, no coding scheme world_weights <- nb2listwdist(nb_world, pts, type = \"idw\",   alpha = 2, zero.policy = TRUE) moran.test(world$lifeExp, world_weights, zero.policy = TRUE, na.action = na.pass) #> Warning: NAs in lagged values #>  #> \tMoran I test under randomisation #>  #> data:  world$lifeExp   #> weights: world_weights   #> n reduced by no-neighbour observations   #>  #> Moran I statistic standard deviate = 2.7769, p-value = 0.002744 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.473883371      -0.007042254       0.029994057  #>  # Moran's I (life expectancy), DPD, alpha = 2, dmax = 1000 km, no coding scheme world_weights <- nb2listwdist(nb_world, pts, type = \"dpd\",   dmax = 1000000, alpha = 2, zero.policy = TRUE) moran.test(world$lifeExp, world_weights, zero.policy = TRUE, na.action = na.pass) #> Warning: NAs in lagged values #>  #> \tMoran I test under randomisation #>  #> data:  world$lifeExp   #> weights: world_weights   #> n reduced by no-neighbour observations   #>  #> Moran I statistic standard deviate = 8.8557, p-value < 2.2e-16 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.601498970      -0.007042254       0.004722063  #>  # Boston examples data(boston, package=\"spData\") boston_coords <- data.frame(x = boston.utm[,1], y = boston.utm[,2]) boston.geoms <- st_as_sf(boston_coords, coords = c(\"x\", \"y\"), remove = FALSE) nb_boston <- dnearneigh(boston.geoms, 0, 3) #> Warning: neighbour object has 9 sub-graphs # Moran's I (crime) with exp weights with alpha = 2, no coding scheme boston_weights <- nb2listwdist(nb_boston, boston.geoms, type = \"exp\", alpha = 2,   style=\"raw\", zero.policy = TRUE) moran.test(boston.c$CRIM, boston_weights, zero.policy = TRUE, na.action = na.pass) #>  #> \tMoran I test under randomisation #>  #> data:  boston.c$CRIM   #> weights: boston_weights   #> n reduced by no-neighbour observations   #>  #> Moran I statistic standard deviate = 51.34, p-value < 2.2e-16 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>      0.8845114518     -0.0019960080      0.0002981586  #>  # Moran's I (crime) with idw weights with alpha = 2, coding scheme = W boston_weights <- nb2listwdist(nb_boston, boston.geoms, type = \"idw\", alpha = 2,   style=\"W\", zero.policy = TRUE) moran.test(boston.c$CRIM, boston_weights, zero.policy = TRUE, na.action = na.pass) #>  #> \tMoran I test under randomisation #>  #> data:  boston.c$CRIM   #> weights: boston_weights   #> n reduced by no-neighbour observations   #>  #> Moran I statistic standard deviate = 18.976, p-value < 2.2e-16 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>      0.4392852330     -0.0019960080      0.0005408065  #>  # }"},{"path":"https://r-spatial.github.io/spdep/reference/nb2mat.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial weights matrices for neighbours lists — nb2mat","title":"Spatial weights matrices for neighbours lists — nb2mat","text":"function generates weights matrix neighbours list spatial weights chosen coding scheme.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2mat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial weights matrices for neighbours lists — nb2mat","text":"","code":"nb2mat(neighbours, glist=NULL, style=\"W\", zero.policy=NULL) listw2mat(listw)"},{"path":"https://r-spatial.github.io/spdep/reference/nb2mat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial weights matrices for neighbours lists — nb2mat","text":"neighbours object class nb glist list general weights corresponding neighbours style style can take values W, B, C, S zero.policy default NULL, use global option value; FALSE stop error empty neighbour sets, TRUE permit weights list formed zero-length weights vectors listw listw object example nb2listw","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2mat.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial weights matrices for neighbours lists — nb2mat","text":"Starting binary neighbours list, regions either listed neighbours absent (thus set neighbours definition), function creates n n weights matrix values given coding scheme style chosen. B basic binary coding, W row standardised, C globally standardised, S variance-stabilizing coding scheme proposed Tiefelsdorf et al. 1999, p. 167-168. function leaves matrix rows zero regions zero neighbours fore zero.policy TRUE. turn generate lag values zero, equivalent sum products zero row t(rep(0, length=length(neighbours))) %*% x, arbitraty numerical vector x length length(neighbours). spatially lagged value x zero-neighbour region zero, may (may ) sensible choice.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2mat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial weights matrices for neighbours lists — nb2mat","text":"n n matrix, n=length(neighbours)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2mat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spatial weights matrices for neighbours lists — nb2mat","text":"Tiefelsdorf, M., Griffith, D. ., Boots, B. 1999 variance-stabilizing coding scheme spatial link matrices, Environment Planning , 31, pp. 165-180.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nb2mat.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial weights matrices for neighbours lists — nb2mat","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/nb2mat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial weights matrices for neighbours lists — nb2mat","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col005 <- dnearneigh(st_coordinates(st_centroid(st_geometry(columbus),  of_largest_polygon=TRUE)), 0, 0.5, as.character(columbus$NEIGNO)) #> Warning: neighbour object has 8 sub-graphs summary(col005) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 170  #> Percentage nonzero weights: 7.080383  #> Average number of links: 3.469388  #> 4 regions with no links: #> 1005, 1006, 1008, 1043 #> 8 disjoint connected subgraphs #> Link number distribution: #>  #>  0  1  2  3  4  5  6  7  8  9  #>  4 11  5  8  3  9  2  2  3  2  #> 11 least connected regions: #> 1001 1007 1018 1010 1045 1044 1046 1047 1049 1048 1015 with 1 link #> 2 most connected regions: #> 1038 1036 with 9 links col005.w.mat <- nb2mat(col005, style=\"B\", zero.policy=TRUE) table(round(rowSums(col005.w.mat))) #>  #>  0  1  2  3  4  5  6  7  8  9  #>  4 11  5  8  3  9  2  2  3  2"},{"path":"https://r-spatial.github.io/spdep/reference/nbcosts.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute cost of edges — nbcosts","title":"Compute cost of edges — nbcosts","text":"cost edge distance nodes. function   compute distance using data.frame observations vector   node.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nbcosts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute cost of edges — nbcosts","text":"","code":"nbcost(data, id, id.neigh,  method = c(\"euclidean\", \"maximum\",      \"manhattan\", \"canberra\", \"binary\", \"minkowski\", \"mahalanobis\"),     p = 2, cov, inverted = FALSE) nbcosts(nb, data,  method = c(\"euclidean\", \"maximum\",      \"manhattan\", \"canberra\", \"binary\", \"minkowski\", \"mahalanobis\"),     p = 2, cov, inverted = FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/nbcosts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute cost of edges — nbcosts","text":"nb object nb class. See poly2nb     details. data matrix observations nodes. id Node index compute cost id.neigh Idex neighbours nodes node id method Character function declare distance method.     method character, method must \"mahalanobis\"     \"euclidean\", \"maximum\", \"manhattan\", \"canberra\", \"binary\"     \"minkowisk\".     method one \"euclidean\", \"maximum\",     \"manhattan\", \"canberra\", \"binary\" \"minkowisk\", see     dist details,      function used compute distance.      method=\"mahalanobis\", mahalanobis distance      computed neighbour areas.      method function, function      used compute distance. p power Minkowski distance. cov covariance matrix used compute mahalanobis    distance. inverted logical.  'TRUE', 'cov' supposed contain           inverse covariance matrix.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nbcosts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute cost of edges — nbcosts","text":"object nbdist class. See nbdists   details.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nbcosts.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Compute cost of edges — nbcosts","text":"neighbours must connected graph.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nbcosts.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute cost of edges — nbcosts","text":"Elias T. Krainski Renato M. Assuncao","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/nbdists.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial link distance measures — nbdists","title":"Spatial link distance measures — nbdists","text":"Given list spatial neighbour links (neighbours list object type   nb), function returns Euclidean distances along links   list form neighbours list. longlat = TRUE, Great   Circle distances used.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nbdists.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial link distance measures — nbdists","text":"","code":"nbdists(nb, coords, longlat = NULL)"},{"path":"https://r-spatial.github.io/spdep/reference/nbdists.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial link distance measures — nbdists","text":"nb object class nb coords matrix point coordinates, object inheriting SpatialPoints \"sf\" \"sfc\" object; \"sf\" \"sfc\" object geometries geographical coordinates (sf::st_is_longlat(x) == TRUE sf::sf_use_s2() == TRUE), s2 used find distances https://github.com/r-spatial/s2/issues/125 longlat TRUE point coordinates longitude-latitude decimal degrees, case distances measured kilometers; coords SpatialPoints object, value taken object ","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nbdists.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial link distance measures — nbdists","text":"list class nbdist","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nbdists.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial link distance measures — nbdists","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/nbdists.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial link distance measures — nbdists","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) coords <- st_coordinates(st_centroid(columbus)) #> Warning: st_centroid assumes attributes are constant over geometries dlist <- nbdists(col.gal.nb, coords) dlist <- lapply(dlist, function(x) 1/x) stem(unlist(dlist)) #>  #>   The decimal point is at the | #>  #>   1 | 1111112222223333334444444444 #>   1 | 555555556666667777777777888888888899999999999999999999 #>   2 | 00000000111111111111111122222222222222333333333333334444 #>   2 | 55555555556666666666666677777777888888999999 #>   3 | 0000111111222233334444 #>   3 | 77779999 #>   4 | 223344 #>   4 | 77 #>   5 | 001144 #>   5 |  #>   6 |  #>   6 | 99 #>   7 |  #>   7 | 88 #>"},{"path":"https://r-spatial.github.io/spdep/reference/nblag.html","id":null,"dir":"Reference","previous_headings":"","what":"Higher order neighbours lists — nblag","title":"Higher order neighbours lists — nblag","text":"function creates higher order neighbour lists, higher order neighbours lags links graph described input neighbours list. refuse lag neighbours lists attribute self.included set TRUE. nblag_cumul cumulates neighbour lists single neighbour list (“nb” object).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nblag.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Higher order neighbours lists — nblag","text":"","code":"nblag(neighbours, maxlag) nblag_cumul(nblags)"},{"path":"https://r-spatial.github.io/spdep/reference/nblag.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Higher order neighbours lists — nblag","text":"neighbours input neighbours list class nb maxlag maximum lag constructed nblags list neighbour lists output nblag","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nblag.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Higher order neighbours lists — nblag","text":"returns list lagged neighbours lists class nb","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nblag.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Higher order neighbours lists — nblag","text":"Roger Bivand Roger.Bivand@nhh.Giovanni Millo","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/nblag.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Higher order neighbours lists — nblag","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) coords <- st_coordinates(st_centroid(columbus)) #> Warning: st_centroid assumes attributes are constant over geometries summary(col.gal.nb, coords) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.579342  #> Average number of links: 4.693878  #> Link number distribution: #>  #>  2  3  4  5  6  7  8  9 10  #>  7  7 13  4  9  6  1  1  1  #> 7 least connected regions: #> 1 6 31 39 42 46 47 with 2 links #> 1 most connected region: #> 20 with 10 links col.lags <- nblag(col.gal.nb, 2) print(col.lags) #> [[1]] #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.579342  #> Average number of links: 4.693878  #>  #> [[2]] #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 406  #> Percentage nonzero weights: 16.90962  #> Average number of links: 8.285714  #>  #> attr(,\"call\") #> nblag(neighbours = col.gal.nb, maxlag = 2) summary(col.lags[[2]], coords) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 406  #> Percentage nonzero weights: 16.90962  #> Average number of links: 8.285714  #> Link number distribution: #>  #>  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17  #>  1  2  5  4  2  3  5  4  2  3  7  3  4  1  1  1  1  #> 1 least connected region: #> 36 with 1 link #> 1 most connected region: #> 25 with 17 links plot(st_geometry(columbus), border=\"grey\") plot(col.gal.nb, coords, add=TRUE) title(main=\"GAL order 1 (black) and 2 (red) links\") plot(col.lags[[2]], coords, add=TRUE, col=\"red\", lty=2)  cuml <- nblag_cumul(col.lags) cuml #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 636  #> Percentage nonzero weights: 26.48896  #> Average number of links: 12.97959  run <- FALSE if (require(igraph, quietly=TRUE) && require(spatialreg, quietly=TRUE)) run <- TRUE if (run) { W <- as(nb2listw(col.gal.nb), \"CsparseMatrix\") G <- graph_from_adjacency_matrix(W, mode=\"directed\", weight=\"W\") D <- diameter(G) nbs <- nblag(col.gal.nb, maxlag=D) n <- length(col.gal.nb) lmat <- lapply(nbs, nb2mat, style=\"B\", zero.policy=TRUE) mat <- matrix(0, n, n) for (i in seq(along=lmat)) mat = mat + i*lmat[[i]] G2 <- distances(G) print(all.equal(G2, mat, check.attributes=FALSE)) } #> Warning: lag 6 neighbour object has 5 sub-graphs #> Warning: lag 7 neighbour object has 20 sub-graphs #> Warning: lag 8 neighbour object has 36 sub-graphs #> Warning: lag 9 neighbour object has 44 sub-graphs #> [1] TRUE"},{"path":"https://r-spatial.github.io/spdep/reference/nboperations.html","id":null,"dir":"Reference","previous_headings":"","what":"Set operations on neighborhood objects — nb.set.operations","title":"Set operations on neighborhood objects — nb.set.operations","text":"Set operations neighbors list objects","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nboperations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set operations on neighborhood objects — nb.set.operations","text":"","code":"intersect.nb(nb.obj1,nb.obj2) union.nb(nb.obj1,nb.obj2) setdiff.nb(nb.obj1,nb.obj2) complement.nb(nb.obj)"},{"path":"https://r-spatial.github.io/spdep/reference/nboperations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set operations on neighborhood objects — nb.set.operations","text":"nb.obj neighbor list created neighborhood     list funtions nb.obj1 neighbor list created neighborhood     list funtions nb.obj2 neighbor list created neighborhood     list funtions","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nboperations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set operations on neighborhood objects — nb.set.operations","text":"functions perform set operations element   neighborlist. arguments must neighbor lists created   coordinates, region.id attributes must identical.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nboperations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set operations on neighborhood objects — nb.set.operations","text":"nb.obj new neighborlist created set operations                input neighbor list(s)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/nboperations.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Set operations on neighborhood objects — nb.set.operations","text":"Nicholas Lewin-Koh nikko@hailmail.net","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/nboperations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set operations on neighborhood objects — nb.set.operations","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) coords <- st_coordinates(st_centroid(columbus)) #> Warning: st_centroid assumes attributes are constant over geometries col.tri.nb <- tri2nb(coords) oldpar <- par(mfrow=c(1,2)) if (require(\"dbscan\", quietly=TRUE)) {   col.soi.nb <- graph2nb(soi.graph(col.tri.nb, coords))   plot(st_geometry(columbus), border=\"grey\")   plot(col.soi.nb, coords, add=TRUE)   title(main=\"Sphere of Influence Graph\", cex.main=0.7)   plot(st_geometry(columbus), border=\"grey\")   plot(complement.nb(col.soi.nb), coords, add=TRUE)   title(main=\"Complement of Sphere of Influence Graph\", cex.main=0.7) }  par(mfrow=c(2,2)) col2 <- droplinks(col.gal.nb, 21) #> Warning: some observations have no neighbours #> Warning: neighbour object has 3 sub-graphs plot(intersect.nb(col.gal.nb, col2), coords) #> Warning: neighbour object has 3 sub-graphs title(main=\"Intersect\", cex.main=0.7) plot(union.nb(col.gal.nb, col2), coords) title(main=\"Union\", cex.main=0.7) plot(setdiff.nb(col.gal.nb, col2), coords) #> Warning: neighbour object has 46 sub-graphs title(main=\"Set diff\", cex.main=0.7) par(oldpar)"},{"path":"https://r-spatial.github.io/spdep/reference/p.adjustSP.html","id":null,"dir":"Reference","previous_headings":"","what":"Adjust local association measures' p-values — p.adjustSP","title":"Adjust local association measures' p-values — p.adjustSP","text":"Make adjustment local association measures' p-values based number neighbours (+1) region, rather total number regions.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/p.adjustSP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Adjust local association measures' p-values — p.adjustSP","text":"","code":"p.adjustSP(p, nb, method = \"none\")"},{"path":"https://r-spatial.github.io/spdep/reference/p.adjustSP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Adjust local association measures' p-values — p.adjustSP","text":"p vector p-values nb list neighbours class nb method correction method defined p.adjust: \"adjustment methods include Bonferroni correction ('\"bonferroni\"') p-values multiplied number comparisons.  Four less conservative corrections also included Holm (1979) ('holm'), Hochberg (1988) ('hochberg'), Hommel (1988) ('hommel') Benjamini & Hochberg (1995) ('fdr'), respectively. pass-option ('none') also included.\"","code":""},{"path":"https://r-spatial.github.io/spdep/reference/p.adjustSP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Adjust local association measures' p-values — p.adjustSP","text":"vector corrected p-values using number neighbours + 1.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/p.adjustSP.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Adjust local association measures' p-values — p.adjustSP","text":"Danlin Yu Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/p.adjustSP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Adjust local association measures' p-values — p.adjustSP","text":"","code":"data(afcon, package=\"spData\") oid <- order(afcon$id) resG <- as.vector(localG(afcon$totcon, nb2listw(include.self(paper.nb)))) non <- format.pval(pnorm(2*(abs(resG)), lower.tail=FALSE), 2) bon <- format.pval(p.adjustSP(pnorm(2*(abs(resG)), lower.tail=FALSE),  paper.nb, \"bonferroni\"), 2) tot <- format.pval(p.adjust(pnorm(2*(abs(resG)), lower.tail=FALSE),  \"bonferroni\", n=length(resG)), 2) data.frame(resG, non, bon, tot, row.names=afcon$name)[oid,] #>                                 resG     non     bon     tot #> THE GAMBIA               -0.98383592 0.02455 0.04911  1.0000 #> MALI                     -1.69893391 0.00034 0.00272  0.0143 #> SENEGAL                  -1.46321911 0.00171 0.00857  0.0720 #> BENIN                    -1.30139679 0.00462 0.02312  0.1942 #> MAURITANIA               -0.60496775 0.11315 0.56576  1.0000 #> NIGER                    -1.04877003 0.01797 0.14378  0.7549 #> IVORY COAST              -1.41712454 0.00230 0.01378  0.0965 #> GUINEA                   -1.44888005 0.00188 0.01128  0.0789 #> BURKINA FASO             -1.75085492 0.00023 0.00162  0.0097 #> LIBERIA                  -1.04053617 0.01871 0.07485  0.7860 #> SIERRA LEONE             -0.87032623 0.04087 0.12262  1.0000 #> GHANA                    -1.10269327 0.01371 0.05485  0.5760 #> TOGO                     -0.99053008 0.02379 0.09517  0.9993 #> CAMEROON                 -1.13328519 0.01171 0.07025  0.4917 #> NIGERIA                  -1.17261672 0.00951 0.04754  0.3993 #> GABON                    -0.78935857 0.05720 0.17160  1.0000 #> CENTRAL AFRICAN REPUBLIC  1.17349763 0.00946 0.05678  0.3974 #> CHAD                      0.46259185 0.17744 1.00000  1.0000 #> CONGO                    -0.20253005 0.34272 1.00000  1.0000 #> ZAIRE                     2.02270432 2.6e-05 0.00026  0.0011 #> ANGOLA                    1.23450728 0.00677 0.02710  0.2845 #> UGANDA                    3.33600851 1.3e-11 7.6e-11 5.3e-10 #> KENYA                     3.50301896 1.2e-12 7.4e-12 5.1e-11 #> TANZANIA                  1.09843592 0.01401 0.12613  0.5886 #> BURUNDI                   0.77417084 0.06077 0.24308  1.0000 #> RWANDA                    1.45720776 0.00178 0.00891  0.0748 #> SOMALIA                   1.18316273 0.00898 0.02695  0.3773 #> ETHIOPIA                  2.62720027 7.4e-08 3.0e-07 3.1e-06 #> ZAMBIA                    0.75273285 0.06610 0.59492  1.0000 #> ZIMBABWE                 -0.19956472 0.34490 1.00000  1.0000 #> MALAWI                    0.21195283 0.33582 1.00000  1.0000 #> MOZAMBIQUE               -0.28761679 0.28257 1.00000  1.0000 #> SOUTH AFRICA             -0.86814954 0.04126 0.33004  1.0000 #> LESOTHO                  -0.29841469 0.27531 0.55062  1.0000 #> BOTSWANA                  0.04090396 0.46740 1.00000  1.0000 #> SWAZILAND                -0.65938417 0.09362 0.28087  1.0000 #> MOROCCO                   0.02191606 0.48252 1.00000  1.0000 #> ALGERIA                  -0.36307938 0.23387 1.00000  1.0000 #> TUNISIA                   0.57910139 0.12339 0.37017  1.0000 #> LIBYA                     2.55272169 1.7e-07 1.2e-06 6.9e-06 #> SUDAN                     4.03925235 3.3e-16 3.0e-15 1.4e-14 #> EGYPT                     4.42133637 < 2e-16 < 2e-16 < 2e-16"},{"path":"https://r-spatial.github.io/spdep/reference/plot.mst.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the Minimum Spanning Tree — plot.mst","title":"Plot the Minimum Spanning Tree — plot.mst","text":"function plots MST, nodes circles edges   segments.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/plot.mst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the Minimum Spanning Tree — plot.mst","text":"","code":"# S3 method for class 'mst' plot(x, coords, label.areas = NULL,     cex.circles = 1, cex.labels = 1, add=FALSE, ...)"},{"path":"https://r-spatial.github.io/spdep/reference/plot.mst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the Minimum Spanning Tree — plot.mst","text":"x Object mst class. coords two column matrix coordinates nodes. label.areas vector labels nodes cex.circles length circles plot. cex.labels length nodes labels ploted. add default FALSE, create new plot ... arguments passed plotting functions.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/plot.mst.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot the Minimum Spanning Tree — plot.mst","text":"Elias T. Krainski Renato M. Assuncao","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/plot.mst.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the Minimum Spanning Tree — plot.mst","text":"","code":"### see example in mstree function documentation"},{"path":"https://r-spatial.github.io/spdep/reference/plot.nb.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot a neighbours list — plot.nb","title":"Plot a neighbours list — plot.nb","text":"function plot neighbours list given point coordinates represent region two dimensions; plot.listw wrapper passes neighbours component plot.nb.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/plot.nb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot a neighbours list — plot.nb","text":"","code":"# S3 method for class 'nb' plot(x, coords, col=\"black\", points=TRUE, add=FALSE, arrows=FALSE,  length=0.1, xlim=NULL, ylim=NULL, ...) # S3 method for class 'listw' plot(x, coords, col=\"black\", points=TRUE, add=FALSE, arrows=FALSE,  length=0.1, xlim=NULL, ylim=NULL, ...)"},{"path":"https://r-spatial.github.io/spdep/reference/plot.nb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot a neighbours list — plot.nb","text":"x object class nb (plot.listw) class listw coords matrix region point coordinates, Spatial object (points polygons), sfc object (points polygons) col plotting colour points (logical) add points plot add (logical) add existing plot arrows (logical) draw arrowheads asymmetric neighbours length length plot inches arrow heads drawn asymmetric neighbours lists xlim, ylim plot window bounds ... graphical parameters par(..)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/plot.nb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot a neighbours list — plot.nb","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/plot.nb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot a neighbours list — plot.nb","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) plot(col.gal.nb, st_geometry(columbus)) title(main=\"GAL order 1 links with first nearest neighbours in red\", cex.main=0.6)  plot(col.gal.nb, as(columbus, \"Spatial\")) title(main=\"GAL order 1 links with first nearest neighbours in red\", cex.main=0.6) coords <- st_centroid(st_geometry(columbus), of_largest_polygon=TRUE) col.knn <- knearneigh(coords, k=1) plot(knn2nb(col.knn), coords, add=TRUE, col=\"red\", length=0.08) #> Warning: neighbour object has 13 sub-graphs"},{"path":"https://r-spatial.github.io/spdep/reference/plot.skater.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the object of skater class — plot.skater","title":"Plot the object of skater class — plot.skater","text":"function displays results skater function. subgraphs   plotted different colours.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/plot.skater.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the object of skater class — plot.skater","text":"","code":"# S3 method for class 'skater' plot(x, coords, label.areas = NULL,     groups.colors, cex.circles = 1, cex.labels = 1, ...)"},{"path":"https://r-spatial.github.io/spdep/reference/plot.skater.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the object of skater class — plot.skater","text":"x object skater class. coords matrix two colums coordinates nodes. label.areas vector labels nodes. groups.colors vector colors groups ou sub-graphs. cex.circles length circles represent nodes. cex.labels length labels nodes. ... arguments passed plotting funcitons.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/plot.skater.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Plot the object of skater class — plot.skater","text":"Elias T. Krainski Renato M. Assuncao","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/plot.skater.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot the object of skater class — plot.skater","text":"","code":"### see example in the skater function documentation"},{"path":"https://r-spatial.github.io/spdep/reference/poly2nb.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct neighbours list from polygon list — poly2nb","title":"Construct neighbours list from polygon list — poly2nb","text":"function builds neighbours list based regions contiguous boundaries, sharing one boundary point. current function part interpreted may run slowly many regions detailed boundaries, 0.2-16 fail lack memory single polygons built many border coordinates.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/poly2nb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct neighbours list from polygon list — poly2nb","text":"","code":"poly2nb(pl, row.names = NULL, snap=NULL, queen=TRUE, useC=TRUE, foundInBox=NULL)"},{"path":"https://r-spatial.github.io/spdep/reference/poly2nb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct neighbours list from polygon list — poly2nb","text":"pl list polygons class extending SpatialPolygons, sf sfc object containing non-empty (multi-)polygon objects row.names character vector region ids added neighbours list attribute region.id, default seq(1, nrow(x)); pl row.names, used instead default sequence. snap boundary points less snap distance apart considered indicate contiguity; used find candidate actual neighbours planar geometries, actual neighbours spherical geometries, spherical spatial indexing injects fuzzyness. set, SpatialPolygons objects, default sqrt(.Machine$double.eps), value also used sf objects coordinate reference system. sf objects defined coordinate reference system, default value 1e-7 geographical coordinates (approximately 10mm), 10mm projected coordinates metre units, converted 10mm distance units coordinates. conversion fail, snap reverts sqrt(.Machine$double.eps). queen TRUE, single shared boundary point meets contiguity condition, FALSE, one shared point required; note one shared boundary point necessarily mean shared boundary line useC default TRUE, work loop C, may set false revert R code calling two C functions n*k work loop, k average number candidate neighbours foundInBox default NULL using R code st_intersects() generate candidate neighbours (using snap= geometries spherical); NULL (legacy purposes) list length (n-1) integer vectors candidate neighbours (j > ) (created poly_findInBoxGEOS function rgeos clean polygons)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/poly2nb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct neighbours list from polygon list — poly2nb","text":"neighbours list class nb. See card details “nb” objects.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/poly2nb.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Construct neighbours list from polygon list — poly2nb","text":"0.5-8, function includes faster bounding box indexing improvements contributed Micah Altman. cluster provided using set.ClusterOption, used finding candidate bounding box overlaps exact testing contiguity. 1.1-7, sf polygons included start end points, erroneously report queen neighbourhood rook present, see https://github.com/r-spatial/spdep/issues/50. 1.1-9 sf 1.0-0, s2 used bounding box indexing internally pl geographical coordinates. topology engine s2 differs use GEOS planar coordinates sf, output differences may expected. Since treating spherical geometries planar also questionable, clear whether spherical contiguous polygon neighbours simply follow neighbours found treating geometries planar https://github.com/r-spatial/s2/issues/125#issuecomment-864403372. However, current advice necessarily use s2 finding contiguity neighbours, least check output.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/poly2nb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Construct neighbours list from polygon list — poly2nb","text":"Roger Bivand Roger.Bivand@nhh.contributions Micah Altman","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/poly2nb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct neighbours list from polygon list — poly2nb","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) coords <- st_coordinates(st_centroid(st_geometry(columbus))) xx <- poly2nb(as(columbus, \"Spatial\")) dxx <- diffnb(xx, col.gal.nb) #> Warning: neighbour object has 46 sub-graphs plot(st_geometry(columbus), border=\"grey\") plot(col.gal.nb, coords, add=TRUE) plot(dxx, coords, add=TRUE, col=\"red\") title(main=paste(\"Differences (red) in Columbus GAL weights (black)\",  \"and polygon generated queen weights\", sep=\"\\n\"), cex.main=0.6)  # poly2nb with sf sfc_MULTIPOLYGON objects sf_xx <- poly2nb(columbus) diffnb(sf_xx, xx) #> Warning: neighbour object has 49 sub-graphs #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 0  #> Percentage nonzero weights: 0  #> Average number of links: 0  #> 49 regions with no links: #> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, #> 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, #> 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49 #> 49 disjoint connected subgraphs sfc_xx <- poly2nb(st_geometry(columbus)) diffnb(sfc_xx, xx) #> Warning: neighbour object has 49 sub-graphs #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 0  #> Percentage nonzero weights: 0  #> Average number of links: 0  #> 49 regions with no links: #> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, #> 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, #> 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49 #> 49 disjoint connected subgraphs xxx <- poly2nb(as(columbus, \"Spatial\"), queen=FALSE) dxxx <- diffnb(xxx, col.gal.nb) #> Warning: neighbour object has 34 sub-graphs plot(st_geometry(columbus), border = \"grey\") plot(col.gal.nb, coords, add = TRUE) plot(dxxx, coords, add = TRUE, col = \"red\") title(main=paste(\"Differences (red) in Columbus GAL weights (black)\",  \"and polygon generated rook weights\", sep=\"\\n\"), cex.main=0.6)  cards <- card(xx) maxconts <- which(cards == max(cards)) if(length(maxconts) > 1) maxconts <- maxconts[1] fg <- rep(\"grey\", length(cards)) fg[maxconts] <- \"red\" fg[xx[[maxconts]]] <- \"green\" plot(st_geometry(columbus), col=fg) title(main=\"Region with largest number of contiguities\", cex.main=0.6)  nc.sids <- st_read(system.file(\"shapes/sids.gpkg\", package=\"spData\")[1], quiet=TRUE) system.time(xxnb <- poly2nb(nc.sids)) #>    user  system elapsed  #>   0.045   0.000   0.046  system.time(xxnb <- poly2nb(as(nc.sids, \"Spatial\"))) #>    user  system elapsed  #>   0.055   0.000   0.055  plot(st_geometry(nc.sids)) plot(xxnb, st_coordinates(st_centroid(nc.sids)), add=TRUE, col=\"blue\") #> Warning: st_centroid assumes attributes are constant over geometries  sq <- st_polygon(list(rbind(c(0,0), c(1,0), c(1,1), c(0,1), c(0,0)))) sq2 <- sq + c(0,1) sq3 <- sq + c(1,0) sq4 <- sq + c(1,1) gm <- st_sfc(list(sq, sq2, sq3, sq4)) df <- st_as_sf(data.frame(gm, id=1:4)) plot(st_geometry(df)) text(st_coordinates(st_centroid(gm)), as.character(df$id))  unclass(poly2nb(df, queen = FALSE)) #> [[1]] #> [1] 2 3 #>  #> [[2]] #> [1] 1 4 #>  #> [[3]] #> [1] 1 4 #>  #> [[4]] #> [1] 2 3 #>  #> attr(,\"region.id\") #> [1] \"1\" \"2\" \"3\" \"4\" #> attr(,\"call\") #> poly2nb(pl = df, queen = FALSE) #> attr(,\"type\") #> [1] \"rook\" #> attr(,\"snap\") #> [1] 1.490116e-08 #> attr(,\"sym\") #> [1] TRUE #> attr(,\"ncomp\") #> attr(,\"ncomp\")$nc #> [1] 1 #>  #> attr(,\"ncomp\")$comp.id #> [1] 1 1 1 1 #>  col_geoms <- st_geometry(columbus) col_geoms[1] <- st_buffer(col_geoms[1], dist=-0.05) st_geometry(columbus) <- col_geoms poly2nb(columbus) #> Warning: some observations have no neighbours; #> if this seems unexpected, try increasing the snap argument. #> Warning: neighbour object has 2 sub-graphs; #> if this sub-graph count seems unexpected, try increasing the snap argument. #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 232  #> Percentage nonzero weights: 9.662641  #> Average number of links: 4.734694  #> 1 region with no links: #> 1 #> 2 disjoint connected subgraphs"},{"path":"https://r-spatial.github.io/spdep/reference/probmap.html","id":null,"dir":"Reference","previous_headings":"","what":"Probability mapping for rates — probmap","title":"Probability mapping for rates — probmap","text":"function returns data frame rates counts populations risk crude rates, expected counts cases, relative risks, Poisson probabilities.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/probmap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probability mapping for rates — probmap","text":"","code":"probmap(n, x, row.names=NULL, alternative=\"less\")"},{"path":"https://r-spatial.github.io/spdep/reference/probmap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Probability mapping for rates — probmap","text":"n numeric vector counts cases x numeric vector populations risk row.names row names passed output data frame alternative default “less”, may set “greater”","code":""},{"path":"https://r-spatial.github.io/spdep/reference/probmap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Probability mapping for rates — probmap","text":"function returns data frame, rates may mapped class intervals chosen. class intervals used examples mostly taken referenced source.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/probmap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Probability mapping for rates — probmap","text":"raw raw (crude) rates expCount expected counts cases assuming global rate relRisk relative risks: ratio observed expected counts cases multiplied 100 pmap Poisson probability map values: probablility getting “extreme” count actually observed - one-tailed, default alternative observed “less” expected","code":""},{"path":"https://r-spatial.github.io/spdep/reference/probmap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Probability mapping for rates — probmap","text":"Bailey T, Gatrell (1995) Interactive Spatial Data Analysis, Harlow: Longman, pp. 300–303.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/probmap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Probability mapping for rates — probmap","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/probmap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Probability mapping for rates — probmap","text":"","code":"auckland <- st_read(system.file(\"shapes/auckland.gpkg\", package=\"spData\")[1], quiet=TRUE) res <- probmap(auckland$M77_85, 9*auckland$Und5_81) rt <- sum(auckland$M77_85)/sum(9*auckland$Und5_81) ppois_pmap <- numeric(length(auckland$Und5_81)) for (i in seq(along=ppois_pmap)) { ppois_pmap[i] <- poisson.test(auckland$M77_85[i], r=rt,   T=(9*auckland$Und5_81[i]), alternative=\"less\")$p.value all.equal(ppois_pmap, res$pmap) } res$id <- 1:nrow(res) auckland$id <- res$id <- 1:nrow(res) auckland_res <- merge(auckland, res, by=\"id\") plot(auckland_res[, \"raw\"], main=\"Crude (raw) estimates\")  plot(auckland_res[, \"relRisk\"], main=\"Standardised mortality ratios\")  plot(auckland_res[, \"pmap\"], main=\"Poisson probabilities\",  breaks=c(0, 0.05, 0.1, 0.5, 0.9, 0.95, 1))"},{"path":"https://r-spatial.github.io/spdep/reference/prunecost.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute cost of prune each edge — prunecost","title":"Compute cost of prune each edge — prunecost","text":"edge dropped, MST pruned. generate two   subgraphs. , makes tree graphs tree dissimilarity values   computed, one graph. dissimilarity sum   sqared differences observactions nodes mean   vector observations graph. dissimilarity original   graph sum dissimilarity subgraphs returned.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/prunecost.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute cost of prune each edge — prunecost","text":"","code":"prunecost(edges, data, method = c(\"euclidean\", \"maximum\", \"manhattan\",      \"canberra\", \"binary\", \"minkowski\", \"mahalanobis\"),      p = 2, cov, inverted = FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/prunecost.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute cost of prune each edge — prunecost","text":"edges matrix 2 colums row one edge data data.frame observations nodes. method Character function declare distance method.     method character, method must \"mahalanobis\"     \"euclidean\", \"maximum\", \"manhattan\", \"canberra\", \"binary\"     \"minkowisk\".     method one \"euclidean\", \"maximum\",     \"manhattan\", \"canberra\", \"binary\" \"minkowisk\", see     dist details,      function used compute distance.      method=\"mahalanobis\", mahalanobis distance      computed neighbour areas.      method function, function      used compute distance. p power Minkowski distance. cov covariance matrix used compute mahalanobis    distance. inverted logical.  'TRUE', 'cov' supposed contain           inverse covariance matrix.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/prunecost.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute cost of prune each edge — prunecost","text":"vector differences dissimilarity nodes   dissimilarity sum subgraphs obtained pruning one   edge time.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/prunecost.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute cost of prune each edge — prunecost","text":"Elias T. Krainski Renato M. Assuncao","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/prunecost.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute cost of prune each edge — prunecost","text":"","code":"d <- data.frame(a=-2:2, b=runif(5)) e <- matrix(c(1,2, 2,3, 3,4, 4,5), ncol=2, byrow=TRUE)  sum(sweep(d, 2, colMeans(d))^2) #> [1] 10.35574  prunecost(e, d) #> [1] 2.138259 2.875555 2.820048 2.169740"},{"path":"https://r-spatial.github.io/spdep/reference/prunemst.html","id":null,"dir":"Reference","previous_headings":"","what":"Prune a Minimun Spanning Tree — prunemst","title":"Prune a Minimun Spanning Tree — prunemst","text":"function deletes first edge makes two subsets edges.   subset Minimun Spanning Treee.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/prunemst.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prune a Minimun Spanning Tree — prunemst","text":"","code":"prunemst(edges, only.nodes = TRUE)"},{"path":"https://r-spatial.github.io/spdep/reference/prunemst.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prune a Minimun Spanning Tree — prunemst","text":"edges matrix two colums row one edge .nodes .nodes=FALSE, return edges nodes   MST resulted. .nodes=TRUE, return two sets   nodes. Defalt TRUE","code":""},{"path":"https://r-spatial.github.io/spdep/reference/prunemst.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prune a Minimun Spanning Tree — prunemst","text":"list length two. .nodes=TRUE element   vector nodes. .nodes=FALSE element list   nodes edges.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/prunemst.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Prune a Minimun Spanning Tree — prunemst","text":"Elias T. Krainski Renato M. Assuncao","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/prunemst.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prune a Minimun Spanning Tree — prunemst","text":"","code":"e <- matrix(c(2,3, 1,2, 3,4, 4,5), ncol=2, byrow=TRUE) e #>      [,1] [,2] #> [1,]    2    3 #> [2,]    1    2 #> [3,]    3    4 #> [4,]    4    5 prunemst(e) #> $node1 #> [1] 2 1 #>  #> $node2 #> [1] 3 4 5 #>  prunemst(e, only.nodes=FALSE) #> [[1]] #> [[1]]$node #> [1] 2 1 #>  #> [[1]]$edge #>      [,1] [,2] #> [1,]    1    2 #>  #>  #> [[2]] #> [[2]]$node #> [1] 3 4 5 #>  #> [[2]]$edge #>      [,1] [,2] #> [1,]    3    4 #> [2,]    4    5 #>  #>"},{"path":"https://r-spatial.github.io/spdep/reference/read.gal.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a GAL lattice file into a neighbours list — read.gal","title":"Read a GAL lattice file into a neighbours list — read.gal","text":"function read.gal() reads GAL lattice file neighbours list spatial analysis. read old new style (GeoDa) GAL files. function read.geoda helper file reading comma separated value data files, calling read.csv().","code":""},{"path":"https://r-spatial.github.io/spdep/reference/read.gal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a GAL lattice file into a neighbours list — read.gal","text":"","code":"read.gal(file, region.id=NULL, override.id=FALSE) read.geoda(file, row.names=NULL, skip=0)"},{"path":"https://r-spatial.github.io/spdep/reference/read.gal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a GAL lattice file into a neighbours list — read.gal","text":"file name file GAL lattice data region.id region IDs specified order coerse neighbours list order numbering region.id override.id override given (NULL) region.id, collecting region.id numbering order GAL file. row.names row.names read.csv(), typically character string naming column file used skip skip number lines, read.csv()","code":""},{"path":"https://r-spatial.github.io/spdep/reference/read.gal.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read a GAL lattice file into a neighbours list — read.gal","text":"Luc Anselin (2003): Spatial Analysis Laboratory, Department Agricultural Consumer Economics, University Illinois, Urbana-Champaign, now dead link: http://www.csiss.org/gispopsci/workshops/2011/PSU/readings/W15_Anselin2007.pdf; Luc Anselin (2003) GeoDa 0.9 User's Guide, pp. 80–81, Spatial Analysis Laboratory, Department Agricultural Consumer Economics, University Illinois, Urbana-Champaign, http://geodacenter.github.io/docs/geoda093.pdf; GAL - Geographical Algorithms Library, University Newcastle","code":""},{"path":"https://r-spatial.github.io/spdep/reference/read.gal.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a GAL lattice file into a neighbours list — read.gal","text":"function read.gal() returns object class nb list integer vectors containing neighbour region number ids. function read.geoda returns data frame, issues warning returned object one column.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/read.gal.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Read a GAL lattice file into a neighbours list — read.gal","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/read.gal.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Read a GAL lattice file into a neighbours list — read.gal","text":"Example data originally downloaded now dead link: http://sal.agecon.uiuc.edu/weights/zips/us48.zip","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/read.gal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read a GAL lattice file into a neighbours list — read.gal","text":"","code":"us48.fipsno <- read.geoda(system.file(\"etc/weights/us48.txt\",  package=\"spdep\")[1]) us48.q <- read.gal(system.file(\"etc/weights/us48_q.GAL\", package=\"spdep\")[1],  us48.fipsno$Fipsno) us48.r <- read.gal(system.file(\"etc/weights/us48_rk.GAL\", package=\"spdep\")[1],  us48.fipsno$Fipsno) data(state) if (as.numeric(paste(version$major, version$minor, sep=\"\")) < 19) {  m50.48 <- match(us48.fipsno$\"State.name\", state.name) } else {  m50.48 <- match(us48.fipsno$\"State_name\", state.name) } plot(us48.q, as.matrix(as.data.frame(state.center))[m50.48,]) plot(diffnb(us48.r, us48.q),  as.matrix(as.data.frame(state.center))[m50.48,], add=TRUE, col=\"red\") #> Warning: neighbour object has 46 sub-graphs title(main=\"Differences between rook and queen criteria imported neighbours lists\")"},{"path":"https://r-spatial.github.io/spdep/reference/read.gwt2nb.html","id":null,"dir":"Reference","previous_headings":"","what":"Read and write spatial neighbour files — read.gwt2nb","title":"Read and write spatial neighbour files — read.gwt2nb","text":"\"gwt\" functions read write GeoDa GWT files (example file baltk4.GWT downloaded site given reference), \"dat\" functions read write Matlab sparse matrix files used James LeSage's Spatial Econometrics Toolbox (example file wmat.dat downloaded site given reference). body files headers three columns separated white space, third column must numeric locale reading platform (correct decimal separator).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/read.gwt2nb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read and write spatial neighbour files — read.gwt2nb","text":"","code":"read.gwt2nb(file, region.id=NULL) write.sn2gwt(sn, file, shpfile=NULL, ind=NULL, useInd=FALSE, legacy=FALSE) read.dat2listw(file) write.sn2dat(sn, file) read.swmdbf2listw(fn, region.id=NULL, style=NULL, zero.policy=NULL) read_swm_dbf(fn) write.sn2DBF(sn, file)"},{"path":"https://r-spatial.github.io/spdep/reference/read.gwt2nb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read and write spatial neighbour files — read.gwt2nb","text":"file, fn name file weights data region.id character vector region IDs - ArcGIS SWM DBFs, values must character integers (numbers starting zero) sn spatial.neighbour object shpfile character string: given Shapefile name taken GWT file dataset ind character string: region id indicator field name useInd default FALSE, TRUE, write region.id attribute ID key tags output file (use OpenGeoDa depend shapefile field named ind argument matching exported tags) legacy default FALSE; TRUE, header single field number observations style default NULL, missing, set \"M\" warning given; \"M\", passed nb2listw re-build object zero.policy default NULL, use global option value; FALSE stop error empty neighbour sets, TRUE permit weights list formed zero-length weights vectors","code":""},{"path":"https://r-spatial.github.io/spdep/reference/read.gwt2nb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read and write spatial neighbour files — read.gwt2nb","text":"Attempts honour region.id argument given reading GWT SWM/DBF files. region IDs given region.id= match origins destinations GWT file, error warning thrown, considered carefully. read_swm_dbf simplified interface read.swmdbf2listw -neighbour observations present, advised region.id= given read.swmdbf2listw; function read correctly minimum maximum IDs present observations neighbours without region.id= set, reading using read.swmdbf2listw fail minimum maximum ID observations neighbours region.id= given.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/read.gwt2nb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read and write spatial neighbour files — read.gwt2nb","text":"read.gwt2nb returns neighbour \"nb\" object generalised weights stored list element called \"dlist\" \"GeoDa\" attribute; read.swmdbf2listw returns \"listw\" object read DBF file exported ArcGIS SWM object.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/read.gwt2nb.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Read and write spatial neighbour files — read.gwt2nb","text":"Luc Anselin (2003) GeoDa 0.9 User's Guide, pp. 80–81, Spatial Analysis Laboratory, Department Agricultural Consumer Economics, University Illinois, Urbana-Champaign, http://geodacenter.github.io/docs/geoda093.pdf; also material formerly spatial-econometrics.com/data/contents.html","code":""},{"path":"https://r-spatial.github.io/spdep/reference/read.gwt2nb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Read and write spatial neighbour files — read.gwt2nb","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/read.gwt2nb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read and write spatial neighbour files — read.gwt2nb","text":"","code":"data(baltimore, package=\"spData\") STATION <- baltimore$STATION gwt1 <- read.gwt2nb(system.file(\"weights/baltk4.GWT\", package=\"spData\")[1],  STATION) #> Warning: 102, 115, 208 are not destinations cat(paste(\"Neighbours list symmetry;\", is.symmetric.nb(gwt1, FALSE, TRUE),  \"\\n\")) #> Neighbours list symmetry; FALSE  listw1 <- nb2listw(gwt1, style=\"B\", glist=attr(gwt1, \"GeoDa\")$dist) tmpGWT <- tempfile() write.sn2gwt(listw2sn(listw1), tmpGWT) gwt2 <- read.gwt2nb(tmpGWT, STATION) #> Warning: 102, 115, 208 are not destinations cat(paste(\"Neighbours list symmetry;\", is.symmetric.nb(gwt2, FALSE, TRUE),  \"\\n\")) #> Neighbours list symmetry; FALSE  diffnb(gwt1, gwt2) #> Warning: neighbour object has 211 sub-graphs #> Neighbour list object: #> Number of regions: 211  #> Number of nonzero links: 0  #> Percentage nonzero weights: 0  #> Average number of links: 0  #> 211 regions with no links: #> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, #> 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, #> 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, #> 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, #> 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, #> 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, #> 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, #> 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, #> 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, #> 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, #> 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, #> 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, #> 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, #> 206, 207, 208, 209, 210, 211 #> 211 disjoint connected subgraphs data(oldcol) tmpMAT <- tempfile() COL.W <- nb2listw(COL.nb) write.sn2dat(listw2sn(COL.W), tmpMAT) listwmat1 <- read.dat2listw(tmpMAT) #> Warning: style is M (missing); style should be set to a valid value diffnb(listwmat1$neighbours, COL.nb, verbose=TRUE) #> Warning: region.id differ; using ids of first list #> Warning: neighbour object has 49 sub-graphs #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 0  #> Percentage nonzero weights: 0  #> Average number of links: 0  #> 49 regions with no links: #> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, #> 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, #> 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49 #> 49 disjoint connected subgraphs listwmat2 <- read.dat2listw(system.file(\"etc/weights/wmat.dat\",   package=\"spdep\")[1]) #> Warning: style is M (missing); style should be set to a valid value diffnb(listwmat1$neighbours, listwmat2$neighbours, verbose=TRUE) #> Warning: neighbour object has 49 sub-graphs #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 0  #> Percentage nonzero weights: 0  #> Average number of links: 0  #> 49 regions with no links: #> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, #> 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, #> 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49 #> 49 disjoint connected subgraphs if (require(\"foreign\", quietly=TRUE)) { nc_sf <- sf::st_read(system.file(\"gpkg/nc.gpkg\", package=\"sf\")[1]) nc_sf$UniqueID <- 1:nrow(nc_sf) fn <- system.file(\"etc/misc/nc_contiguity_unique_id.dbf\", package=\"spdep\")[1] nc1 <- read.swmdbf2listw(fn, style=\"B\") nc1 nc1a <- read.swmdbf2listw(fn, region.id=as.character(nc_sf$UniqueID),  style=\"B\") all.equal(nc1, nc1a) fn <- system.file(\"etc/misc/nc_contiguity_unique_id_islands.dbf\",  package=\"spdep\")[1] try(nc1i <- read.swmdbf2listw(fn, style=\"B\")) nc1i <- read.swmdbf2listw(fn, style=\"B\", zero.policy=TRUE) nc1ia <- read.swmdbf2listw(fn, region.id=as.character(nc_sf$UniqueID),  style=\"B\", zero.policy=TRUE) nc1ia all.equal(nc1i, nc1ia) (GDAL37 <- as.numeric_version(unname(sf_extSoftVersion()[\"GDAL\"])) >= \"3.7.0\") file <- \"etc/shapes/california.gpkg.zip\" zipfile <- system.file(file, package=\"spdep\") if (GDAL37) {     cal <- st_read(zipfile) } else {     td <- tempdir()     bn <- sub(\".zip\", \"\", basename(file), fixed=TRUE)     target <- unzip(zipfile, files=bn, exdir=td)     cal <- st_read(target) } fn <- system.file(\"etc/misc/contiguity_myid.dbf\", package=\"spdep\")[1] cal1 <- read.swmdbf2listw(fn, style=\"B\") cal1a <- read.swmdbf2listw(fn, region.id=as.character(cal$MYID), style=\"B\") all.equal(cal1, cal1a) fn <- system.file(\"etc/misc/contiguity_unique_id.dbf\", package=\"spdep\")[1] cal2 <- read.swmdbf2listw(fn, style=\"B\") cal2a <- read.swmdbf2listw(fn, region.id=as.character(cal$UniqueID), style=\"B\") all.equal(cal2, cal2a) fn <- system.file(\"etc/misc/contiguity_unique_id_islands.dbf\", package=\"spdep\")[1] try(cal3i <- read.swmdbf2listw(fn, style=\"B\")) cal3i <- read.swmdbf2listw(fn, style=\"B\", zero.policy=TRUE) cal3ia <- read.swmdbf2listw(fn, region.id=as.character(cal$UniqueID), style=\"B\", zero.policy=TRUE) all.equal(cal3i, cal3ia) cal1a_1n_nb <- cal1a$neighbours cal1a_1n_nb <- droplinks(cal1a_1n_nb, drop=c(\"158\", \"180\", \"215\"), sym=TRUE) cal1a_1n <- nb2listw(cal1a_1n_nb, style=\"B\", zero.policy=TRUE) cal1a_1n_sn <- listw2sn(cal1a_1n) file <- tempfile(fileext=\".dbf\") write.sn2DBF(cal1a_1n_sn, file) cal1a_1n_rt <- read.swmdbf2listw(file, region.id=as.character(cal$MYID),  style=\"B\", zero.policy=TRUE) all.equal(cal1a_1n$neighbours, cal1a_1n_rt$neighbours) all.equal(cal1a_1n$weights, cal1a_1n_rt$weights, check.attributes=FALSE) cal1_1n_rt <- read.swmdbf2listw(file, style=\"B\", zero.policy=TRUE) all(isTRUE(all.equal(cal1a_1n$neighbours, cal1_1n_rt$neighbours))) all(isTRUE(all.equal(cal1a_1n$weights, cal1_1n_rt$weights)))  } #> Reading layer `nc.gpkg' from data source `/home/rsb/lib/r_libs/sf/gpkg/nc.gpkg' using driver `GPKG' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 #> Warning: region.id not given, c(MYID, NID) range is 1:100 #> Warning: region.id not given, c(MYID, NID) range is 1:100 #> Warning: 81 is not an origin #> Error in read.swmdbf2listw(fn, style = \"B\") :  #>   Error in sn2listw(df1, style = style, zero.policy = zero.policy) :  #>   no-neighbour observations found, set zero.policy to TRUE #>  #> Warning: region.id not given, c(MYID, NID) range is 1:100 #> Reading layer `california' from data source  #>   `/tmp/RtmpqhccSk/temp_libpath108a2257736002/spdep/etc/shapes/california.gpkg.zip'  #>   using driver `GPKG' #> Simple feature collection with 58 features and 2 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -13847330 ymin: 3810869 xmax: -12704360 ymax: 5132708 #> Projected CRS: World_Mercator #> Warning: region.id not given, c(MYID, NID) range is 158:215 #> Warning: region.id not given, c(MYID, NID) range is 1:58 #> Warning: region.id not given, c(MYID, NID) range is 1:58 #> Warning: 21, 38 are not origins #> Error in read.swmdbf2listw(fn, style = \"B\") :  #>   Error in sn2listw(df1, style = style, zero.policy = zero.policy) :  #>   no-neighbour observations found, set zero.policy to TRUE #>  #> Warning: region.id not given, c(MYID, NID) range is 1:58 #> Warning: some observations have no neighbours #> Warning: neighbour object has 4 sub-graphs #> Warning: neighbour object has 4 sub-graphs #> Warning: region.id not given, c(MYID, NID) range is 159:214 #> Warning: neighbour object has 2 sub-graphs #> [1] FALSE"},{"path":"https://r-spatial.github.io/spdep/reference/rotation.html","id":null,"dir":"Reference","previous_headings":"","what":"Rotate a set of point by a certain angle — Rotation","title":"Rotate a set of point by a certain angle — Rotation","text":"Rotate set XY coordinates angle (radians)","code":""},{"path":"https://r-spatial.github.io/spdep/reference/rotation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rotate a set of point by a certain angle — Rotation","text":"","code":"Rotation(xy, angle)"},{"path":"https://r-spatial.github.io/spdep/reference/rotation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rotate a set of point by a certain angle — Rotation","text":"xy 2-columns matrix data frame containing set X Y coordinates. angle Numeric. scalar giving angle points rotated. angle radians.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/rotation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rotate a set of point by a certain angle — Rotation","text":"2-columns matrix size xy giving rotated coordinates.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/rotation.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Rotate a set of point by a certain angle — Rotation","text":"F. Guillaume Blanchet","code":""},{"path":"https://r-spatial.github.io/spdep/reference/rotation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rotate a set of point by a certain angle — Rotation","text":"","code":"set.seed(1) ### Create a set of coordinates coords <- cbind(runif(20), runif(20))  ### Create a series of angles rad <- seq(0, pi, l=20)  opar <- par(mfrow=c(5,4), mar=c(3,3,1,1)) for(i in rad){   coords.rot <- Rotation(coords, i)   plot(coords.rot, xlab=\"\", ylab=\"\") }  par(opar)  ### Rotate the coordinates by an angle of 90 degrees coords.90 <- Rotation(coords, 90*pi/180) coords.90 #>              [,1]       [,2] #>  [1,] -0.93470523 0.26550866 #>  [2,] -0.21214252 0.37212390 #>  [3,] -0.65167377 0.57285336 #>  [4,] -0.12555510 0.90820779 #>  [5,] -0.26722067 0.20168193 #>  [6,] -0.38611409 0.89838968 #>  [7,] -0.01339033 0.94467527 #>  [8,] -0.38238796 0.66079779 #>  [9,] -0.86969085 0.62911404 #> [10,] -0.34034900 0.06178627 #> [11,] -0.48208012 0.20597457 #> [12,] -0.59956583 0.17655675 #> [13,] -0.49354131 0.68702285 #> [14,] -0.18621760 0.38410372 #> [15,] -0.82737332 0.76984142 #> [16,] -0.66846674 0.49769924 #> [17,] -0.79423986 0.71761851 #> [18,] -0.10794363 0.99190609 #> [19,] -0.72371095 0.38003518 #> [20,] -0.41127443 0.77744522  plot(coords, xlim=range(rbind(coords.90,coords)[,1]),  ylim=range(rbind(coords.90,coords)[,2]), asp=1) points(coords.90, pch=19)"},{"path":"https://r-spatial.github.io/spdep/reference/set.mcOption.html","id":null,"dir":"Reference","previous_headings":"","what":"Options for parallel support — set.mcOption","title":"Options for parallel support — set.mcOption","text":"Provides support use parallel computation parallel package.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/set.mcOption.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Options for parallel support — set.mcOption","text":"","code":"set.mcOption(value) get.mcOption() set.coresOption(value) get.coresOption() set.ClusterOption(cl) get.ClusterOption()"},{"path":"https://r-spatial.github.io/spdep/reference/set.mcOption.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Options for parallel support — set.mcOption","text":"value valid replacement value cl cluster object created makeCluster parallel","code":""},{"path":"https://r-spatial.github.io/spdep/reference/set.mcOption.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Options for parallel support — set.mcOption","text":"Options spdep package held environment local package namespace exported. Option values set retrieved pairs access functions, get set. mc option set default FALSE Windows systems, fork R session; default TRUE systems, may set FALSE. mc FALSE, Cluster option used: mc FALSE Cluster option NULL parallel computing done, Cluster option passed “cluster” object created parallel snow package access without passed argument. cores option set NULL default, can used store number cores use integer. cores NULL, facilities parallel package used.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/set.mcOption.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Options for parallel support — set.mcOption","text":"option access functions return current settings, assignment functions usually return previous value option.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/set.mcOption.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Options for parallel support — set.mcOption","text":"extended example shown documentation aple.mc, including treatment seeding RNG multicore/cluster.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/set.mcOption.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Options for parallel support — set.mcOption","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/set.mcOption.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Options for parallel support — set.mcOption","text":"","code":"ls(envir=spdep:::.spdepOptions) #>  [1] \"cluster\"                \"cores\"                  \"listw_is_CsparseMatrix\" #>  [4] \"mc\"                     \"nb_subgraphs_N+E\"       \"report_nb_noneighs\"     #>  [7] \"report_nb_subgraphs\"    \"rlecuyerSeed\"           \"spChkID\"                #> [10] \"verbose\"                \"zeroPolicy\"             if (require(parallel, quietly=TRUE)) {  nc <- max(2L, detectCores(logical=FALSE), na.rm = TRUE)-1L  nc # set nc to 1L here  if (nc > 1L) nc <- 1L #nc <- ifelse(nc > 2L, 2L, nc)  coresOpt <- get.coresOption()  coresOpt  if (!is.na(nc)) {   invisible(set.coresOption(nc))   print(exists(\"moran.mc\"))   if(.Platform$OS.type == \"windows\") { # forking not permitted on Windows - start cluster    print(get.mcOption())    cl <- makeCluster(get.coresOption())    print(clusterEvalQ(cl, exists(\"moran.mc\")))    set.ClusterOption(cl)    clusterEvalQ(get.ClusterOption(), library(spdep))    print(clusterEvalQ(cl, exists(\"moran.mc\")))    clusterEvalQ(get.ClusterOption(), detach(package:spdep))    set.ClusterOption(NULL)    print(clusterEvalQ(cl, exists(\"moran.mc\")))    stopCluster(cl)   } else {    mcOpt <- get.mcOption()    print(mcOpt)    print(mclapply(1:get.coresOption(), function(i) exists(\"moran.mc\"),     mc.cores=get.coresOption()))    invisible(set.mcOption(FALSE))    cl <- makeCluster(nc)    print(clusterEvalQ(cl, exists(\"moran.mc\")))    set.ClusterOption(cl)    clusterEvalQ(get.ClusterOption(), library(spdep))    print(clusterEvalQ(cl, exists(\"moran.mc\")))    clusterEvalQ(get.ClusterOption(), detach(package:spdep))    set.ClusterOption(NULL)    print(clusterEvalQ(cl, exists(\"moran.mc\")))    stopCluster(cl)    invisible(set.mcOption(mcOpt))   }   invisible(set.coresOption(coresOpt))  } } #> [1] TRUE #> [1] TRUE #> [[1]] #> [1] TRUE #>  #> [[1]] #> [1] FALSE #>  #> [[1]] #> [1] TRUE #>  #> [[1]] #> [1] FALSE #>"},{"path":"https://r-spatial.github.io/spdep/reference/set.spChkOption.html","id":null,"dir":"Reference","previous_headings":"","what":"Control checking of spatial object IDs — set.spChkOption","title":"Control checking of spatial object IDs — set.spChkOption","text":"Provides support checking mutual integrity spatial neighbour weights spatial data; similar mechanisms used passing global verbose zero.policy options, causing functions creating neighbour objects warn multiple subgraphs.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/set.spChkOption.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Control checking of spatial object IDs — set.spChkOption","text":"","code":"set.spChkOption(check) get.spChkOption() chkIDs(x, listw) spNamedVec(var, data) set.VerboseOption(check) get.VerboseOption() set.ZeroPolicyOption(check) get.ZeroPolicyOption() set.SubgraphOption(check) get.SubgraphOption() set.SubgraphCeiling(value) get.SubgraphCeiling() set.NoNeighbourOption(check) get.NoNeighbourOption() set.listw_is_CsparseMatrix_Option(check) get.listw_is_CsparseMatrix_Option()"},{"path":"https://r-spatial.github.io/spdep/reference/set.spChkOption.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Control checking of spatial object IDs — set.spChkOption","text":"check logical value, TRUE FALSE value integer value, initialised 100000L, sum numbers nodes edges neighbour graph x vector length, two-dimensional array, data frame number rows neighbours list listw listw listw object nb object inheriting \"nb\" var character string integer value column selected data two-dimensional array data frame containing var","code":""},{"path":"https://r-spatial.github.io/spdep/reference/set.spChkOption.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Control checking of spatial object IDs — set.spChkOption","text":"Analysis functions spChk argument default set NULL, call get.spChkOption() get global spatial option whether check — initialised FALSE, consequently break anything. can changed TRUE using set.spChkOption(TRUE), spChk argument can assigned analysis functions. spNamedVec() provided ensure rownames passed single columns taken two-dimensional arrays data frames.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/set.spChkOption.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Control checking of spatial object IDs — set.spChkOption","text":"set.spChkOption() returns old logical value, get.spChkOption() returns current logical value, chkIDs() returns logical value test lack difference. spNamedVec() returns selected column names set row names object extracted.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/set.spChkOption.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Control checking of spatial object IDs — set.spChkOption","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/set.spChkOption.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Control checking of spatial object IDs — set.spChkOption","text":"motivation mechanism provided observation spatial objects map attribute data values need linked uniquely, avoid spurious results. reordering legacy Columbus data set used earlier publications available download Spacestat website just one example common problem.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/set.spChkOption.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Control checking of spatial object IDs — set.spChkOption","text":"","code":"data(oldcol) rownames(COL.OLD) #>  [1] \"1001\" \"1002\" \"1003\" \"1004\" \"1005\" \"1006\" \"1007\" \"1008\" \"1009\" \"1010\" #> [11] \"1011\" \"1012\" \"1013\" \"1014\" \"1015\" \"1016\" \"1017\" \"1018\" \"1019\" \"1020\" #> [21] \"1021\" \"1022\" \"1023\" \"1024\" \"1025\" \"1026\" \"1027\" \"1028\" \"1029\" \"1030\" #> [31] \"1031\" \"1032\" \"1033\" \"1034\" \"1035\" \"1036\" \"1037\" \"1038\" \"1039\" \"1040\" #> [41] \"1041\" \"1042\" \"1043\" \"1044\" \"1045\" \"1046\" \"1047\" \"1048\" \"1049\" data(columbus, package=\"spData\") rownames(columbus) #>  [1] \"1005\" \"1001\" \"1006\" \"1002\" \"1007\" \"1008\" \"1004\" \"1003\" \"1018\" \"1010\" #> [11] \"1038\" \"1037\" \"1039\" \"1040\" \"1009\" \"1036\" \"1011\" \"1042\" \"1041\" \"1017\" #> [21] \"1043\" \"1019\" \"1012\" \"1035\" \"1032\" \"1020\" \"1021\" \"1031\" \"1033\" \"1034\" #> [31] \"1045\" \"1013\" \"1022\" \"1044\" \"1023\" \"1046\" \"1030\" \"1024\" \"1047\" \"1016\" #> [41] \"1014\" \"1049\" \"1029\" \"1025\" \"1028\" \"1048\" \"1015\" \"1027\" \"1026\" get.spChkOption() #> [1] FALSE oldChk <- set.spChkOption(TRUE) get.spChkOption() #> [1] TRUE chkIDs(COL.OLD, nb2listw(COL.nb)) #> [1] TRUE chkIDs(columbus, nb2listw(col.gal.nb)) #> [1] TRUE chkIDs(columbus, nb2listw(COL.nb)) #> [1] FALSE tmp <- try(moran.test(spNamedVec(\"CRIME\", COL.OLD), nb2listw(COL.nb))) print(tmp) #>  #> \tMoran I test under randomisation #>  #> data:  spNamedVec(\"CRIME\", COL.OLD)   #> weights: nb2listw(COL.nb)     #>  #> Moran I statistic standard deviate = 5.6341, p-value = 8.797e-09 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.510951264      -0.020833333       0.008908762  #>  tmp <- try(moran.test(spNamedVec(\"CRIME\", columbus), nb2listw(col.gal.nb))) print(tmp) #>  #> \tMoran I test under randomisation #>  #> data:  spNamedVec(\"CRIME\", columbus)   #> weights: nb2listw(col.gal.nb)     #>  #> Moran I statistic standard deviate = 5.3427, p-value = 4.578e-08 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.485770914      -0.020833333       0.008991121  #>  tmp <- try(moran.test(spNamedVec(\"CRIME\", columbus), nb2listw(COL.nb))) #> Error in moran.test(spNamedVec(\"CRIME\", columbus), nb2listw(COL.nb)) :  #>   Check of data and weights ID integrity failed print(tmp) #> [1] \"Error in moran.test(spNamedVec(\\\"CRIME\\\", columbus), nb2listw(COL.nb)) : \\n  Check of data and weights ID integrity failed\\n\" #> attr(,\"class\") #> [1] \"try-error\" #> attr(,\"condition\") #> <simpleError in moran.test(spNamedVec(\"CRIME\", columbus), nb2listw(COL.nb)): Check of data and weights ID integrity failed> set.spChkOption(FALSE) get.spChkOption() #> [1] FALSE moran.test(spNamedVec(\"CRIME\", columbus), nb2listw(COL.nb)) #>  #> \tMoran I test under randomisation #>  #> data:  spNamedVec(\"CRIME\", columbus)   #> weights: nb2listw(COL.nb)     #>  #> Moran I statistic standard deviate = 3.8402, p-value = 6.147e-05 #> alternative hypothesis: greater #> sample estimates: #> Moran I statistic       Expectation          Variance  #>       0.341628707      -0.020833333       0.008908762  #>  tmp <- try(moran.test(spNamedVec(\"CRIME\", columbus), nb2listw(COL.nb),  spChk=TRUE), silent=TRUE) print(tmp) #> [1] \"Error in moran.test(spNamedVec(\\\"CRIME\\\", columbus), nb2listw(COL.nb), spChk = TRUE) : \\n  Check of data and weights ID integrity failed\\n\" #> attr(,\"class\") #> [1] \"try-error\" #> attr(,\"condition\") #> <simpleError in moran.test(spNamedVec(\"CRIME\", columbus), nb2listw(COL.nb), spChk = TRUE): Check of data and weights ID integrity failed> set.spChkOption(oldChk) get.spChkOption() #> [1] FALSE"},{"path":"https://r-spatial.github.io/spdep/reference/skater.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial 'K'luster Analysis by Tree Edge Removal — skater","title":"Spatial 'K'luster Analysis by Tree Edge Removal — skater","text":"function implements SKATER procedure spatial clustering   analysis. procedure essentialy begins edges set, data set   number cuts. output object 'skater' class   valid input .","code":""},{"path":"https://r-spatial.github.io/spdep/reference/skater.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial 'K'luster Analysis by Tree Edge Removal — skater","text":"","code":"skater(edges, data, ncuts, crit, vec.crit, method = c(\"euclidean\",      \"maximum\", \"manhattan\", \"canberra\", \"binary\", \"minkowski\",      \"mahalanobis\"), p = 2, cov, inverted = FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/skater.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial 'K'luster Analysis by Tree Edge Removal — skater","text":"edges matrix 2 colums row edge data data.frame data observed nodes. ncuts number cuts crit scalar two dimensional vector     criteria groups. Examples: limits group size     limits population size. scalar, minimum     criteria groups. vec.crit vector evaluating criteria. method Character function declare distance method.     method character, method must \"mahalanobis\"     \"euclidean\", \"maximum\", \"manhattan\", \"canberra\", \"binary\"     \"minkowisk\".     method one \"euclidean\", \"maximum\",     \"manhattan\", \"canberra\", \"binary\" \"minkowski\", see     dist details,      function used compute distance.      method=\"mahalanobis\", mahalanobis distance      computed neighbour areas.      method function, function      used compute distance. p power Minkowski distance. cov covariance matrix used compute mahalanobis    distance. inverted logical.  'TRUE', 'cov' supposed contain           inverse covariance matrix.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/skater.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial 'K'luster Analysis by Tree Edge Removal — skater","text":"object skater class :  groups vector length equal number nodes.     position identifies group node edges.groups list length equal number groups     element set edges .prune vector identifying groups     candidates partition. candidates vector identifying groups candidates     partition. ssto total dissimilarity step edge removal.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/skater.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spatial 'K'luster Analysis by Tree Edge Removal — skater","text":"Assuncao, R.M., Lage J.P., Reis, E.. (2002). Analise de   conglomerados espaciais via arvore geradora minima. Revista Brasileira   de Estatistica, 62, 1-23. Assuncao, R. M, Neves, M. C., Camara, G. Freitas, C. da   C. (2006). Efficient regionalization techniques socio-economic   geographical units using minimum spanning trees. International Journal   Geographical Information Science Vol. 20, . 7, August 2006,   797-811","code":""},{"path":"https://r-spatial.github.io/spdep/reference/skater.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial 'K'luster Analysis by Tree Edge Removal — skater","text":"Renato M. Assuncao Elias T. Krainski","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/skater.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial 'K'luster Analysis by Tree Edge Removal — skater","text":"","code":"### loading data (GDAL37 <- as.numeric_version(unname(sf_extSoftVersion()[\"GDAL\"])) >= \"3.7.0\") #> [1] TRUE file <- \"etc/shapes/bhicv.gpkg.zip\" zipfile <- system.file(file, package=\"spdep\") if (GDAL37) {     bh <- st_read(zipfile) } else {     td <- tempdir()     bn <- sub(\".zip\", \"\", basename(file), fixed=TRUE)     target <- unzip(zipfile, files=bn, exdir=td)     bh <- st_read(target) } #> Reading layer `bhicv' from data source  #>   `/tmp/RtmpSUekmE/temp_libpath10a50471772c0b/spdep/etc/shapes/bhicv.gpkg.zip'  #>   using driver `GPKG' #> Simple feature collection with 98 features and 8 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: -45.02175 ymin: -20.93007 xmax: -42.50321 ymax: -18.08342 #> Geodetic CRS:  Corrego Alegre 1970-72 ### data standardized  dim(bh) #> [1] 98  9 dpad <- data.frame(scale(as.data.frame(bh)[,5:8]))  ### neighboorhod list bh.nb <- poly2nb(bh) bh.nb #> Neighbour list object: #> Number of regions: 98  #> Number of nonzero links: 508  #> Percentage nonzero weights: 5.289463  #> Average number of links: 5.183673   ### calculating costs lcosts <- nbcosts(bh.nb, dpad) head(lcosts) #> [[1]] #>  [1] 1.5418355 2.5253558 1.4738620 1.8462822 1.7089412 1.5613667 1.0279919 #>  [8] 0.6334314 1.9029531 2.5816759 #>  #> [[2]] #> [1] 1.0847913 1.7723275 0.7940341 #>  #> [[3]] #> [1] 1.257984 2.634043 0.847224 1.807124 #>  #> [[4]] #> [1] 1.2579836 1.0548805 0.7862035 #>  #> [[5]] #> [1] 1.541835 1.295112 2.206320 #>  #> [[6]] #> [1] 0.9981915 1.3801441 1.5225548 1.3606678 0.9775650 #>   ### making listw nb.w <- nb2listw(bh.nb, lcosts, style=\"B\") nb.w #> Characteristics of weights list object: #> Neighbour list object: #> Number of regions: 98  #> Number of nonzero links: 508  #> Percentage nonzero weights: 5.289463  #> Average number of links: 5.183673  #>  #> Weights style: B  #> Weights constants summary: #>    n   nn       S0       S1       S2 #> B 98 9604 1027.424 5192.868 55983.97  ### find a minimum spanning tree mst.bh <- mstree(nb.w,5) str(mst.bh) #>  'mst' num [1:97, 1:3] 5 12 13 13 11 31 39 40 31 40 ...  ### the mstree plot par(mar=c(0,0,0,0)) plot(st_geometry(bh), border=gray(.5)) pts <- st_coordinates(st_centroid(bh)) #> Warning: st_centroid assumes attributes are constant over geometries plot(mst.bh, pts, col=2,       cex.lab=.6, cex.circles=0.035, fg=\"blue\", add=TRUE)  ### three groups with no restriction res1 <- skater(mst.bh[,1:2], dpad, 2)  ### groups size table(res1$groups) #>  #>  1  2  3  #> 18 23 57   ### the skater plot opar <- par(mar=c(0,0,0,0)) plot(res1, pts, cex.circles=0.035, cex.lab=.7)   ### the skater plot, using other colors plot(res1, pts, cex.circles=0.035, cex.lab=.7,      groups.colors=heat.colors(length(res1$ed)))   ### the Spatial Polygons plot plot(st_geometry(bh), col=heat.colors(length(res1$edg))[res1$groups])   #par(opar) ### EXPERT OPTIONS  ### more one partition res1b <- skater(res1, dpad, 1)  ### length groups frequency table(res1$groups) #>  #>  1  2  3  #> 18 23 57   table(res1b$groups) #>  #>  1  2  3  4  #> 18 23 55  2   ### thee groups with minimum population  res2 <- skater(mst.bh[,1:2], dpad, 2, 200000, bh$Pop) table(res2$groups) #>  #>  1  2  3  #> 22 37 39   ### thee groups with minimun number of areas res3 <- skater(mst.bh[,1:2], dpad, 2, 3, rep(1,nrow(bh))) table(res3$groups) #>  #>  1  2  3  #> 18 23 57   ### thee groups with minimun and maximun number of areas res4 <- skater(mst.bh[,1:2], dpad, 2, c(20,50), rep(1,nrow(bh))) table(res4$groups) #>  #>  1  2  3  #> 50 24 24   ### if I want to get groups with 20 to 40 elements res5 <- skater(mst.bh[,1:2], dpad, 2,    c(20,40), rep(1,nrow(bh))) ## DON'T MAKE DIVISIONS  table(res5$groups) #>  #>  1  #> 98   ### In this MST don't have groups with this restrictions ### In this case, first I do one division ### with the minimun criteria res5a <- skater(mst.bh[,1:2], dpad, 1, 20, rep(1,nrow(bh)))  table(res5a$groups) #>  #>  1  2  #> 75 23   ### and do more one division with the full criteria res5b <- skater(res5a, dpad, 1, c(20, 40), rep(1,nrow(bh))) table(res5b$groups) #>  #>  1  2  3  #> 22 23 53   ### and do more one division with the full criteria res5c <- skater(res5b, dpad, 1, c(20, 40), rep(1,nrow(bh))) table(res5c$groups) #>  #>  1  2  3  4  #> 22 23 33 20   ### It don't have another divison with this criteria res5d <- skater(res5c, dpad, 1, c(20, 40), rep(1,nrow(bh))) table(res5d$groups) #>  #>  1  2  3  4  #> 22 23 33 20   # \\dontrun{ data(boston, package=\"spData\") bh.nb <- boston.soi dpad <- data.frame(scale(boston.c[,c(7:10)])) ### calculating costs system.time(lcosts <- nbcosts(bh.nb, dpad)) #>    user  system elapsed  #>   0.045   0.000   0.045  ### making listw nb.w <- nb2listw(bh.nb, lcosts, style=\"B\") ### find a minimum spanning tree mst.bh <- mstree(nb.w,5) ### three groups with no restriction system.time(res1 <- skater(mst.bh[,1:2], dpad, 2)) #>    user  system elapsed  #>   2.044   0.253   2.309  library(parallel) nc <- max(2L, detectCores(logical=FALSE), na.rm = TRUE)-1L # set nc to 1L here if (nc > 1L) nc <- 1L coresOpt <- get.coresOption() invisible(set.coresOption(nc)) if(!get.mcOption()) { # no-op, \"snow\" parallel calculation not available   cl <- makeCluster(get.coresOption())   set.ClusterOption(cl) } ### calculating costs system.time(plcosts <- nbcosts(bh.nb, dpad)) #>    user  system elapsed  #>   0.045   0.000   0.045  all.equal(lcosts, plcosts, check.attributes=FALSE) #> [1] TRUE ### making listw pnb.w <- nb2listw(bh.nb, plcosts, style=\"B\") ### find a minimum spanning tree pmst.bh <- mstree(pnb.w,5) ### three groups with no restriction system.time(pres1 <- skater(pmst.bh[,1:2], dpad, 2)) #>    user  system elapsed  #>   2.134   0.285   2.430  if(!get.mcOption()) {   set.ClusterOption(NULL)   stopCluster(cl) } all.equal(res1, pres1, check.attributes=FALSE) #> [1] TRUE invisible(set.coresOption(coresOpt)) # }"},{"path":"https://r-spatial.github.io/spdep/reference/sp.correlogram.html","id":null,"dir":"Reference","previous_headings":"","what":"Spatial correlogram — sp.correlogram","title":"Spatial correlogram — sp.correlogram","text":"Spatial correlograms Moran's autocorrelation coefficient, print plot helper functions.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/sp.correlogram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spatial correlogram — sp.correlogram","text":"","code":"sp.correlogram(neighbours, var, order = 1, method = \"corr\",  style = \"W\", randomisation = TRUE, zero.policy = NULL, spChk=NULL) # S3 method for class 'spcor' plot(x, main, ylab, ylim, ...) # S3 method for class 'spcor' print(x, p.adj.method=\"none\", ...)"},{"path":"https://r-spatial.github.io/spdep/reference/sp.correlogram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spatial correlogram — sp.correlogram","text":"neighbours object class nb var numeric vector order maximum lag order method \"corr\" correlation, \"\" Moran's , \"C\" Geary's C style style can take values W, B, C, S randomisation variance C calculated assumption randomisation, FALSE normality zero.policy default NULL, use global option value; FALSE stop error empty neighbour sets, TRUE permit weights list formed zero-length weights vectors spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() x object sp.correlogram() class spcor p.adj.method correction method p.adjust main overall title plot ylab title y axis ylim y limits plot ... arguments passed ","code":""},{"path":"https://r-spatial.github.io/spdep/reference/sp.correlogram.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Spatial correlogram — sp.correlogram","text":"print function also calculates standard deviates Moran's Geary's C two-sided probability value, optionally using p.adjust correct nymber lags. plot function plots bar estimated Moran's , Geary's C value +/- twice square root variance (previous releases , twice). table includes count included observations brackets lag order. Care needs shown interpreting results remaining included observations lag order increases.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/sp.correlogram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spatial correlogram — sp.correlogram","text":"returns list class spcor: res \"corr\" vector values; \"\", matrix estimates \"\", expectations, variances method \"\" \"corr\" cardnos list tables neighbour cardinalities lag orders used var variable name","code":""},{"path":"https://r-spatial.github.io/spdep/reference/sp.correlogram.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spatial correlogram — sp.correlogram","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, pp. 118–122, Martin, R. L., Oeppen, J. E. 1975 identification regional forecasting models using space-time correlation functions, Transactions Institute British Geographers, 66, 95–118.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/sp.correlogram.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Spatial correlogram — sp.correlogram","text":"Roger Bivand, Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/sp.correlogram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spatial correlogram — sp.correlogram","text":"","code":"nc.sids <- st_read(system.file(\"shapes/sids.gpkg\", package=\"spData\")[1], quiet=TRUE) rn <- as.character(nc.sids$FIPS) ncCC89_nb <- read.gal(system.file(\"weights/ncCC89.gal\", package=\"spData\")[1],  region.id=rn) #> Warning: neighbour object has 3 sub-graphs ft.SID74 <- sqrt(1000)*(sqrt(nc.sids$SID74/nc.sids$BIR74) +   sqrt((nc.sids$SID74+1)/nc.sids$BIR74)) tr.SIDS74 <- ft.SID74*sqrt(nc.sids$BIR74) cspc <- sp.correlogram(ncCC89_nb, tr.SIDS74, order=8, method=\"corr\",  zero.policy=TRUE) #> Warning: lag 1 neighbour object has 3 sub-graphs #> Warning: lag 2 neighbour object has 3 sub-graphs #> Warning: lag 3 neighbour object has 3 sub-graphs #> Warning: lag 4 neighbour object has 3 sub-graphs #> Warning: lag 5 neighbour object has 3 sub-graphs #> Warning: lag 6 neighbour object has 3 sub-graphs #> Warning: lag 7 neighbour object has 3 sub-graphs #> Warning: lag 8 neighbour object has 3 sub-graphs print(cspc) #> Spatial correlogram for tr.SIDS74  #> method: Spatial autocorrelation #>           1           2           3           4           5           6  #>  0.38193491  0.47679881  0.11740653  0.09935901  0.27819159  0.30153012  #>           7           8  #> -0.05150923  0.05283813  plot(cspc)  Ispc <- sp.correlogram(ncCC89_nb, tr.SIDS74, order=8, method=\"I\",  zero.policy=TRUE) #> Warning: lag 1 neighbour object has 3 sub-graphs #> Warning: lag 2 neighbour object has 3 sub-graphs #> Warning: lag 3 neighbour object has 3 sub-graphs #> Warning: lag 4 neighbour object has 3 sub-graphs #> Warning: lag 5 neighbour object has 3 sub-graphs #> Warning: lag 6 neighbour object has 3 sub-graphs #> Warning: lag 7 neighbour object has 3 sub-graphs #> Warning: lag 8 neighbour object has 3 sub-graphs print(Ispc) #> Spatial correlogram for tr.SIDS74  #> method: Moran's I #>          estimate expectation   variance standard deviate Pr(I) two sided     #> 1 (98)  0.2311685  -0.0103093  0.0055378           3.2450       0.0011747 **  #> 2 (98)  0.2246930  -0.0103093  0.0037817           3.8214       0.0001327 *** #> 3 (98)  0.0193576  -0.0103093  0.0029386           0.5473       0.5841914     #> 4 (98)  0.0042255  -0.0103093  0.0024974           0.2908       0.7711687     #> 5 (98)  0.0875548  -0.0103093  0.0022875           2.0462       0.0407386 *   #> 6 (98)  0.0758362  -0.0103093  0.0021583           1.8543       0.0637011 .   #> 7 (98) -0.0752243  -0.0103093  0.0022282          -1.3752       0.1690654     #> 8 (98) -0.0261063  -0.0103093  0.0025211          -0.3146       0.7530514     #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 print(Ispc, \"bonferroni\") #> Spatial correlogram for tr.SIDS74  #> method: Moran's I #>          estimate expectation   variance standard deviate Pr(I) two sided    #> 1 (98)  0.2311685  -0.0103093  0.0055378           3.2450        0.009397 ** #> 2 (98)  0.2246930  -0.0103093  0.0037817           3.8214        0.001061 ** #> 3 (98)  0.0193576  -0.0103093  0.0029386           0.5473        1.000000    #> 4 (98)  0.0042255  -0.0103093  0.0024974           0.2908        1.000000    #> 5 (98)  0.0875548  -0.0103093  0.0022875           2.0462        0.325909    #> 6 (98)  0.0758362  -0.0103093  0.0021583           1.8543        0.509609    #> 7 (98) -0.0752243  -0.0103093  0.0022282          -1.3752        1.000000    #> 8 (98) -0.0261063  -0.0103093  0.0025211          -0.3146        1.000000    #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 plot(Ispc)  Cspc <- sp.correlogram(ncCC89_nb, tr.SIDS74, order=8, method=\"C\",  zero.policy=TRUE) #> Warning: lag 1 neighbour object has 3 sub-graphs #> Warning: lag 2 neighbour object has 3 sub-graphs #> Warning: lag 3 neighbour object has 3 sub-graphs #> Warning: lag 4 neighbour object has 3 sub-graphs #> Warning: lag 5 neighbour object has 3 sub-graphs #> Warning: lag 6 neighbour object has 3 sub-graphs #> Warning: lag 7 neighbour object has 3 sub-graphs #> Warning: lag 8 neighbour object has 3 sub-graphs print(Cspc) #> Spatial correlogram for tr.SIDS74  #> method: Geary's C #>         estimate expectation  variance standard deviate Pr(I) two sided     #> 1 (98) 0.7172624   1.0000000 0.0059986          -3.6506       0.0002617 *** #> 2 (98) 0.6817819   1.0000000 0.0046785          -4.6523       3.282e-06 *** #> 3 (98) 0.9470179   1.0000000 0.0044311          -0.7959       0.4260762     #> 4 (98) 1.0016202   1.0000000 0.0041985           0.0250       0.9800516     #> 5 (98) 0.8977501   1.0000000 0.0038054          -1.6575       0.0974119 .   #> 6 (98) 0.9173310   1.0000000 0.0036428          -1.3697       0.1707819     #> 7 (98) 1.0527148   1.0000000 0.0037227           0.8640       0.3875979     #> 8 (98) 1.0067939   1.0000000 0.0036482           0.1125       0.9104415     #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 print(Cspc, \"bonferroni\") #> Spatial correlogram for tr.SIDS74  #> method: Geary's C #>         estimate expectation  variance standard deviate Pr(I) two sided     #> 1 (98) 0.7172624   1.0000000 0.0059986          -3.6506        0.002093 **  #> 2 (98) 0.6817819   1.0000000 0.0046785          -4.6523       2.626e-05 *** #> 3 (98) 0.9470179   1.0000000 0.0044311          -0.7959        1.000000     #> 4 (98) 1.0016202   1.0000000 0.0041985           0.0250        1.000000     #> 5 (98) 0.8977501   1.0000000 0.0038054          -1.6575        0.779295     #> 6 (98) 0.9173310   1.0000000 0.0036428          -1.3697        1.000000     #> 7 (98) 1.0527148   1.0000000 0.0037227           0.8640        1.000000     #> 8 (98) 1.0067939   1.0000000 0.0036482           0.1125        1.000000     #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 plot(Cspc)  drop.no.neighs <- !(1:length(ncCC89_nb) %in% which(card(ncCC89_nb) == 0)) sub.ncCC89.nb <- subset(ncCC89_nb, drop.no.neighs) plot(sp.correlogram(sub.ncCC89.nb, subset(tr.SIDS74,  drop.no.neighs),  order=8, method=\"corr\"))"},{"path":"https://r-spatial.github.io/spdep/reference/sp.mantel.mc.html","id":null,"dir":"Reference","previous_headings":"","what":"Mantel-Hubert spatial general cross product statistic — sp.mantel.mc","title":"Mantel-Hubert spatial general cross product statistic — sp.mantel.mc","text":"permutation test spatial general cross product statistic Moran (\\(C_{ij} = z_i z_j\\)), Geary (\\(C_{ij} = (z_i - z_j)^2\\)), Sokal (\\(C_{ij} = |z_i - z_j|\\)) criteria, \\(z_i = (x_i - \\bar{x}) / \\sigma_{x}\\). plot.mc.sim helper function plot outcomes permutation test.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/sp.mantel.mc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mantel-Hubert spatial general cross product statistic — sp.mantel.mc","text":"","code":"sp.mantel.mc(var, listw, nsim, type = \"moran\", zero.policy = attr(listw, \"zero.policy\"),  alternative = \"greater\", spChk=NULL, return_boot=FALSE) # S3 method for class 'mc.sim' plot(x, xlim, xlab, main, sub, ..., ptype=\"density\")"},{"path":"https://r-spatial.github.io/spdep/reference/sp.mantel.mc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mantel-Hubert spatial general cross product statistic — sp.mantel.mc","text":"var numeric vector length neighbours list listw listw listw object created example nb2listw nsim number permutations type \"moran\", \"geary\" \"sokal\" criteria similarity zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE assign zero lagged value zones without   neighbours, FALSE assign NA alternative character string specifying alternative hypothesis,   must one \"greater\" (default), \"two.sided\", \"less\". spChk data vector names checked spatial objects identity integrity, TRUE, FALSE, default NULL use get.spChkOption() return_boot return object class boot equivalent permutation bootstrap rather object class htest x object plotted xlim range x axis xlab title x axis main overall title plot sub sub title plot ptype either \"density\" \"hist\" ... arguments passed ","code":""},{"path":"https://r-spatial.github.io/spdep/reference/sp.mantel.mc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mantel-Hubert spatial general cross product statistic — sp.mantel.mc","text":"list class htest mc.sim containing following components: statistic value observed Geary's C. parameter rank observed Geary's C. alternative character string describing alternative hypothesis. method character string giving method used. data.name character string giving name(s) data,   number simulations. p.value pseudo p-value test. res nsim simulated values statistic, final value observed   statistic estimate mean variance simulated distribution.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/sp.mantel.mc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Mantel-Hubert spatial general cross product statistic — sp.mantel.mc","text":"Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, p. 22-24, Haining, R. 1990 Spatial data analysis social environmental sciences, Cambridge: Cambridge University Press, p. 230–1. function checked general matrix code posted r-help list Ben Bolker 1 May 2001; another mantel() function vegan package.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/sp.mantel.mc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Mantel-Hubert spatial general cross product statistic — sp.mantel.mc","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/sp.mantel.mc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mantel-Hubert spatial general cross product statistic — sp.mantel.mc","text":"","code":"data(oldcol) sim1 <- sp.mantel.mc(COL.OLD$CRIME, nb2listw(COL.nb),  nsim=99, type=\"geary\", alternative=\"two.sided\") sim1 #>  #> \tMantel permutation test for geary measure #>  #> data:  COL.OLD$CRIME  #> weights: nb2listw(COL.nb)  #> number of simulations + 1: 100  #>  #> statistic = 51.927, observed rank = 1, p-value = 0.02 #> alternative hypothesis: two.sided #> sample estimates: #> mean of permutations   sd of permutations  #>            98.852997             8.934135  #>  plot(sim1)  sp.mantel.mc(COL.OLD$CRIME, nb2listw(COL.nb), nsim=99,  type=\"sokal\", alternative=\"two.sided\") #>  #> \tMantel permutation test for sokal measure #>  #> data:  COL.OLD$CRIME  #> weights: nb2listw(COL.nb)  #> number of simulations + 1: 100  #>  #> statistic = 36.695, observed rank = 1, p-value = 0.02 #> alternative hypothesis: two.sided #> sample estimates: #> mean of permutations   sd of permutations  #>            56.418584             3.227064  #>  sp.mantel.mc(COL.OLD$CRIME, nb2listw(COL.nb), nsim=99,  type=\"moran\") #>  #> \tMantel permutation test for moran measure #>  #> data:  COL.OLD$CRIME  #> weights: nb2listw(COL.nb)  #> number of simulations + 1: 100  #>  #> statistic = 24.526, observed rank = 100, p-value = 0.01 #> alternative hypothesis: greater #> sample estimates: #> mean of permutations   sd of permutations  #>           -0.3401381            4.5579226  #>"},{"path":"https://r-spatial.github.io/spdep/reference/spdep-defunct.html","id":null,"dir":"Reference","previous_headings":"","what":"Defunct Functions in Package spdep — spdep-defunct","title":"Defunct Functions in Package spdep — spdep-defunct","text":"functions defunct release 1.2-1.   functions moved spatialreg package.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/spdep-defunct.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Defunct Functions in Package spdep — spdep-defunct","text":"","code":"aple.plot() localAple() aple.mc() aple() lextrB() lextrW() lextrS() griffith_sone() subgraph_eigenw() mom_calc() mom_calc_int2() stsls() # S3 method for class 'stsls' impacts() GMerrorsar() # S3 method for class 'gmsar' summary() gstsls()  # S3 method for class 'gmsar' impacts() # S3 method for class 'gmsar' Hausman.test() lagmess() ME() SpatialFiltering() LR.sarlm() # S3 method for class 'sarlm' logLik() LR1.sarlm() Wald1.sarlm() # S3 method for class 'sarlm' Hausman.test() as.spam.listw() as_dgRMatrix_listw() as_dsTMatrix_listw() as_dsCMatrix_I() as_dsCMatrix_IrW() Jacobian_W() powerWeights() # S3 method for class 'lagImpact' plot() # S3 method for class 'lagImpact' print() # S3 method for class 'lagImpact' summary() # S3 method for class 'lagImpact' HPDinterval() intImpacts() can.be.simmed() eigenw() similar.listw() do_ldet() jacobianSetup() cheb_setup() mcdet_setup() eigen_setup() eigen_pre_setup() spam_setup() spam_update_setup() Matrix_setup() Matrix_J_setup() LU_setup() LU_prepermutate_setup() moments_setup() SE_classic_setup() SE_whichMin_setup() SE_interp_setup() MCMCsamp() # S3 method for class 'spautolm' MCMCsamp() # S3 method for class 'sarlm' MCMCsamp() spautolm() # S3 method for class 'spautolm' summary() spBreg_sac() # S3 method for class 'MCMC_sar_g' impacts() # S3 method for class 'MCMC_sem_g' impacts() # S3 method for class 'MCMC_sac_g' impacts() spBreg_err() spBreg_lag() # S3 method for class 'SLX' predict() lmSLX() # S3 method for class 'SLX' impacts() create_WX() # S3 method for class 'sarlm' anova() bptest.sarlm() errorsarlm() # S3 method for class 'sarlm' impacts() lagsarlm() # S3 method for class 'sarlm' predict() # S3 method for class 'sarlm.pred' print() # S3 method for class 'sarlm.pred' as.data.frame() # S3 method for class 'sarlm' residuals() # S3 method for class 'sarlm' deviance() # S3 method for class 'sarlm' coef() # S3 method for class 'sarlm' vcov() # S3 method for class 'sarlm' fitted() sacsarlm() # S3 method for class 'sarlm' summary() # S3 method for class 'sarlm' print() # S3 method for class 'summary.sarlm' print() trW()"},{"path":"https://r-spatial.github.io/spdep/reference/spdep-defunct.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Defunct Functions in Package spdep — spdep-defunct","text":"Model-fitting functions functions supporting model fitting moved spatialreg package.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/spdep.html","id":null,"dir":"Reference","previous_headings":"","what":"Return package version number — spdep","title":"Return package version number — spdep","text":"function retreives package version build information","code":""},{"path":"https://r-spatial.github.io/spdep/reference/spdep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return package version number — spdep","text":"","code":"spdep(build = FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/spdep.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return package version number — spdep","text":"build TRUE, also returns build information","code":""},{"path":"https://r-spatial.github.io/spdep/reference/spdep.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return package version number — spdep","text":"character vector one two elements","code":""},{"path":"https://r-spatial.github.io/spdep/reference/spdep.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Return package version number — spdep","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/spweights.constants.html","id":null,"dir":"Reference","previous_headings":"","what":"Provides constants for spatial weights matrices — spweights.constants","title":"Provides constants for spatial weights matrices — spweights.constants","text":"function calculates constants needed tests spatial autocorrelation general weights matrices represented listw objects. Note: spdep 0.3-32, values S1 S2 returned correctly underlying symmetric asymmetric neighbour lists, 0.3-32, S1 S2 wrong listw objects based asymmetric neighbour lists, k-nearest neighbours (thanks Luc Anselin finding bug).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/spweights.constants.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Provides constants for spatial weights matrices — spweights.constants","text":"","code":"spweights.constants(listw, zero.policy=attr(listw, \"zero.policy\"), adjust.n=TRUE) Szero(listw)"},{"path":"https://r-spatial.github.io/spdep/reference/spweights.constants.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Provides constants for spatial weights matrices — spweights.constants","text":"listw listw object example nb2listw zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; TRUE ignore zones without neighbours, FALSE fail encountered adjust.n default TRUE, FALSE number observations adjusted -neighbour observations, TRUE, number observations adjusted","code":""},{"path":"https://r-spatial.github.io/spdep/reference/spweights.constants.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Provides constants for spatial weights matrices — spweights.constants","text":"n number zones n1 n - 1 n2 n - 2 n3 n - 3 nn n * n S0 global sum weights S1 S1 sum weights S2 S2 sum weights","code":""},{"path":"https://r-spatial.github.io/spdep/reference/spweights.constants.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Provides constants for spatial weights matrices — spweights.constants","text":"Haining, R. 1990 Spatial data analysis social environmental sciences, Cambridge University Press, p. 233; Cliff, . D., Ord, J. K. 1981 Spatial processes, Pion, p. 19, 21.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/spweights.constants.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Provides constants for spatial weights matrices — spweights.constants","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/spweights.constants.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Provides constants for spatial weights matrices — spweights.constants","text":"","code":"data(oldcol) B <- spweights.constants(nb2listw(COL.nb, style=\"B\")) W <- spweights.constants(nb2listw(COL.nb, style=\"W\")) C <- spweights.constants(nb2listw(COL.nb, style=\"C\")) S <- spweights.constants(nb2listw(COL.nb, style=\"S\")) U <- spweights.constants(nb2listw(COL.nb, style=\"U\")) print(data.frame(rbind(unlist(B), unlist(W), unlist(C), unlist(S), unlist(U)),   row.names=c(\"B\", \"W\", \"C\", \"S\", \"U\"))) #>    n n1 n2 n3   nn  S0           S1           S2 #> B 49 48 47 46 2401 232 464.00000000 5.136000e+03 #> W 49 48 47 46 2401  49  23.29434146 2.048729e+02 #> C 49 48 47 46 2401  49  20.69827586 2.291085e+02 #> S 49 48 47 46 2401  49  21.25561347 2.134568e+02 #> U 49 48 47 46 2401   1   0.00862069 9.542212e-02"},{"path":"https://r-spatial.github.io/spdep/reference/ssw.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the sum of dissimilarity — ssw","title":"Compute the sum of dissimilarity — ssw","text":"function computes sum dissimilarity   observation mean (scalar vector) observations.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/ssw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the sum of dissimilarity — ssw","text":"","code":"ssw(data, id, method = c(\"euclidean\", \"maximum\",      \"manhattan\", \"canberra\", \"binary\", \"minkowski\",     \"mahalanobis\"), p = 2, cov, inverted = FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/ssw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the sum of dissimilarity — ssw","text":"data matrix observations nodes. id Node index compute cost method Character function declare distance method.     method character, method must \"mahalanobis\"     \"euclidean\", \"maximum\", \"manhattan\", \"canberra\", \"binary\"     \"minkowisk\".     method one \"euclidean\", \"maximum\",     \"manhattan\", \"canberra\", \"binary\" \"minkowisk\", see     dist details,      function used compute distance.      method=\"mahalanobis\", mahalanobis distance      computed neighbour areas.      method function, function      used compute distance. p power Minkowski distance. cov covariance matrix used compute mahalanobis    distance. inverted logical.  'TRUE', 'cov' supposed contain           inverse covariance matrix.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/ssw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the sum of dissimilarity — ssw","text":"numeric, sum dissimilarity observations   id data mean (scalar vector)   observations.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/ssw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute the sum of dissimilarity — ssw","text":"Elias T. Krainski Renato M. Assuncao","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/ssw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the sum of dissimilarity — ssw","text":"","code":"data(USArrests) n <- nrow(USArrests) ssw(USArrests, 1:n) #> [1] 3701.394 ssw(USArrests, 1:(n/2)) #> [1] 1910.214 ssw(USArrests, (n/2+1):n) #> [1] 1625.882 ssw(USArrests, 1:(n/2)) + ssw(USArrests, (n/2+1):n) #> [1] 3536.096"},{"path":"https://r-spatial.github.io/spdep/reference/subset.listw.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset a spatial weights list — subset.listw","title":"Subset a spatial weights list — subset.listw","text":"function subsets spatial weights list, retaining objects subset argument vector TRUE. present subset non-general weights lists (created nb2listw glist=NULL).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/subset.listw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset a spatial weights list — subset.listw","text":"","code":"# S3 method for class 'listw' subset(x, subset, zero.policy = attr(x, \"zero.policy\"), ...)"},{"path":"https://r-spatial.github.io/spdep/reference/subset.listw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset a spatial weights list — subset.listw","text":"x object class listw subset logical expression zero.policy default attr(x, \"zero.policy\") set x created, attribute set, use global option value; FALSE stop error empty neighbour sets, TRUE permit weights list formed zero-length weights vectors - passed nb2listw ... generic function pass-","code":""},{"path":"https://r-spatial.github.io/spdep/reference/subset.listw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset a spatial weights list — subset.listw","text":"function returns object class listw component style input object, component neighbours list integer vectors containing neighbour region number ids (compacted run 1:number regions subset), component weights weights computed neighbours using style. -neighbour observations created subsetting zero.policy input weights object FALSE, set TRUE warning issued.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/subset.listw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Subset a spatial weights list — subset.listw","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/subset.listw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset a spatial weights list — subset.listw","text":"","code":"col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) to.be.dropped <- c(31, 34, 36, 39, 42, 46) pre <- nb2listw(col.gal.nb) print(pre) #> Characteristics of weights list object: #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.579342  #> Average number of links: 4.693878  #>  #> Weights style: W  #> Weights constants summary: #>    n   nn S0       S1       S2 #> W 49 2401 49 23.48489 204.6687 post <- subset(pre, !(1:length(col.gal.nb) %in% to.be.dropped)) print(post) #> Characteristics of weights list object: #> Neighbour list object: #> Number of regions: 43  #> Number of nonzero links: 212  #> Percentage nonzero weights: 11.46566  #> Average number of links: 4.930233  #>  #> Weights style: W  #> Weights constants summary: #>    n   nn S0       S1       S2 #> W 43 1849 43 19.26584 178.4604 columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) nb <- poly2nb(columbus) lw <- nb2listw(nb, style=\"W\") attr(lw, \"zero.policy\") #> [1] FALSE (lwa <- subset(lw, 1:nrow(columbus) != c(21))) #> Warning: subsetting caused increase in subgraph count #> Characteristics of weights list object: #> Neighbour list object: #> Number of regions: 48  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.982639  #> Average number of links: 4.791667  #> 2 disjoint connected subgraphs #>  #> Weights style: W  #> Weights constants summary: #>    n   nn S0       S1       S2 #> W 48 2304 48 22.46811 199.4398 attr(lwa, \"zero.policy\") #> [1] FALSE (lwb <- subset(lw, !(1:nrow(columbus) %in% c(21, 36, 39)))) #> Warning: subsetting caused increase in subgraph count #> Warning: subsetting created no-neighbour observations, zero.policy set TRUE #> Characteristics of weights list object: #> Neighbour list object: #> Number of regions: 46  #> Number of nonzero links: 216  #> Percentage nonzero weights: 10.20794  #> Average number of links: 4.695652  #> 1 region with no links: #> 46 #> 3 disjoint connected subgraphs #>  #> Weights style: W  #> Weights constants summary: #>    n   nn S0     S1       S2 #> W 45 2025 45 22.857 187.4843 attr(lwb, \"zero.policy\") #> [1] TRUE"},{"path":"https://r-spatial.github.io/spdep/reference/subset.nb.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset a neighbours list — subset.nb","title":"Subset a neighbours list — subset.nb","text":"function subsets neighbors list, retaining objects subset argument vector TRUE.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/subset.nb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset a neighbours list — subset.nb","text":"","code":"# S3 method for class 'nb' subset(x, subset, ...)"},{"path":"https://r-spatial.github.io/spdep/reference/subset.nb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset a neighbours list — subset.nb","text":"x object class nb subset logical expression ... generic function pass-","code":""},{"path":"https://r-spatial.github.io/spdep/reference/subset.nb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Subset a neighbours list — subset.nb","text":"function returns object class nb list    integer vectors containing neighbour region number ids (compacted    run 1:number regions subset).","code":""},{"path":"https://r-spatial.github.io/spdep/reference/subset.nb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Subset a neighbours list — subset.nb","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/subset.nb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Subset a neighbours list — subset.nb","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) coords <- st_coordinates(st_centroid(columbus)) #> Warning: st_centroid assumes attributes are constant over geometries plot(col.gal.nb, coords) to.be.dropped <- c(31, 34, 36, 39, 42, 46) text(coords[to.be.dropped,1], coords[to.be.dropped,2], labels=to.be.dropped,   pos=2, offset=0.3) sub.col.gal.nb <- subset(col.gal.nb,   !(1:length(col.gal.nb) %in% to.be.dropped)) plot(sub.col.gal.nb, coords[-to.be.dropped,], col=\"red\", add=TRUE)  which(!(attr(col.gal.nb, \"region.id\") %in%   attr(sub.col.gal.nb, \"region.id\"))) #> [1] 31 34 36 39 42 46"},{"path":"https://r-spatial.github.io/spdep/reference/summary.nb.html","id":null,"dir":"Reference","previous_headings":"","what":"Print and summary function for neighbours and weights lists — summary.nb","title":"Print and summary function for neighbours and weights lists — summary.nb","text":"function prints summary measures links neighbours list. matrix coordinates given well, summary descriptive measures link lengths also printed. Print summary functions also available \"listw\" weights list objects, also reporting constants (S0, S1, S2) used inference global spatial autocorrelation statistics Moran's , Geary's C, join-count tests Getis-Ord G.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/summary.nb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print and summary function for neighbours and weights lists — summary.nb","text":"","code":"# S3 method for class 'nb' summary(object, coords=NULL, longlat = NULL, scale = 1, ...) # S3 method for class 'nb' print(x, ...) # S3 method for class 'listw' summary(object, coords, longlat, zero.policy = attr(object, \"zero.policy\"),   scale = 1, adjust.n=TRUE, ...) # S3 method for class 'listw' print(x, zero.policy = attr(x, \"zero.policy\"), ...)"},{"path":"https://r-spatial.github.io/spdep/reference/summary.nb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print and summary function for neighbours and weights lists — summary.nb","text":"object object class nb coords matrix region point coordinates SpatialPoints object sfc points object longlat TRUE point coordinates longitude-latitude decimal degrees, case distances measured kilometers; coords SpatialPoints object, value taken object ... additional arguments affecting output produced x object class nb zero.policy default attr(listw, \"zero.policy\") set listw created, attribute set, use global option value; FALSE stop error empty neighbour sets scale passed stem() control plot length adjust.n default TRUE, FALSE number observations adjusted -neighbour observations, TRUE, number observations spweights.constants adjusted","code":""},{"path":"https://r-spatial.github.io/spdep/reference/summary.nb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Print and summary function for neighbours and weights lists — summary.nb","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/summary.nb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print and summary function for neighbours and weights lists — summary.nb","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) coords <- st_centroid(st_geometry(columbus), of_largest_polygon=TRUE) col.gal.nb #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.579342  #> Average number of links: 4.693878  summary(col.gal.nb, coords) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.579342  #> Average number of links: 4.693878  #> Link number distribution: #>  #>  2  3  4  5  6  7  8  9 10  #>  7  7 13  4  9  6  1  1  1  #> 7 least connected regions: #> 1 6 31 39 42 46 47 with 2 links #> 1 most connected region: #> 20 with 10 links col.listw <- nb2listw(col.gal.nb, style=\"W\") col.listw #> Characteristics of weights list object: #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.579342  #> Average number of links: 4.693878  #>  #> Weights style: W  #> Weights constants summary: #>    n   nn S0       S1       S2 #> W 49 2401 49 23.48489 204.6687 summary(col.listw) #> Characteristics of weights list object: #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.579342  #> Average number of links: 4.693878  #> Link number distribution: #>  #>  2  3  4  5  6  7  8  9 10  #>  7  7 13  4  9  6  1  1  1  #> 7 least connected regions: #> 1 6 31 39 42 46 47 with 2 links #> 1 most connected region: #> 20 with 10 links #>  #> Weights style: W  #> Weights constants summary: #>    n   nn S0       S1       S2 #> W 49 2401 49 23.48489 204.6687 col_geoms <- st_geometry(columbus) col_geoms[21] <- st_buffer(col_geoms[21], dist=-0.05) st_geometry(columbus) <- col_geoms nb <- poly2nb(columbus) #> Warning: some observations have no neighbours; #> if this seems unexpected, try increasing the snap argument. #> Warning: neighbour object has 3 sub-graphs; #> if this sub-graph count seems unexpected, try increasing the snap argument. summary(nb) #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.579342  #> Average number of links: 4.693878  #> 1 region with no links: #> 21 #> 3 disjoint connected subgraphs #> Link number distribution: #>  #>  0  2  3  4  5  6  7  8  9 10  #>  1  5  9 12  4 10  2  4  1  1  #> 5 least connected regions: #> 1 6 42 46 47 with 2 links #> 1 most connected region: #> 20 with 10 links try(nb2listw(nb, style=\"W\")) #> Error in nb2listw(nb, style = \"W\") :  #>   Empty neighbour sets found (zero.policy: FALSE) summary(nb2listw(nb, style=\"W\", zero.policy=TRUE)) #> Characteristics of weights list object: #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.579342  #> Average number of links: 4.693878  #> 1 region with no links: #> 21 #> 3 disjoint connected subgraphs #> Link number distribution: #>  #>  0  2  3  4  5  6  7  8  9 10  #>  1  5  9 12  4 10  2  4  1  1  #> 5 least connected regions: #> 1 6 42 46 47 with 2 links #> 1 most connected region: #> 20 with 10 links #>  #> Weights style: W  #> Weights constants summary: #>    n   nn S0       S1       S2 #> W 48 2304 48 22.46811 199.4398 summary(nb2listw(nb, style=\"W\", zero.policy=TRUE), adjust.n=FALSE) #> Characteristics of weights list object: #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 230  #> Percentage nonzero weights: 9.579342  #> Average number of links: 4.693878  #> 1 region with no links: #> 21 #> 3 disjoint connected subgraphs #> Link number distribution: #>  #>  0  2  3  4  5  6  7  8  9 10  #>  1  5  9 12  4 10  2  4  1  1  #> 5 least connected regions: #> 1 6 42 46 47 with 2 links #> 1 most connected region: #> 20 with 10 links #>  #> Weights style: W  #> Weights constants summary: #>    n   nn S0       S1       S2 #> W 49 2401 48 22.46811 199.4398"},{"path":"https://r-spatial.github.io/spdep/reference/testnb.html","id":null,"dir":"Reference","previous_headings":"","what":"Test a neighbours list for symmetry — is.symmetric.nb","title":"Test a neighbours list for symmetry — is.symmetric.nb","text":"Checks neighbours list symmetry/transitivity (neighbour j, j neighbour ). holds distance contiguity based neighbours, k-nearest neighbours. helper function sym.attr.nb() calls .symmetric.nb() set sym attribute needed, make.sym.nb makes non-symmetric list symmetric adding neighbors. .symmetric.glist checks list general weights corresponding neighbours symmetry symmetric neighbours.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/testnb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test a neighbours list for symmetry — is.symmetric.nb","text":"","code":"is.symmetric.nb(nb, verbose = NULL, force = FALSE) sym.attr.nb(nb) make.sym.nb(nb) old.make.sym.nb(nb) is.symmetric.glist(nb, glist)"},{"path":"https://r-spatial.github.io/spdep/reference/testnb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test a neighbours list for symmetry — is.symmetric.nb","text":"nb object class nb list integer vectors containing neighbour region number ids. verbose default NULL, use global option value; TRUE prints non-matching pairs force respect neighbours list sym attribute test anyway glist list general weights corresponding neighbours","code":""},{"path":"https://r-spatial.github.io/spdep/reference/testnb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test a neighbours list for symmetry — is.symmetric.nb","text":"TRUE symmetric, FALSE ; .symmetric.glist returns value attribute, \"d\", indicating failed symmetry largest failing value.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/testnb.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Test a neighbours list for symmetry — is.symmetric.nb","text":"new version make.sym.nb Bjarke Christensen now included. older version renamed old.make.sym.nb, comparison constitutes nice demonstration vectorising speedup using sapply lapply rather loops. -neighbour observations present, old.make.sym.nb used.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/testnb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Test a neighbours list for symmetry — is.symmetric.nb","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/testnb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test a neighbours list for symmetry — is.symmetric.nb","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) coords <- st_coordinates(st_centroid(columbus)) #> Warning: st_centroid assumes attributes are constant over geometries ind <- row.names(as(columbus, \"Spatial\")) print(is.symmetric.nb(col.gal.nb, verbose=TRUE, force=TRUE)) #> [1] TRUE k4 <- knn2nb(knearneigh(coords, k=4), row.names=ind) k4 <- sym.attr.nb(k4) print(is.symmetric.nb(k4)) #> [1] FALSE k4.sym <- make.sym.nb(k4) print(is.symmetric.nb(k4.sym)) #> [1] TRUE"},{"path":"https://r-spatial.github.io/spdep/reference/tolerance.nb.html","id":null,"dir":"Reference","previous_headings":"","what":"Function to construct edges based on a tolerance angle and a maximum distance — tolerance.nb","title":"Function to construct edges based on a tolerance angle and a maximum distance — tolerance.nb","text":"function creates object class nb (defined library spdep) containing connexion diagram. edges sites based tolerance angle maximum distance. angle directional; direction always bottow top screen.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/tolerance.nb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Function to construct edges based on a tolerance angle and a maximum distance — tolerance.nb","text":"","code":"tolerance.nb(coords, unit.angle = \"degrees\", max.dist, tolerance, rot.angle,  plot.sites=FALSE)"},{"path":"https://r-spatial.github.io/spdep/reference/tolerance.nb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Function to construct edges based on a tolerance angle and a maximum distance — tolerance.nb","text":"coords matrix data frame containing X Y coordinates study sites. unit.angle Character. measurement units angles defined: either \"degrees\" (default) \"radians\". max.dist Numeric. maximum distance edge linking two sites together. tolerance Numeric. tolerance angle site can influence another site. angle measured vertically bottom top pictures rotation points. rot.angle Numeric, optional. angle set coordinates rotated creating connexion diagram. set coordinates rotated counterclockwise. Negative values produce clockwise rotation. plot.sites Logical (TRUE, FALSE) determining site plotted graphic window. graph allows one make sure points rotated correct direction.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/tolerance.nb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Function to construct edges based on a tolerance angle and a maximum distance — tolerance.nb","text":"Even though function creates connexion diagram based tolerance angle going bottom top screen, resulting object symmetric, meaning site influences another vice versa. final object represent directional connexion network.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/tolerance.nb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Function to construct edges based on a tolerance angle and a maximum distance — tolerance.nb","text":"function returns object class nb list integer vectors  corresponding neighbour region numbers.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/tolerance.nb.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Function to construct edges based on a tolerance angle and a maximum distance — tolerance.nb","text":"function design handle large number rows coords. use function set coordinates 1500 entries memory intensive.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/tolerance.nb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Function to construct edges based on a tolerance angle and a maximum distance — tolerance.nb","text":"F. Guillaume Blanchet","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/tolerance.nb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Function to construct edges based on a tolerance angle and a maximum distance — tolerance.nb","text":"","code":"set.seed(1) ex.data<-cbind(runif(50),rexp(50))  ### Construct object of class nb with a tolerance angle of 30 degrees ### and a maximum distance of 2 m. nb.ex<-tolerance.nb(ex.data, unit.angle = \"degrees\", max.dist=1,  tolerance = 30) #> Warning: neighbour object has 3 sub-graphs  ### Construct object of class nb with a tolerance angle of 30 degrees ### and a maximum distance of 2 m. The coordinates are rotated at an angle ### of 45 degrees counterclockwise. nb.ex2<-tolerance.nb(ex.data, unit.angle = \"degrees\", max.dist=1,  tolerance = 30, rot.angle = 45) #> Warning: neighbour object has 4 sub-graphs  ### Construct object of class nb with a tolerance angle of pi/8 radians ### and a maximum distance of 1.5 m. The coordinates are rotated at ### an angle of pi/4 radians clockwise. nb.ex3<-tolerance.nb(ex.data, unit.angle = \"radians\", max.dist=1.5,  tolerance = pi/8, rot.angle = -pi*2/3) #> Warning: neighbour object has 5 sub-graphs  par(mfrow=c(1,3)) plot(nb.ex,ex.data,asp=1) plot(nb.ex2,ex.data,asp=1) plot(nb.ex3,ex.data,asp=1)"},{"path":"https://r-spatial.github.io/spdep/reference/tri2nb.html","id":null,"dir":"Reference","previous_headings":"","what":"Neighbours list from tri object — tri2nb","title":"Neighbours list from tri object — tri2nb","text":"function uses deldir package convert matrix two-dimensional coordinates neighbours list class nb list integer vectors containing neighbour region number ids.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/tri2nb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Neighbours list from tri object — tri2nb","text":"","code":"tri2nb(coords, row.names = NULL)"},{"path":"https://r-spatial.github.io/spdep/reference/tri2nb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Neighbours list from tri object — tri2nb","text":"coords matrix, data.frame tibble point coordinates two columns, SpatialPoints object sfc points object row.names character vector region ids added neighbours list attribute region.id, default seq(1, nrow(x))","code":""},{"path":"https://r-spatial.github.io/spdep/reference/tri2nb.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Neighbours list from tri object — tri2nb","text":"coordinates duplicated, function used. coordinates grid, need ordered first three collinear, first triangle can constructed. can achieved randomising order coordinates (possibly several times), re-ordering order data match new order neighbour list - fix used, remember re-order row.names argument well coordinates! Please also note triangulation grid points give arbitrary diagonal neighbours, may sensible outcome, dnearneigh() may serve better tri2nb() used.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/tri2nb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Neighbours list from tri object — tri2nb","text":"function returns object class nb list integer vectors containing neighbour region number ids.","code":""},{"path":"https://r-spatial.github.io/spdep/reference/tri2nb.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Neighbours list from tri object — tri2nb","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/tri2nb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Neighbours list from tri object — tri2nb","text":"","code":"columbus <- st_read(system.file(\"shapes/columbus.gpkg\", package=\"spData\")[1], quiet=TRUE) coords <- st_centroid(st_geometry(columbus), of_largest_polygon=TRUE) ind <- row.names(columbus) suppressPackageStartupMessages(require(deldir)) col.tri.nb <- tri2nb(coords, row.names=ind) plot(st_geometry(columbus), border=\"grey\") plot(col.tri.nb, coords, add=TRUE) title(main=\"Raw triangulation links\", cex.main=0.6)  x <- seq(0,1,0.1) y <- seq(0,2,0.2) xy <- expand.grid(x, y) try(xy.nb <- tri2nb(xy)) seed <- 1234 xid <- sample(1:nrow(xy)) xy.nb <- tri2nb(xy[xid,]) plot(xy.nb, xy[xid,])  # example of reading points with readr::read_csv() yielding a tibble load(system.file(\"etc/misc/coords.rda\", package=\"spdep\")) class(coords) #> [1] \"spec_tbl_df\" \"tbl_df\"      \"tbl\"         \"data.frame\"  nb <- tri2nb(coords) plot(nb, coords)"},{"path":"https://r-spatial.github.io/spdep/reference/write.nb.gal.html","id":null,"dir":"Reference","previous_headings":"","what":"Write a neighbours list as a GAL lattice file — write.nb.gal","title":"Write a neighbours list as a GAL lattice file — write.nb.gal","text":"Write neighbours list GAL lattice file, may also use newer GeoDa header format","code":""},{"path":"https://r-spatial.github.io/spdep/reference/write.nb.gal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write a neighbours list as a GAL lattice file — write.nb.gal","text":"","code":"write.nb.gal(nb, file, oldstyle=TRUE, shpfile=NULL, ind=NULL)"},{"path":"https://r-spatial.github.io/spdep/reference/write.nb.gal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write a neighbours list as a GAL lattice file — write.nb.gal","text":"nb object class nb list integer vectors containing neighbour region number ids. file name file GAL lattice data oldstyle TRUE, first line file contains number spatial units, FALSE, uses newer GeoDa style shpfile Shapefile name taken GAL file dataset ind region id indicator variable name","code":""},{"path":"https://r-spatial.github.io/spdep/reference/write.nb.gal.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Write a neighbours list as a GAL lattice file — write.nb.gal","text":"Roger Bivand Roger.Bivand@nhh.","code":""},{"path":[]},{"path":"https://r-spatial.github.io/spdep/reference/write.nb.gal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write a neighbours list as a GAL lattice file — write.nb.gal","text":"","code":"col.gal.nb <- read.gal(system.file(\"weights/columbus.gal\", package=\"spData\")[1]) GALfile <- tempfile(\"GAL\") write.nb.gal(col.gal.nb, GALfile) col.queen <- read.gal(GALfile) summary(diffnb(col.queen, col.gal.nb)) #> Warning: neighbour object has 49 sub-graphs #> Neighbour list object: #> Number of regions: 49  #> Number of nonzero links: 0  #> Percentage nonzero weights: 0  #> Average number of links: 0  #> 49 regions with no links: #> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, #> 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, #> 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49 #> 49 disjoint connected subgraphs #> Link number distribution: #>  #>  0  #> 49"},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-13-6-development","dir":"Changelog","previous_headings":"","what":"Version 1.3-6 (development)","title":"Version 1.3-6 (development)","text":"CRAN release: 2024-09-13 adding vignette desribing recent changes poly2nb #162, subgraph -neighbour (island) handling adding prototype LICD ESDA function licd_multi hotspot method add read.swmdbf2listw #163 reading DBF files exported ArcGIS representing SWM objects; note problems observation IDs known, see help file #162 add option -neighbour checking poly2nb - default report whether -neighbour observations present #162 change default snap= argument poly2nb 10mm Condition forthcoming tmap 4 #160 handle n.comp.nb delay print.nb elsewhere total number neighbours large","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-13-5-2024-06-10","dir":"Changelog","previous_headings":"","what":"Version 1.3-5 (2024-06-10)","title":"Version 1.3-5 (2024-06-10)","text":"CRAN release: 2024-06-10 #157 migrate ESRI Shapefile GPKG files; convert bhicv.shp GPKG #155 Throw error hotspot despatched object without \"quadr\" attribute #154 turn s2 vignette","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-13-4-2024-05-31","dir":"Changelog","previous_headings":"","what":"Version 1.3-4 (2024-05-31)","title":"Version 1.3-4 (2024-05-31)","text":"CRAN release: 2024-05-31 add scale argument geary.test, geary.mc geary #151, appropriate tests Introduce error knearneigh k less largest count identical points; encountered, increase k remove spurious warning knearneigh longlat geometries fix https://github.com/edzer/sdsr/issues/121, wrong assignment old test names lmRStests fix #144 plot.nb nb2lines","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-13-3-2024-02-07","dir":"Changelog","previous_headings":"","what":"Version 1.3-3 (2024-02-07)","title":"Version 1.3-3 (2024-02-07)","text":"CRAN release: 2024-02-07 change lm.LMtests lm.RStests re-name Lagrange multiplier Rao’s score; add GNM_ prefix test names input object inherits SlX created spatialreg::lmSLX (Koley, forthcoming) add SD.RStests implementation Rao’s score tests spatial Durbin models (Koley Bera, 2024) SDEM models (Koley, forthcoming) #143 row.names pass-poly2nb corrected, harmonised row.names pass-also nbdists dnearneigh #139 add na.action argument geary.test, geary.mc globalG.test add style sn2listw use tri2nb","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-13-1-2023-11-23","dir":"Changelog","previous_headings":"","what":"Version 1.3-1 (2023-11-23)","title":"Version 1.3-1 (2023-11-23)","text":"CRAN release: 2023-11-23 functions creating nb objects now warn object sub-graph count > 1 get.SubgraphOption TRUE (default FALSE): complement.nb, diffnb, dnearneigh, droplinks, edit.nb, graph2nb, knn2nb, nb2blocknb, nblag, nblag_cumul, poly2nb, read.gal, read.gwt2nb, setdiff.nb, tolerance.nb, tri2nb, union.nb summary.nb, print.nb, summary.listw print.listw now report subgraph count n.comp.nb one subset.nb now reports subgraph count neighbour object increases subsetting adding zero.policy attribute functions creating listw objects: nb2listw, sn2listw, mat2listw, nb2listwdist. Default zero.policy= argument updated use attr(., \"zero.policy\") summary.listw, print.listw, moran, moran.test, moran.mc, moran.plot, geary.mc, geary, geary.test, globalG.test, joincount.test, joincount.mc, joincount.multi, localC, localC_perm, localmoran, localmoran_perm, localG, localG_perm, lee, lee.test, lee.mc, lm.morantest, lm.LMtests, sp.mantel.mc, listw2star, lag.listw, lm.morantest, lm.LMtests, subset.listw, EBImoran.mc, LOSH, LOSH.mc, LOSH.cs, lm.morantest.exactand lm.morantest.sad confusing error message moran.plot() -neighbour cases, zero.policy=FALSE replace rgrass7 rgrass vignette fix #133 (edit.nb affected attaching sp)","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-12-8-2023-02-28","dir":"Changelog","previous_headings":"","what":"Version 1.2-8 (2023-02-28)","title":"Version 1.2-8 (2023-02-28)","text":"CRAN release: 2023-02-28 mat2listw() warning style= argument given, M\" given https://github.com/r-spatial/spatialreg/issues/24, https://github.com/r-spatial/spatialreg/issues/23. remaining users run_perm() - localC(), localmoran_bv() local_joincount_uni() get no_repeat_in_row= arguments. Address 2) #124; localG_perm() localmoran_perm() get no_repeat_in_row= arguments use conditional permutation without replacement sample vectors; default implementation uses sampling replacement, acceptable across simulation draws, arguably less acceptable within draws. Feedback valued. Address 1) #124; localG_perm() localG() now return analytical standard deviates. standard deviates simulated distributions now returned attr(., \"internals\")[,\"StdDev.Gi\"] localG_perm(), p-values, etc. move sp Depends Imports, reduce visual impression sp objects required spdep; sf objects now preferred, sp objects can used , although users may need attach sp expliciitly. fix #121 #123; correcting returned values localG_perm() estimating G-star measure (fix self x values weights) address #120, moving documentation listw2U() ?lm.morantest ?nb2listw addressing #119 interpretation moran_bv() results adding #116, René Westerholt fix #113, low R version grDevices::hcl.colors() addressing #111 Josiah Parry PRs René Westerholt, ending #109, local GS measure","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-12-7-2022-10-01","dir":"Changelog","previous_headings":"","what":"Version 1.2-7 (2022-10-01)","title":"Version 1.2-7 (2022-10-01)","text":"CRAN release: 2022-10-01 #103 refactoring local joincount test Josiah Parry add hotspot methods localmoran (analytical, permutation, Saddlepoint exact), localC (univariate multivariate) localG (analytical permutation) #95 add \"two.sided\" lee.mc(), sp.mantel.mc(), EBImoran.mc(), joincount.mc(), geary.mc() #92, #93, #94, #96, #97 contributions prototype bivariate Moran, local bivariate Moran local joincount bivariate joincount tests Josiah Parry #91 tolerance.nb() update F. Guillaume Blanchet updating coercion Matrix 1.4-2 fix ncpus issue dontrun examples remove suggested packages rgdal, rgeos, maptools","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-12-5-2022-08-11","dir":"Changelog","previous_headings":"","what":"Version 1.2-5 (2022-08-11)","title":"Version 1.2-5 (2022-08-11)","text":"CRAN release: 2022-08-11 permit use data.frame tibble matrix functions creating neighbour objects 2D points (preferred use object inheriting `\"SpatialPoints\" \"sfc\") fix #87 wrong logic infinite weights nb2listwdist() https://github.com/r-spatial/s2/pull/174 speeds dnearneigh() geographical coordinates without using s2::s2_closest_edges(). Adapting vignettes absence rgdal maptools","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-12-4-2022-04-18","dir":"Changelog","previous_headings":"","what":"Version 1.2-4 (2022-04-18)","title":"Version 1.2-4 (2022-04-18)","text":"CRAN release: 2022-04-18 added remove.self(), thanks Josiah Parry #83. unescape underscores help pages.","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-12-3-2022-03-29","dir":"Changelog","previous_headings":"","what":"Version 1.2-3 (2022-03-29)","title":"Version 1.2-3 (2022-03-29)","text":"CRAN release: 2022-03-29 replace deprecated S-compatibility macros DOUBLE_ #81 improved dnearneigh() help page. #79 remove \"htest\" class LOSH.mc() output object. Added GA SI article citations.","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-12-2-2022-01-28","dir":"Changelog","previous_headings":"","what":"Version 1.2-2 (2022-01-28)","title":"Version 1.2-2 (2022-01-28)","text":"CRAN release: 2022-01-28 Replace rainbow() hcl.colors(..., \"Set 2\") plot.skater(). Add link R-sig-geo thread EBlocal() NaN estimates many counts zero help page. Revise add documentation object returned localC_perm() #68 #72 #73 #74 #75 #76 localmoran.sad(), localmoran.exact() localmoran.exact.alt() now use multiple compute nodes needed; Omega used, multiple cores may need memory #77 s2 > 1.0.7, use indexed distances dnearneigh() https://github.com/r-spatial/s2/pull/162.","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-12-1-2022-01-05","dir":"Changelog","previous_headings":"","what":"Version 1.2-1 (2022-01-05)","title":"Version 1.2-1 (2022-01-05)","text":"CRAN release: 2022-01-04 Switching deprecated functions moved spatialreg defunct.","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-11-13-2021-12-14","dir":"Changelog","previous_headings":"","what":"Version 1.1-13 (2021-12-14)","title":"Version 1.1-13 (2021-12-14)","text":"CRAN release: 2021-12-14 Recent changes poly2nb() reduced recently (1.1-8) removed use snap= finding candidate neighbours; many thanks Matilda Brown clear well-documented issue #65 Add local Geary’s C #66 thanks Josiah Parry, discussion work #68 localmoran_perm() returns look-folded rank p-values","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-11-12-2021-11-09","dir":"Changelog","previous_headings":"","what":"Version 1.1-12 (2021-11-09)","title":"Version 1.1-12 (2021-11-09)","text":"CRAN release: 2021-11-09 poly2nb(), reverted removal legacy interpreted overlapping envelope code sp objects coerced sf without rgeos. Add Fortran character handling USE_FC_LEN_T WRE §6.6.1. Checks OK forthcoming deldir 1.0-0. Fixes #62 clarifying dnearneigh() help page","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-11-11-2021-09-07","dir":"Changelog","previous_headings":"","what":"Version 1.1-11 (2021-09-07)","title":"Version 1.1-11 (2021-09-07)","text":"CRAN release: 2021-09-07 knearneigh() nbdists(); added prototype adaptation s2 unprojected coordinates, used sf_use_s2() TRUE became default sf 1.0.0 https://github.com/r-spatial/s2/issues/125. activated default. dnearneigh() can choose prototype s2 approach sf_use_s2() TRUE use_s2=TRUE unprojected coordinates; https://github.com/r-spatial/s2/issues/125 seems distance thresholds present use brute-force rather spatial indexing. Use activated default. poly2nb() now uses sf::st_intersects() find candidate neighbours unless findInBounds= NULL. spatial indexing, fast scales well large data sets. sf_use_s2() TRUE, sf::st_intersects() passes geometries s2::s2_intersects_matrix(), also uses spatial indexing fast, scaling well large data sets. localmoran() localmoran_perm() return cluster quadrants attribute three splits, zeros, means medians variable interest spatial lag. localmoran_perm() returns skewness kurtosis permutation samples.","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-11-8-2021-05-23","dir":"Changelog","previous_headings":"","what":"Version 1.1-8 (2021-05-23)","title":"Version 1.1-8 (2021-05-23)","text":"CRAN release: 2021-05-23 #55 related #20 cycling order setting grids provoked re-design interface cell2nb(), passing \"GridTopology\" \"SpatialGrid\" objects unnamed first x= argument. Coerce \"RasterLayer\" similar raster, terra stars objects sp class objects first need . working renewing arguments cell2nb(), useful add tinytest support, now present function may extended functions creating \"nb\" objects. #58 contributed Jeff Sauer Levi Wolf (https://doi.org/10.31219/osf.io/ugkhp) providing conditional standard deviates local Moran’s Error assignment matrix detected CRAN check SIDS vignette, section median polish","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-11-7-2021-04-03","dir":"Changelog","previous_headings":"","what":"Version 1.1-7 (2021-04-03)","title":"Version 1.1-7 (2021-04-03)","text":"CRAN release: 2021-04-03 Changes continuous integration vignettes. Error poly2nb(, queen=FALSE) sf grids (double counting closed polygon start/end points), https://github.com/r-spatial/spdep/issues/50, thanks Christopher Kenny. Adding local Moran local G conditional permutation: localmoran_perm() localG_perm(). Adding nb2listwdist() contributed René Westerholt. Adding use sf GEOS find polygon contiguity candidates poly2nb() geometry count >= 500 - uses intersections polygon envelopes. #38, #53 removing RANN, adding dbscan suggestions fast dnearneigh() knearneigh() via use_kd_tree= argument fast planar neighbour set finding 2D 3D. Affects soi.graph() , used RANN. #54 avoid partial matching glist= handling. Disambiguating spdep spatialreg model output object class names prior making spdep model fitting functions defunct.","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-11-5-2020-06-29","dir":"Changelog","previous_headings":"","what":"Version 1.1-5 (2020-06-29)","title":"Version 1.1-5 (2020-06-29)","text":"CRAN release: 2020-06-29 Replacing broken geoda URLs, moving knitr rmarkdown, work-around missing weights files spData.","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-11-3-2019-09-18","dir":"Changelog","previous_headings":"","what":"Version 1.1-3 (2019-09-18)","title":"Version 1.1-3 (2019-09-18)","text":"CRAN release: 2019-09-18 small maintenance update accommodate forthcoming change spData (dataset used example spdep spData changing name; name involved putting “x”, “y” “xyz” global environment lazy loading dataset).","code":""},{"path":"https://r-spatial.github.io/spdep/news/index.html","id":"version-11-2-2019-04-05","dir":"Changelog","previous_headings":"","what":"Version 1.1-2 (2019-04-05)","title":"Version 1.1-2 (2019-04-05)","text":"CRAN release: 2019-04-05 Follow-version spdep functions methods transferred spatialreg package marked deprecated, still exported spdep. Reverse dependencies passing released version still pass version.","code":""}]
